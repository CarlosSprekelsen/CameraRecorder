
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>websocket: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/camerarecorder/mediamtx-camera-service-go/internal/websocket/methods.go (15.6%)</option>
				
				<option value="file1">github.com/camerarecorder/mediamtx-camera-service-go/internal/websocket/server.go (27.1%)</option>
				
				<option value="file2">github.com/camerarecorder/mediamtx-camera-service-go/internal/websocket/types.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
WebSocket JSON-RPC 2.0 method registration and core method implementations.

Provides method registration system and core JSON-RPC method implementations
following the Python WebSocketJsonRpcServer patterns and project architecture standards.

Requirements Coverage:
- REQ-API-002: JSON-RPC 2.0 protocol implementation
- REQ-API-003: Request/response message handling
- REQ-API-004: Core method implementations (ping, authenticate, get_camera_list, get_camera_status)

Test Categories: Unit/Integration
API Documentation Reference: docs/api/json_rpc_methods.md
*/

package websocket

import (
        "fmt"
        "time"

        "github.com/sirupsen/logrus"
)

// registerBuiltinMethods registers all built-in JSON-RPC methods
// Following Python _register_builtin_methods patterns
func (s *WebSocketServer) registerBuiltinMethods() <span class="cov8" title="1">{
        // Core methods
        s.registerMethod("ping", s.methodPing, "1.0")
        s.registerMethod("authenticate", s.methodAuthenticate, "1.0")
        s.registerMethod("get_camera_list", s.methodGetCameraList, "1.0")
        s.registerMethod("get_camera_status", s.methodGetCameraStatus, "1.0")

        s.logger.WithField("action", "register_methods").Info("Built-in methods registered")
}</span>

// registerMethod registers a JSON-RPC method handler
func (s *WebSocketServer) registerMethod(name string, handler MethodHandler, version string) <span class="cov8" title="1">{
        s.methodsMutex.Lock()
        defer s.methodsMutex.Unlock()

        s.methods[name] = handler
        s.methodVersions[name] = version

        s.logger.WithFields(logrus.Fields{
                "method":  name,
                "version": version,
                "action":  "register_method",
        }).Debug("Method registered")
}</span>

// methodPing implements the ping method
// Following Python _method_ping implementation
func (s *WebSocketServer) methodPing(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        s.logger.WithFields(logrus.Fields{
                "client_id": client.ClientID,
                "method":    "ping",
                "action":    "method_call",
        }).Debug("Ping method called")

        // Return "pong" as specified in API documentation
        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result:  "pong",
        }, nil
}</span>

// methodAuthenticate implements the authenticate method
// Following Python _method_authenticate implementation
func (s *WebSocketServer) methodAuthenticate(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        s.logger.WithFields(logrus.Fields{
                "client_id": client.ClientID,
                "method":    "authenticate",
                "action":    "method_call",
        }).Debug("Authenticate method called")

        // Extract auth_token parameter
        authToken, ok := params["auth_token"].(string)
        if !ok || authToken == "" </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INVALID_PARAMS,
                                Message: ErrorMessages[INVALID_PARAMS],
                                Data:    "auth_token parameter is required",
                        },
                }, nil
        }</span>

        // Validate JWT token
        <span class="cov0" title="0">claims, err := s.jwtHandler.ValidateToken(authToken)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).WithFields(logrus.Fields{
                        "client_id": client.ClientID,
                        "method":    "authenticate",
                        "action":    "authentication_failed",
                }).Warn("Authentication failed")

                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    AUTHENTICATION_REQUIRED,
                                Message: "Authentication failed",
                                Data: map[string]interface{}{
                                        "reason": "Invalid or expired token",
                                },
                        },
                }, nil
        }</span>

        // Update client authentication state
        <span class="cov0" title="0">client.Authenticated = true
        client.UserID = claims.UserID
        client.Role = claims.Role
        client.AuthMethod = "jwt"

        // Calculate expiration time
        expiresAt := time.Unix(claims.EXP, 0)

        s.logger.WithFields(logrus.Fields{
                "client_id": client.ClientID,
                "user_id":   claims.UserID,
                "role":      claims.Role,
                "method":    "authenticate",
                "action":    "authentication_success",
        }).Info("Authentication successful")

        // Return authentication result following Python implementation
        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result: map[string]interface{}{
                        "authenticated": true,
                        "role":          claims.Role,
                        "permissions":   getPermissionsForRole(claims.Role),
                        "expires_at":    expiresAt.Format(time.RFC3339),
                        "session_id":    client.ClientID,
                },
        }, nil</span>
}

// methodGetCameraList implements the get_camera_list method
// Following Python _method_get_camera_list implementation
func (s *WebSocketServer) methodGetCameraList(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        s.logger.WithFields(logrus.Fields{
                "client_id": client.ClientID,
                "method":    "get_camera_list",
                "action":    "method_call",
        }).Debug("Get camera list method called")

        // Check authentication
        if !client.Authenticated </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    AUTHENTICATION_REQUIRED,
                                Message: ErrorMessages[AUTHENTICATION_REQUIRED],
                        },
                }, nil
        }</span>

        // Get camera list from camera monitor
        <span class="cov0" title="0">cameras := s.cameraMonitor.GetConnectedCameras()
        
        // Convert camera list to response format
        cameraList := make([]map[string]interface{}, 0, len(cameras))
        connectedCount := 0

        for devicePath, camera := range cameras </span><span class="cov0" title="0">{
                // Get resolution from first format if available
                resolution := ""
                if len(camera.Formats) &gt; 0 </span><span class="cov0" title="0">{
                        format := camera.Formats[0]
                        resolution = fmt.Sprintf("%dx%d", format.Width, format.Height)
                }</span>

                <span class="cov0" title="0">cameraData := map[string]interface{}{
                        "device":     devicePath,
                        "status":     string(camera.Status),
                        "name":       camera.Name,
                        "resolution": resolution,
                        "fps":        30, // Default FPS - can be enhanced later
                        "streams":    make(map[string]string), // Empty streams for now
                }

                cameraList = append(cameraList, cameraData)

                if camera.Status == "CONNECTED" </span><span class="cov0" title="0">{
                        connectedCount++
                }</span>
        }

        <span class="cov0" title="0">s.logger.WithFields(logrus.Fields{
                "client_id":      client.ClientID,
                "method":         "get_camera_list",
                "total_cameras":  len(cameras),
                "connected":      connectedCount,
                "action":         "camera_list_success",
        }).Debug("Camera list retrieved successfully")

        // Return camera list following Python implementation
        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result: map[string]interface{}{
                        "cameras":   cameraList,
                        "total":     len(cameras),
                        "connected": connectedCount,
                },
        }, nil</span>
}

// methodGetCameraStatus implements the get_camera_status method
// Following Python _method_get_camera_status implementation
func (s *WebSocketServer) methodGetCameraStatus(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        s.logger.WithFields(logrus.Fields{
                "client_id": client.ClientID,
                "method":    "get_camera_status",
                "action":    "method_call",
        }).Debug("Get camera status method called")

        // Check authentication
        if !client.Authenticated </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    AUTHENTICATION_REQUIRED,
                                Message: ErrorMessages[AUTHENTICATION_REQUIRED],
                        },
                }, nil
        }</span>

        // Extract device parameter
        <span class="cov0" title="0">device, ok := params["device"].(string)
        if !ok || device == "" </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INVALID_PARAMS,
                                Message: ErrorMessages[INVALID_PARAMS],
                                Data:    "device parameter is required",
                        },
                }, nil
        }</span>

        // Get camera status from camera monitor
        <span class="cov0" title="0">camera, exists := s.cameraMonitor.GetDevice(device)
        if !exists </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INVALID_PARAMS,
                                Message: "Camera not found",
                                Data:    fmt.Sprintf("Camera device %s not found", device),
                        },
                }, nil
        }</span>

        // Get resolution from first format if available
        <span class="cov0" title="0">resolution := ""
        if len(camera.Formats) &gt; 0 </span><span class="cov0" title="0">{
                format := camera.Formats[0]
                resolution = fmt.Sprintf("%dx%d", format.Width, format.Height)
        }</span>

        <span class="cov0" title="0">s.logger.WithFields(logrus.Fields{
                "client_id": client.ClientID,
                "device":    device,
                "method":    "get_camera_status",
                "status":    string(camera.Status),
                "action":    "camera_status_success",
        }).Debug("Camera status retrieved successfully")

        // Return camera status following Python implementation
        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result: map[string]interface{}{
                        "device":       device,
                        "status":       string(camera.Status),
                        "name":         camera.Name,
                        "resolution":   resolution,
                        "fps":          30, // Default FPS - can be enhanced later
                        "streams":      make(map[string]string), // Empty streams for now
                        "metrics":      make(map[string]interface{}), // Empty metrics for now
                        "capabilities": camera.Capabilities,
                },
        }, nil</span>
}

// getPermissionsForRole returns permissions for a given role
// Following Python role-based access control patterns
func getPermissionsForRole(role string) []string <span class="cov0" title="0">{
        switch role </span>{
        case "admin":<span class="cov0" title="0">
                return []string{"view", "control", "admin"}</span>
        case "operator":<span class="cov0" title="0">
                return []string{"view", "control"}</span>
        case "viewer":<span class="cov0" title="0">
                return []string{"view"}</span>
        default:<span class="cov0" title="0">
                return []string{}</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
WebSocket JSON-RPC 2.0 server implementation.

Provides high-performance WebSocket server with JSON-RPC 2.0 protocol support,
following the Python WebSocketJsonRpcServer patterns and project architecture standards.

Requirements Coverage:
- REQ-API-001: WebSocket JSON-RPC 2.0 API endpoint
- REQ-API-002: JSON-RPC 2.0 protocol implementation
- REQ-API-003: Request/response message handling
- REQ-API-011: API methods respond within specified time limits

Test Categories: Unit/Integration
API Documentation Reference: docs/api/json_rpc_methods.md
*/

package websocket

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "sync"
        "time"

        "github.com/camerarecorder/mediamtx-camera-service-go/internal/camera"
        "github.com/camerarecorder/mediamtx-camera-service-go/internal/config"
        "github.com/camerarecorder/mediamtx-camera-service-go/internal/logging"
        "github.com/camerarecorder/mediamtx-camera-service-go/internal/security"
        "github.com/gorilla/websocket"
        "github.com/sirupsen/logrus"
)

// WebSocketServer implements the WebSocket JSON-RPC 2.0 server
// Following Python WebSocketJsonRpcServer patterns with Go-specific optimizations
type WebSocketServer struct {
        // Configuration
        config *ServerConfig

        // Dependencies (proper dependency injection)
        configManager *config.ConfigManager
        logger        *logging.Logger
        cameraMonitor *camera.HybridCameraMonitor
        jwtHandler    *security.JWTHandler

        // WebSocket server
        upgrader websocket.Upgrader
        server   *http.Server
        running  bool

        // Client connection management
        clients       map[string]*ClientConnection
        clientsMutex  sync.RWMutex
        clientCounter int64

        // Method registration
        methods        map[string]MethodHandler
        methodsMutex   sync.RWMutex
        methodVersions map[string]string

        // Performance metrics
        metrics      *PerformanceMetrics
        metricsMutex sync.RWMutex

        // Event handling
        eventHandlers      []func(string, interface{})
        eventHandlersMutex sync.RWMutex

        // Graceful shutdown
        stopChan chan struct{}
        wg       sync.WaitGroup
}

// NewWebSocketServer creates a new WebSocket server with proper dependency injection
func NewWebSocketServer(
        configManager *config.ConfigManager,
        logger *logging.Logger,
        cameraMonitor *camera.HybridCameraMonitor,
        jwtHandler *security.JWTHandler,
) *WebSocketServer <span class="cov8" title="1">{
        if configManager == nil </span><span class="cov0" title="0">{
                panic("configManager cannot be nil - use existing internal/config/ConfigManager")</span>
        }

        <span class="cov8" title="1">if logger == nil </span><span class="cov0" title="0">{
                logger = logging.NewLogger("websocket-server")
        }</span>

        <span class="cov8" title="1">if cameraMonitor == nil </span><span class="cov0" title="0">{
                panic("cameraMonitor cannot be nil - use existing internal/camera/HybridCameraMonitor")</span>
        }

        <span class="cov8" title="1">if jwtHandler == nil </span><span class="cov0" title="0">{
                panic("jwtHandler cannot be nil - use existing internal/security/JWTHandler")</span>
        }

        // Get configuration from config manager
        <span class="cov8" title="1">cfg := configManager.GetConfig()
        if cfg == nil </span><span class="cov0" title="0">{
                panic("configuration not available - ensure config is loaded")</span>
        }

        // Create server configuration
        <span class="cov8" title="1">serverConfig := &amp;ServerConfig{
                Host:           cfg.Server.Host,
                Port:           cfg.Server.Port,
                WebSocketPath:  cfg.Server.WebSocketPath,
                MaxConnections: cfg.Server.MaxConnections,
                ReadTimeout:    cfg.Server.ReadTimeout,
                WriteTimeout:   cfg.Server.WriteTimeout,
                PingInterval:   cfg.Server.PingInterval,
                PongWait:       cfg.Server.PongWait,
                MaxMessageSize: cfg.Server.MaxMessageSize,
        }

        server := &amp;WebSocketServer{
                config:        serverConfig,
                configManager: configManager,
                logger:        logger,
                cameraMonitor: cameraMonitor,
                jwtHandler:    jwtHandler,

                // WebSocket upgrader configuration
                upgrader: websocket.Upgrader{
                        ReadBufferSize:  1024,
                        WriteBufferSize: 1024,
                        CheckOrigin: func(r *http.Request) bool </span><span class="cov0" title="0">{
                                // Allow all origins for now - can be made configurable
                                return true
                        }</span>,
                },

                // Client management
                clients:       make(map[string]*ClientConnection),
                clientCounter: 0,

                // Method registration
                methods:        make(map[string]MethodHandler),
                methodVersions: make(map[string]string),

                // Performance metrics
                metrics: &amp;PerformanceMetrics{
                        RequestCount:      0,
                        ResponseTimes:     make(map[string][]float64),
                        ErrorCount:        0,
                        ActiveConnections: 0,
                        StartTime:         time.Now(),
                },

                // Event handling
                eventHandlers: make([]func(string, interface{}), 0),

                // Graceful shutdown
                stopChan: make(chan struct{}),
        }

        // Register built-in methods
        <span class="cov8" title="1">server.registerBuiltinMethods()

        return server</span>
}

// Start starts the WebSocket server
func (s *WebSocketServer) Start() error <span class="cov8" title="1">{
        if s.running </span><span class="cov0" title="0">{
                s.logger.Warn("WebSocket server is already running")
                return nil
        }</span>

        <span class="cov8" title="1">s.logger.WithFields(logrus.Fields{
                "host":   s.config.Host,
                "port":   s.config.Port,
                "path":   s.config.WebSocketPath,
                "action": "start_server",
        }).Info("Starting WebSocket JSON-RPC server")

        // Create HTTP server
        mux := http.NewServeMux()
        mux.HandleFunc(s.config.WebSocketPath, s.handleWebSocket)

        s.server = &amp;http.Server{
                Addr:         fmt.Sprintf("%s:%d", s.config.Host, s.config.Port),
                Handler:      mux,
                ReadTimeout:  s.config.ReadTimeout,
                WriteTimeout: s.config.WriteTimeout,
        }

        // Start server in goroutine
        s.wg.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer s.wg.Done()
                if err := s.server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        s.logger.WithError(err).Error("WebSocket server failed")
                }</span>
        }()

        <span class="cov8" title="1">s.running = true

        s.logger.WithFields(logrus.Fields{
                "host":   s.config.Host,
                "port":   s.config.Port,
                "path":   s.config.WebSocketPath,
                "action": "start_server",
                "status": "success",
        }).Info("WebSocket server started successfully")

        return nil</span>
}

// Stop stops the WebSocket server gracefully
func (s *WebSocketServer) Stop() error <span class="cov8" title="1">{
        if !s.running </span><span class="cov0" title="0">{
                s.logger.Warn("WebSocket server is not running")
                return nil
        }</span>

        <span class="cov8" title="1">s.logger.Info("Stopping WebSocket server")

        // Signal shutdown
        close(s.stopChan)

        // Close all client connections
        s.clientsMutex.Lock()
        for clientID := range s.clients </span><span class="cov0" title="0">{
                s.logger.WithField("client_id", clientID).Debug("Closing client connection")
                // Note: Actual connection closing will be handled by the connection handler
        }</span>
        <span class="cov8" title="1">s.clientsMutex.Unlock()

        // Shutdown HTTP server
        if s.server != nil </span><span class="cov8" title="1">{
                ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
                defer cancel()
                if err := s.server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        s.logger.WithError(err).Error("Error shutting down HTTP server")
                }</span>
        }

        // Wait for all goroutines to finish
        <span class="cov8" title="1">s.wg.Wait()

        s.running = false

        s.logger.Info("WebSocket server stopped successfully")
        return nil</span>
}

// handleWebSocket handles WebSocket upgrade and connection management
func (s *WebSocketServer) handleWebSocket(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Check connection limit
        s.clientsMutex.RLock()
        if len(s.clients) &gt;= s.config.MaxConnections </span><span class="cov0" title="0">{
                s.clientsMutex.RUnlock()
                s.logger.Warn("Maximum connections reached")
                http.Error(w, "Maximum connections reached", http.StatusServiceUnavailable)
                return
        }</span>
        <span class="cov0" title="0">s.clientsMutex.RUnlock()

        // Upgrade HTTP connection to WebSocket
        conn, err := s.upgrader.Upgrade(w, r, nil)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).Error("Failed to upgrade connection to WebSocket")
                return
        }</span>

        // Generate client ID
        <span class="cov0" title="0">s.clientsMutex.Lock()
        s.clientCounter++
        clientID := fmt.Sprintf("client_%d", s.clientCounter)
        s.clientsMutex.Unlock()

        // Create client connection
        client := &amp;ClientConnection{
                ClientID:      clientID,
                Authenticated: false,
                ConnectedAt:   time.Now(),
                Subscriptions: make(map[string]bool),
        }

        // Add client to connections
        s.clientsMutex.Lock()
        s.clients[clientID] = client
        s.clientsMutex.Unlock()

        // Update metrics
        s.metricsMutex.Lock()
        s.metrics.ActiveConnections++
        s.metricsMutex.Unlock()

        s.logger.WithFields(logrus.Fields{
                "client_id": clientID,
                "action":    "client_connected",
        }).Info("Client connected")

        // Handle connection in goroutine
        s.wg.Add(1)
        go s.handleClientConnection(conn, client)</span>
}

// handleClientConnection handles individual client connections
func (s *WebSocketServer) handleClientConnection(conn *websocket.Conn, client *ClientConnection) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                // Remove client from connections
                s.clientsMutex.Lock()
                delete(s.clients, client.ClientID)
                s.clientsMutex.Unlock()

                // Update metrics
                s.metricsMutex.Lock()
                s.metrics.ActiveConnections--
                s.metricsMutex.Unlock()

                // Close connection
                conn.Close()

                s.logger.WithFields(logrus.Fields{
                        "client_id": client.ClientID,
                        "action":    "client_disconnected",
                }).Info("Client disconnected")

                s.wg.Done()
        }</span>()

        // Set connection parameters
        <span class="cov0" title="0">conn.SetReadLimit(s.config.MaxMessageSize)
        conn.SetReadDeadline(time.Now().Add(s.config.PongWait))
        conn.SetPongHandler(func(string) error </span><span class="cov0" title="0">{
                conn.SetReadDeadline(time.Now().Add(s.config.PongWait))
                return nil
        }</span>)

        // Start ping ticker
        <span class="cov0" title="0">ticker := time.NewTicker(s.config.PingInterval)
        defer ticker.Stop()

        // Message handling loop
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-s.stopChan:<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if err := conn.WriteControl(websocket.PingMessage, []byte{}, time.Now().Add(s.config.WriteTimeout)); err != nil </span><span class="cov0" title="0">{
                                s.logger.WithError(err).WithField("client_id", client.ClientID).Error("Failed to send ping")
                                return
                        }</span>
                default:<span class="cov0" title="0">
                        // Read message
                        _, message, err := conn.ReadMessage()
                        if err != nil </span><span class="cov0" title="0">{
                                if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) </span><span class="cov0" title="0">{
                                        s.logger.WithError(err).WithField("client_id", client.ClientID).Error("WebSocket read error")
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }

                        // Handle message
                        <span class="cov0" title="0">s.handleMessage(conn, client, message)</span>
                }
        }
}

// handleMessage processes incoming WebSocket messages
func (s *WebSocketServer) handleMessage(conn *websocket.Conn, client *ClientConnection, message []byte) <span class="cov0" title="0">{
        startTime := time.Now()

        s.logger.WithFields(logrus.Fields{
                "client_id": client.ClientID,
                "action":    "handle_message",
        }).Debug("Processing WebSocket message")

        // Parse JSON-RPC request
        var request JsonRpcRequest
        if err := json.Unmarshal(message, &amp;request); err != nil </span><span class="cov0" title="0">{
                s.sendErrorResponse(conn, nil, INVALID_PARAMS, "Invalid JSON-RPC request")
                return
        }</span>

        // Validate JSON-RPC version
        <span class="cov0" title="0">if request.JSONRPC != "2.0" </span><span class="cov0" title="0">{
                s.sendErrorResponse(conn, request.ID, INVALID_PARAMS, "Invalid JSON-RPC version")
                return
        }</span>

        // Handle request
        <span class="cov0" title="0">response, err := s.handleRequest(&amp;request, client)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).WithFields(logrus.Fields{
                        "client_id": client.ClientID,
                        "method":    request.Method,
                }).Error("Request handling error")
                s.sendErrorResponse(conn, request.ID, INTERNAL_ERROR, "Internal server error")
                return
        }</span>

        // Send response
        <span class="cov0" title="0">if err := s.sendResponse(conn, response); err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).WithField("client_id", client.ClientID).Error("Failed to send response")
                return
        }</span>

        // Record performance metrics
        <span class="cov0" title="0">duration := time.Since(startTime).Seconds()
        s.recordRequest(request.Method, duration)

        s.logger.WithFields(logrus.Fields{
                "client_id": client.ClientID,
                "method":    request.Method,
                "duration":  duration,
                "action":    "request_completed",
        }).Debug("Request completed")</span>
}

// handleRequest processes JSON-RPC requests
func (s *WebSocketServer) handleRequest(request *JsonRpcRequest, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        // Find method handler
        s.methodsMutex.RLock()
        handler, exists := s.methods[request.Method]
        s.methodsMutex.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        ID:      request.ID,
                        Error: &amp;JsonRpcError{
                                Code:    METHOD_NOT_FOUND,
                                Message: ErrorMessages[METHOD_NOT_FOUND],
                        },
                }, nil
        }</span>

        // Call method handler
        <span class="cov0" title="0">response, err := handler(request.Params, client)
        if err != nil </span><span class="cov0" title="0">{
                s.metricsMutex.Lock()
                s.metrics.ErrorCount++
                s.metricsMutex.Unlock()

                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        ID:      request.ID,
                        Error: &amp;JsonRpcError{
                                Code:    INTERNAL_ERROR,
                                Message: ErrorMessages[INTERNAL_ERROR],
                                Data:    err.Error(),
                        },
                }, nil
        }</span>

        // Set JSON-RPC version and ID
        <span class="cov0" title="0">response.JSONRPC = "2.0"
        response.ID = request.ID

        return response, nil</span>
}

// sendResponse sends a JSON-RPC response to the client
func (s *WebSocketServer) sendResponse(conn *websocket.Conn, response *JsonRpcResponse) error <span class="cov0" title="0">{
        conn.SetWriteDeadline(time.Now().Add(s.config.WriteTimeout))
        return conn.WriteJSON(response)
}</span>

// sendErrorResponse sends a JSON-RPC error response to the client
func (s *WebSocketServer) sendErrorResponse(conn *websocket.Conn, id interface{}, code int, message string) <span class="cov0" title="0">{
        response := &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                ID:      id,
                Error: &amp;JsonRpcError{
                        Code:    code,
                        Message: message,
                },
        }

        if err := s.sendResponse(conn, response); err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).Error("Failed to send error response")
        }</span>
}

// recordRequest records performance metrics for a request
func (s *WebSocketServer) recordRequest(method string, duration float64) <span class="cov0" title="0">{
        s.metricsMutex.Lock()
        defer s.metricsMutex.Unlock()

        s.metrics.RequestCount++
        if s.metrics.ResponseTimes[method] == nil </span><span class="cov0" title="0">{
                s.metrics.ResponseTimes[method] = make([]float64, 0)
        }</span>
        <span class="cov0" title="0">s.metrics.ResponseTimes[method] = append(s.metrics.ResponseTimes[method], duration)</span>
}

// GetMetrics returns current performance metrics
func (s *WebSocketServer) GetMetrics() *PerformanceMetrics <span class="cov8" title="1">{
        s.metricsMutex.RLock()
        defer s.metricsMutex.RUnlock()

        // Calculate average response time
        allResponseTimes := make([]float64, 0)
        for _, times := range s.metrics.ResponseTimes </span><span class="cov0" title="0">{
                allResponseTimes = append(allResponseTimes, times...)
        }</span>

        // Note: averageResponseTime and errorRate calculations are available for future use
        // when extending the metrics functionality

        <span class="cov8" title="1">return &amp;PerformanceMetrics{
                RequestCount:      s.metrics.RequestCount,
                ResponseTimes:     s.metrics.ResponseTimes,
                ErrorCount:        s.metrics.ErrorCount,
                ActiveConnections: s.metrics.ActiveConnections,
                StartTime:         s.metrics.StartTime,
        }</span>
}

// IsRunning returns whether the server is currently running
func (s *WebSocketServer) IsRunning() bool <span class="cov8" title="1">{
        return s.running
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
WebSocket JSON-RPC 2.0 types and structures.

Provides JSON-RPC 2.0 request, response, and notification structures
following the Python WebSocketJsonRpcServer patterns and project architecture standards.

Requirements Coverage:
- REQ-API-001: WebSocket JSON-RPC 2.0 API endpoint
- REQ-API-002: JSON-RPC 2.0 protocol implementation
- REQ-API-003: Request/response message handling

Test Categories: Unit/Integration
API Documentation Reference: docs/api/json_rpc_methods.md
*/

package websocket

import (
        "encoding/json"
        "time"
)

// JSON-RPC Error Codes (RFC 32700) - Following Python implementation
const (
        AUTHENTICATION_REQUIRED = -32001
        RATE_LIMIT_EXCEEDED     = -32002
        INSUFFICIENT_PERMISSIONS = -32003
        METHOD_NOT_FOUND        = -32601
        INVALID_PARAMS          = -32602
        INTERNAL_ERROR          = -32603

        // Enhanced Recording Management Error Codes
        ERROR_CAMERA_ALREADY_RECORDING = -1006
        ERROR_STORAGE_LOW              = -1008
        ERROR_STORAGE_CRITICAL         = -1010
)

// ErrorMessages maps error codes to their corresponding messages
// Following Python ERROR_MESSAGES dictionary
var ErrorMessages = map[int]string{
        AUTHENTICATION_REQUIRED:        "Authentication required",
        RATE_LIMIT_EXCEEDED:           "Rate limit exceeded",
        INSUFFICIENT_PERMISSIONS:      "Insufficient permissions",
        METHOD_NOT_FOUND:              "Method not found",
        INVALID_PARAMS:                "Invalid parameters",
        INTERNAL_ERROR:                "Internal server error",
        ERROR_CAMERA_ALREADY_RECORDING: "Camera is currently recording",
        ERROR_STORAGE_LOW:             "Storage space is low",
        ERROR_STORAGE_CRITICAL:        "Storage space is critical",
}

// JsonRpcRequest represents a JSON-RPC 2.0 request structure
// Following Python JsonRpcRequest dataclass
type JsonRpcRequest struct {
        JSONRPC string                 `json:"jsonrpc"`
        Method  string                 `json:"method"`
        ID      interface{}            `json:"id,omitempty"`
        Params  map[string]interface{} `json:"params,omitempty"`
}

// JsonRpcResponse represents a JSON-RPC 2.0 response structure
// Following Python JsonRpcResponse dataclass
type JsonRpcResponse struct {
        JSONRPC string      `json:"jsonrpc"`
        ID      interface{} `json:"id,omitempty"`
        Result  interface{} `json:"result,omitempty"`
        Error   *JsonRpcError `json:"error,omitempty"`
}

// JsonRpcNotification represents a JSON-RPC 2.0 notification structure
// Following Python JsonRpcNotification dataclass
type JsonRpcNotification struct {
        JSONRPC string                 `json:"jsonrpc"`
        Method  string                 `json:"method"`
        Params  map[string]interface{} `json:"params,omitempty"`
}

// JsonRpcError represents a JSON-RPC 2.0 error structure
type JsonRpcError struct {
        Code    int         `json:"code"`
        Message string      `json:"message"`
        Data    interface{} `json:"data,omitempty"`
}

// ClientConnection represents a connected WebSocket client
// Following Python ClientConnection class
type ClientConnection struct {
        ClientID      string
        Authenticated bool
        UserID        string
        Role          string
        AuthMethod    string
        ConnectedAt   time.Time
        Subscriptions map[string]bool
}

// PerformanceMetrics tracks WebSocket server performance
// Following Python PerformanceMetrics class
type PerformanceMetrics struct {
        RequestCount      int64
        ResponseTimes     map[string][]float64
        ErrorCount        int64
        ActiveConnections int64
        StartTime         time.Time
}

// MethodHandler defines the signature for JSON-RPC method handlers
type MethodHandler func(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error)

// WebSocketMessage represents a WebSocket message with metadata
type WebSocketMessage struct {
        Type      string          `json:"type"`
        Data      json.RawMessage `json:"data"`
        Timestamp time.Time       `json:"timestamp"`
        ClientID  string          `json:"client_id,omitempty"`
}

// ServerConfig contains WebSocket server configuration
// Following Python server configuration patterns
type ServerConfig struct {
        Host            string        `mapstructure:"host"`
        Port            int           `mapstructure:"port"`
        WebSocketPath   string        `mapstructure:"websocket_path"`
        MaxConnections  int           `mapstructure:"max_connections"`
        ReadTimeout     time.Duration `mapstructure:"read_timeout"`
        WriteTimeout    time.Duration `mapstructure:"write_timeout"`
        PingInterval    time.Duration `mapstructure:"ping_interval"`
        PongWait        time.Duration `mapstructure:"pong_wait"`
        MaxMessageSize  int64         `mapstructure:"max_message_size"`
}

// DefaultServerConfig returns default WebSocket server configuration
// Optimized for Epic E3 performance requirements: &lt;50ms response time, 1000+ connections
func DefaultServerConfig() *ServerConfig <span class="cov8" title="1">{
        return &amp;ServerConfig{
                Host:            "0.0.0.0",
                Port:            8002,
                WebSocketPath:   "/ws",
                MaxConnections:  1000,
                ReadTimeout:     5 * time.Second,  // Reduced for faster response detection
                WriteTimeout:    1 * time.Second,  // Reduced for faster message delivery
                PingInterval:    30 * time.Second, // Keep reasonable for connection health
                PongWait:        60 * time.Second, // Keep reasonable for connection stability
                MaxMessageSize:  1024 * 1024,      // 1MB
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
