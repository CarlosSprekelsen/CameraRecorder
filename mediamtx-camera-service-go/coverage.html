
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>websocket: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/camerarecorder/mediamtx-camera-service-go/internal/websocket/api_contract_validators.go (0.0%)</option>
				
				<option value="file1">github.com/camerarecorder/mediamtx-camera-service-go/internal/websocket/event_integration.go (0.0%)</option>
				
				<option value="file2">github.com/camerarecorder/mediamtx-camera-service-go/internal/websocket/events.go (6.9%)</option>
				
				<option value="file3">github.com/camerarecorder/mediamtx-camera-service-go/internal/websocket/methods.go (23.4%)</option>
				
				<option value="file4">github.com/camerarecorder/mediamtx-camera-service-go/internal/websocket/server.go (37.6%)</option>
				
				<option value="file5">github.com/camerarecorder/mediamtx-camera-service-go/internal/websocket/types.go (0.0%)</option>
				
				<option value="file6">github.com/camerarecorder/mediamtx-camera-service-go/internal/websocket/validation_helper.go (11.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package websocket implements API contract validation helpers
//
// This file contains validation helpers that ensure API responses match
// the documented contracts in docs/api/json_rpc_methods.md
//
// These validators enforce strict API compliance and prevent accommodation
// of incorrect responses in tests.

package websocket

import (
        "testing"

        "github.com/stretchr/testify/assert"
        "github.com/stretchr/testify/require"
)

// validateStopRecordingResponse validates stop_recording API response structure
func validateStopRecordingResponse(t *testing.T, result interface{}) <span class="cov0" title="0">{
        require.NotNil(t, result, "StopRecording result cannot be nil")

        resultMap, ok := result.(map[string]interface{})
        require.True(t, ok, "StopRecording result must be object")

        // Required fields per API documentation
        assert.Contains(t, resultMap, "device", "StopRecording must include device field")
        assert.Contains(t, resultMap, "filename", "StopRecording must include filename field")
        assert.Contains(t, resultMap, "status", "StopRecording must include status field")
        assert.Contains(t, resultMap, "start_time", "StopRecording must include start_time field")
        assert.Contains(t, resultMap, "end_time", "StopRecording must include end_time field")
        assert.Contains(t, resultMap, "duration", "StopRecording must include duration field")
        assert.Contains(t, resultMap, "file_size", "StopRecording must include file_size field")
        assert.Contains(t, resultMap, "format", "StopRecording must include format field")

        // Validate field types
        assert.IsType(t, "", resultMap["device"], "device must be string")
        assert.IsType(t, "", resultMap["filename"], "filename must be string")
        assert.IsType(t, "", resultMap["status"], "status must be string")
        assert.IsType(t, "", resultMap["format"], "format must be string")

        // Validate status values
        validStatuses := []string{"STOPPED", "FAILED"}
        assert.Contains(t, validStatuses, resultMap["status"], "status must be valid value")
}</span>

// validateStartRecordingResponse validates start_recording API response structure
func validateStartRecordingResponse(t *testing.T, result interface{}) <span class="cov0" title="0">{
        require.NotNil(t, result, "StartRecording result cannot be nil")

        resultMap, ok := result.(map[string]interface{})
        require.True(t, ok, "StartRecording result must be object")

        // Required fields per API documentation
        assert.Contains(t, resultMap, "device", "StartRecording must include device field")
        assert.Contains(t, resultMap, "filename", "StartRecording must include filename field")
        assert.Contains(t, resultMap, "status", "StartRecording must include status field")
        assert.Contains(t, resultMap, "start_time", "StartRecording must include start_time field")
        assert.Contains(t, resultMap, "format", "StartRecording must include format field")

        // Validate status values
        validStatuses := []string{"RECORDING", "FAILED"}
        assert.Contains(t, validStatuses, resultMap["status"], "status must be valid value")
}</span>

// validateTakeSnapshotResponse validates take_snapshot API response structure
func validateTakeSnapshotResponse(t *testing.T, result interface{}) <span class="cov0" title="0">{
        require.NotNil(t, result, "TakeSnapshot result cannot be nil")

        resultMap, ok := result.(map[string]interface{})
        require.True(t, ok, "TakeSnapshot result must be object")

        // Required fields per API documentation
        assert.Contains(t, resultMap, "device", "TakeSnapshot must include device field")
        assert.Contains(t, resultMap, "filename", "TakeSnapshot must include filename field")
        assert.Contains(t, resultMap, "status", "TakeSnapshot must include status field")
        assert.Contains(t, resultMap, "timestamp", "TakeSnapshot must include timestamp field")
        assert.Contains(t, resultMap, "file_size", "TakeSnapshot must include file_size field")
        assert.Contains(t, resultMap, "file_path", "TakeSnapshot must include file_path field")

        // Validate status values
        validStatuses := []string{"success", "failed"}
        assert.Contains(t, validStatuses, resultMap["status"], "status must be valid value")
}</span>

// validateRecordingSpecificError validates that recording method errors are recording-related
func validateRecordingSpecificError(t *testing.T, errorCode int, method string) <span class="cov0" title="0">{
        validRecordingErrors := []int{
                CAMERA_NOT_FOUND,
                RECORDING_IN_PROGRESS,
                ERROR_CAMERA_NOT_FOUND,
                ERROR_CAMERA_NOT_AVAILABLE,
                ERROR_RECORDING_IN_PROGRESS,
                ERROR_MEDIAMTX_ERROR,
                INSUFFICIENT_STORAGE,
        }

        assert.Contains(t, validRecordingErrors, errorCode,
                "Method %s should return recording-specific errors, not system errors. Got error code: %d",
                method, errorCode)
}</span>

// validateAPICompliantError validates error follows JSON-RPC 2.0 and API specification
func validateAPICompliantError(t *testing.T, err *JsonRpcError) <span class="cov0" title="0">{
        require.NotNil(t, err, "Error cannot be nil")

        // Validate error code is defined in API specification
        validErrorCodes := []int{
                // Standard JSON-RPC 2.0 errors
                -32600, -32601, -32602, -32603,
                // Service-specific errors
                AUTHENTICATION_REQUIRED, RATE_LIMIT_EXCEEDED, INSUFFICIENT_PERMISSIONS,
                CAMERA_NOT_FOUND, RECORDING_IN_PROGRESS, MEDIAMTX_UNAVAILABLE,
                INSUFFICIENT_STORAGE, CAPABILITY_NOT_SUPPORTED,
                // Enhanced recording errors
                ERROR_CAMERA_NOT_FOUND, ERROR_CAMERA_NOT_AVAILABLE,
                ERROR_RECORDING_IN_PROGRESS, ERROR_MEDIAMTX_ERROR,
        }

        assert.Contains(t, validErrorCodes, err.Code,
                "Error code %d is not defined in API specification", err.Code)

        // Validate error message is not empty
        assert.NotEmpty(t, err.Message, "Error message cannot be empty")

        // Validate error data exists
        assert.NotNil(t, err.Data, "Error data should exist")
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Event System Integration Layer

Connects camera monitor and other components to the WebSocket event system,
implementing the EventNotifier interface for seamless event propagation.

Requirements Coverage:
- REQ-API-001: Efficient event delivery
- REQ-API-002: Component integration
- REQ-API-003: Event routing

Test Categories: Unit/Integration
API Documentation Reference: docs/api/json_rpc_methods.md
*/

package websocket

import (
        "time"

        "github.com/camerarecorder/mediamtx-camera-service-go/internal/camera"
        "github.com/camerarecorder/mediamtx-camera-service-go/internal/logging"
)

// EventIntegration connects camera monitor and other components to the event system
type EventIntegration struct {
        eventManager *EventManager
        logger       *logging.Logger
}

// NewEventIntegration creates a new event integration layer
func NewEventIntegration(eventManager *EventManager, logger *logging.Logger) *EventIntegration <span class="cov0" title="0">{
        return &amp;EventIntegration{
                eventManager: eventManager,
                logger:       logger,
        }
}</span>

// CameraEventNotifier implements the camera.EventNotifier interface
type CameraEventNotifier struct {
        eventManager *EventManager
        mapper       DeviceToCameraIDMapper // For device path to camera ID conversion
        logger       *logging.Logger
}

// DeviceToCameraIDMapper interface for event abstraction
type DeviceToCameraIDMapper interface {
        GetCameraForDevicePath(devicePath string) (string, bool)
        GetDevicePathForCamera(cameraID string) (string, bool)
}

// NewCameraEventNotifier creates a new camera event notifier
func NewCameraEventNotifier(eventManager *EventManager, mapper DeviceToCameraIDMapper, logger *logging.Logger) *CameraEventNotifier <span class="cov0" title="0">{
        return &amp;CameraEventNotifier{
                eventManager: eventManager,
                mapper:       mapper,
                logger:       logger,
        }
}</span>

// NotifyCameraConnected notifies when a camera is connected
func (n *CameraEventNotifier) NotifyCameraConnected(device *camera.CameraDevice) <span class="cov0" title="0">{
        // Check for nil device to prevent panic
        if device == nil </span><span class="cov0" title="0">{
                n.logger.Error("Cannot notify camera connected: device is nil")
                return
        }</span>

        // Convert device path to camera ID using proper abstraction layer
        <span class="cov0" title="0">cameraID, exists := n.mapper.GetCameraForDevicePath(device.Path)
        if !exists </span><span class="cov0" title="0">{
                n.logger.WithField("device_path", device.Path).Warning("Could not map device path to camera ID - skipping event")
                return // Skip unmapped devices to prevent runtime errors
        }</span>

        // Event payload matching JSON-RPC API specification
        <span class="cov0" title="0">eventData := logging.Fields{
                "device":      cameraID,    // API spec: "device" field with camera identifier
                "device_path": device.Path, // Internal metadata only
                "name":        device.Name,
                "status":      string(device.Status),
                "driver":      device.Capabilities.DriverName,
                "card_name":   device.Capabilities.CardName,
                "timestamp":   time.Now().Format(time.RFC3339),
        }

        if err := n.eventManager.PublishEvent(TopicCameraConnected, eventData); err != nil </span><span class="cov0" title="0">{
                n.logger.WithError(err).WithField("device", cameraID).Error("Failed to publish camera connected event")
        }</span> else<span class="cov0" title="0"> {
                n.logger.WithFields(logging.Fields{
                        "device": cameraID,
                        "name":   device.Name,
                        "topic":  TopicCameraConnected,
                }).Info("Published camera connected event")
        }</span>
}

// NotifyCameraDisconnected notifies when a camera is disconnected
func (n *CameraEventNotifier) NotifyCameraDisconnected(devicePath string) <span class="cov0" title="0">{
        // Convert device path to camera ID using proper abstraction layer
        cameraID, exists := n.mapper.GetCameraForDevicePath(devicePath)
        if !exists </span><span class="cov0" title="0">{
                n.logger.WithField("device_path", devicePath).Warning("Could not map device path to camera ID - skipping event")
                return // Skip unmapped devices to prevent runtime errors
        }</span>

        // Event payload matching JSON-RPC API specification
        <span class="cov0" title="0">eventData := logging.Fields{
                "device":      cameraID,   // API spec: "device" field with camera identifier
                "device_path": devicePath, // Internal metadata only
                "status":      "disconnected",
                "timestamp":   time.Now().Format(time.RFC3339),
        }

        if err := n.eventManager.PublishEvent(TopicCameraDisconnected, eventData); err != nil </span><span class="cov0" title="0">{
                n.logger.WithError(err).WithField("device", cameraID).Error("Failed to publish camera disconnected event")
        }</span> else<span class="cov0" title="0"> {
                n.logger.WithFields(logging.Fields{
                        "device": cameraID,
                        "topic":  TopicCameraDisconnected,
                }).Info("Published camera disconnected event")
        }</span>
}

// NotifyCameraStatusChange notifies when camera status changes
func (n *CameraEventNotifier) NotifyCameraStatusChange(device *camera.CameraDevice, oldStatus, newStatus camera.DeviceStatus) <span class="cov0" title="0">{
        // Check for nil device to prevent panic
        if device == nil </span><span class="cov0" title="0">{
                n.logger.Error("Cannot notify camera status change: device is nil")
                return
        }</span>

        // Convert device path to camera ID using proper abstraction layer
        <span class="cov0" title="0">cameraID, exists := n.mapper.GetCameraForDevicePath(device.Path)
        if !exists </span><span class="cov0" title="0">{
                n.logger.WithField("device_path", device.Path).Warning("Could not map device path to camera ID - skipping event")
                return // Skip unmapped devices to prevent runtime errors
        }</span>

        // Event payload matching JSON-RPC API specification: device (camera identifier) primary
        <span class="cov0" title="0">eventData := logging.Fields{
                "device":      cameraID,
                "device_path": device.Path,
                "name":        device.Name,
                "old_status":  string(oldStatus),
                "new_status":  string(newStatus),
                "timestamp":   time.Now().Format(time.RFC3339),
        }

        if err := n.eventManager.PublishEvent(TopicCameraStatusChange, eventData); err != nil </span><span class="cov0" title="0">{
                n.logger.WithError(err).WithField("device", cameraID).Error("Failed to publish camera status change event")
        }</span> else<span class="cov0" title="0"> {
                n.logger.WithFields(logging.Fields{
                        "device":     cameraID,
                        "old_status": oldStatus,
                        "new_status": newStatus,
                        "topic":      TopicCameraStatusChange,
                }).Info("Published camera status change event")
        }</span>
}

// NotifyCapabilityDetected notifies when camera capabilities are detected
func (n *CameraEventNotifier) NotifyCapabilityDetected(device *camera.CameraDevice, capabilities camera.V4L2Capabilities) <span class="cov0" title="0">{
        // Check for nil device to prevent panic
        if device == nil </span><span class="cov0" title="0">{
                n.logger.Error("Cannot notify capability detected: device is nil")
                return
        }</span>

        // Convert device path to camera ID using proper abstraction layer
        <span class="cov0" title="0">cameraID, exists := n.mapper.GetCameraForDevicePath(device.Path)
        if !exists </span><span class="cov0" title="0">{
                n.logger.WithField("device_path", device.Path).Warning("Could not map device path to camera ID - skipping event")
                return // Skip unmapped devices to prevent runtime errors
        }</span>

        <span class="cov0" title="0">eventData := logging.Fields{
                "device":       cameraID,
                "device_path":  device.Path,
                "name":         device.Name,
                "driver":       capabilities.DriverName,
                "card_name":    capabilities.CardName,
                "bus_info":     capabilities.BusInfo,
                "capabilities": capabilities.Capabilities,
                "timestamp":    time.Now().Format(time.RFC3339),
        }

        if err := n.eventManager.PublishEvent(TopicCameraCapabilityDetected, eventData); err != nil </span><span class="cov0" title="0">{
                n.logger.WithError(err).WithField("device", cameraID).Error("Failed to publish capability detected event")
        }</span> else<span class="cov0" title="0"> {
                n.logger.WithFields(logging.Fields{
                        "device": cameraID,
                        "driver": capabilities.DriverName,
                        "topic":  TopicCameraCapabilityDetected,
                }).Info("Published capability detected event")
        }</span>
}

// NotifyCapabilityError notifies when camera capability detection fails
func (n *CameraEventNotifier) NotifyCapabilityError(devicePath string, errorMsg string) <span class="cov0" title="0">{
        // Convert device path to camera ID for proper abstraction
        // Use device path as camera identifier (devicePath = cameraID for our system)
        // Controller handles proper device path to camera ID mapping internally
        cameraID := devicePath

        eventData := logging.Fields{
                "device":      cameraID,
                "device_path": devicePath,
                "error":       errorMsg,
                "timestamp":   time.Now().Format(time.RFC3339),
        }

        if err := n.eventManager.PublishEvent(TopicCameraCapabilityError, eventData); err != nil </span><span class="cov0" title="0">{
                n.logger.WithError(err).WithField("device", cameraID).Error("Failed to publish capability error event")
        }</span> else<span class="cov0" title="0"> {
                n.logger.WithFields(logging.Fields{
                        "device": cameraID,
                        "error":  errorMsg,
                        "topic":  TopicCameraCapabilityError,
                }).Info("Published capability error event")
        }</span>
}

// MediaMTXEventNotifier implements MediaMTX event notifications
type MediaMTXEventNotifier struct {
        eventManager *EventManager
        mapper       DeviceToCameraIDMapper // For proper abstraction layer
        logger       *logging.Logger
}

// NewMediaMTXEventNotifier creates a new MediaMTX event notifier
func NewMediaMTXEventNotifier(eventManager *EventManager, mapper DeviceToCameraIDMapper, logger *logging.Logger) *MediaMTXEventNotifier <span class="cov0" title="0">{
        return &amp;MediaMTXEventNotifier{
                eventManager: eventManager,
                mapper:       mapper,
                logger:       logger,
        }
}</span>

// NotifyRecordingStarted notifies when MediaMTX recording starts
func (n *MediaMTXEventNotifier) NotifyRecordingStarted(device, filename string) <span class="cov0" title="0">{
        // The 'device' parameter contains camera_id from MediaMTX Controller
        // Stateless architecture - no session_id needed

        // Event payload with proper abstraction: camera_id primary
        eventData := logging.Fields{
                "device":    device, // API spec: "device" field with camera identifier
                "filename":  filename,
                "timestamp": time.Now().Format(time.RFC3339),
        }

        if err := n.eventManager.PublishEvent(TopicMediaMTXRecordingStarted, eventData); err != nil </span><span class="cov0" title="0">{
                n.logger.WithError(err).WithField("device", device).Error("Failed to publish recording started event")
        }</span> else<span class="cov0" title="0"> {
                n.logger.WithFields(logging.Fields{
                        "device":   device,
                        "filename": filename,
                        "topic":    TopicMediaMTXRecordingStarted,
                }).Info("Published recording started event")
        }</span>
}

// NotifyRecordingStopped notifies when MediaMTX recording stops
func (n *MediaMTXEventNotifier) NotifyRecordingStopped(device, filename string, duration time.Duration) <span class="cov0" title="0">{
        // Event payload with proper abstraction: camera_id primary (stateless - no session_id)
        eventData := logging.Fields{
                "device":    device, // API spec: "device" field with camera identifier
                "filename":  filename,
                "duration":  duration.Seconds(),
                "timestamp": time.Now().Format(time.RFC3339),
        }

        if err := n.eventManager.PublishEvent(TopicMediaMTXRecordingStopped, eventData); err != nil </span><span class="cov0" title="0">{
                n.logger.WithError(err).WithField("device", device).Error("Failed to publish recording stopped event")
        }</span> else<span class="cov0" title="0"> {
                n.logger.WithFields(logging.Fields{
                        "device":   device,
                        "filename": filename,
                        "duration": duration,
                        "topic":    TopicMediaMTXRecordingStopped,
                }).Info("Published recording stopped event")
        }</span>
}

// NotifyRecordingFailed notifies when recording fails (e.g., device disconnection)
func (n *MediaMTXEventNotifier) NotifyRecordingFailed(device, reason string) <span class="cov0" title="0">{
        // Event payload for recording failure
        eventData := logging.Fields{
                "device":    device, // Camera identifier (e.g., "camera0")
                "reason":    reason, // Failure reason (e.g., "device_disconnected")
                "timestamp": time.Now().Format(time.RFC3339),
        }

        if err := n.eventManager.PublishEvent(TopicMediaMTXRecordingFailed, eventData); err != nil </span><span class="cov0" title="0">{
                n.logger.WithError(err).WithField("device", device).Error("Failed to publish recording failed event")
        }</span> else<span class="cov0" title="0"> {
                n.logger.WithFields(logging.Fields{
                        "device": device,
                        "reason": reason,
                }).Info("Published recording failed event")
        }</span>
}

// NotifyStreamStarted notifies when MediaMTX stream starts
func (n *MediaMTXEventNotifier) NotifyStreamStarted(device, streamID, streamType string) <span class="cov0" title="0">{
        // Event payload with proper abstraction: device (camera identifier) primary
        eventData := logging.Fields{
                "device":      device,
                "stream_id":   streamID,
                "stream_type": streamType,
                "timestamp":   time.Now().Format(time.RFC3339),
        }

        if err := n.eventManager.PublishEvent(TopicMediaMTXStreamStarted, eventData); err != nil </span><span class="cov0" title="0">{
                n.logger.WithError(err).WithField("device", device).Error("Failed to publish stream started event")
        }</span> else<span class="cov0" title="0"> {
                n.logger.WithFields(logging.Fields{
                        "device":      device,
                        "stream_id":   streamID,
                        "stream_type": streamType,
                        "topic":       TopicMediaMTXStreamStarted,
                }).Info("Published stream started event")
        }</span>
}

// NotifyStreamStopped notifies when MediaMTX stream stops
func (n *MediaMTXEventNotifier) NotifyStreamStopped(device, streamID, streamType string) <span class="cov0" title="0">{
        // Event payload with proper abstraction: device (camera identifier) primary
        eventData := logging.Fields{
                "device":      device,
                "stream_id":   streamID,
                "stream_type": streamType,
                "timestamp":   time.Now().Format(time.RFC3339),
        }

        if err := n.eventManager.PublishEvent(TopicMediaMTXStreamStopped, eventData); err != nil </span><span class="cov0" title="0">{
                n.logger.WithError(err).WithField("device", device).Error("Failed to publish stream stopped event")
        }</span> else<span class="cov0" title="0"> {
                n.logger.WithFields(logging.Fields{
                        "device":      device,
                        "stream_id":   streamID,
                        "stream_type": streamType,
                        "topic":       TopicMediaMTXStreamStopped,
                }).Info("Published stream stopped event")
        }</span>
}

// SystemEventNotifier implements system-level event notifications
type SystemEventNotifier struct {
        eventManager *EventManager
        logger       *logging.Logger
}

// NewSystemEventNotifier creates a new system event notifier
func NewSystemEventNotifier(eventManager *EventManager, logger *logging.Logger) *SystemEventNotifier <span class="cov0" title="0">{
        return &amp;SystemEventNotifier{
                eventManager: eventManager,
                logger:       logger,
        }
}</span>

// NotifySystemStartup notifies when the system starts up
func (n *SystemEventNotifier) NotifySystemStartup(version, buildInfo string) <span class="cov0" title="0">{
        eventData := logging.Fields{
                "version":    version,
                "build_info": buildInfo,
                "timestamp":  time.Now().Format(time.RFC3339),
        }

        if err := n.eventManager.PublishEvent(TopicSystemStartup, eventData); err != nil </span><span class="cov0" title="0">{
                n.logger.WithError(err).Error("Failed to publish system startup event")
        }</span> else<span class="cov0" title="0"> {
                n.logger.WithFields(logging.Fields{
                        "version": version,
                        "topic":   TopicSystemStartup,
                }).Info("Published system startup event")
        }</span>
}

// NotifySystemShutdown notifies when the system shuts down
func (n *SystemEventNotifier) NotifySystemShutdown(reason string) <span class="cov0" title="0">{
        eventData := logging.Fields{
                "reason":    reason,
                "timestamp": time.Now().Format(time.RFC3339),
        }

        if err := n.eventManager.PublishEvent(TopicSystemShutdown, eventData); err != nil </span><span class="cov0" title="0">{
                n.logger.WithError(err).Error("Failed to publish system shutdown event")
        }</span> else<span class="cov0" title="0"> {
                n.logger.WithFields(logging.Fields{
                        "reason": reason,
                        "topic":  TopicSystemShutdown,
                }).Info("Published system shutdown event")
        }</span>
}

// NotifySystemHealth notifies about system health status
func (n *SystemEventNotifier) NotifySystemHealth(status string, metrics map[string]interface{}) <span class="cov0" title="0">{
        eventData := logging.Fields{
                "status":    status,
                "metrics":   metrics,
                "timestamp": time.Now().Format(time.RFC3339),
        }

        if err := n.eventManager.PublishEvent(TopicSystemHealth, eventData); err != nil </span><span class="cov0" title="0">{
                n.logger.WithError(err).Error("Failed to publish system health event")
        }</span> else<span class="cov0" title="0"> {
                n.logger.WithFields(logging.Fields{
                        "status": status,
                        "topic":  TopicSystemHealth,
                }).Info("Published system health event")
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
Event subscription system for WebSocket server.

Provides efficient, topic-based event delivery to subscribed clients,
replacing the inefficient broadcast-to-all approach.

Requirements Coverage:
- REQ-API-001: Efficient event delivery
- REQ-API-002: Client subscription management
- REQ-API-003: Topic-based filtering

Test Categories: Unit/Integration
API Documentation Reference: docs/api/json_rpc_methods.md
*/

package websocket

import (
        "fmt"
        "sync"
        "sync/atomic"
        "time"

        "github.com/camerarecorder/mediamtx-camera-service-go/internal/logging"
)

// EventTopic represents different types of events that clients can subscribe to
type EventTopic string

const (
        // Camera events
        TopicCameraConnected          EventTopic = "camera.connected"
        TopicCameraDisconnected       EventTopic = "camera.disconnected"
        TopicCameraStatusChange       EventTopic = "camera.status_change"
        TopicCameraCapabilityDetected EventTopic = "camera.capability_detected"
        TopicCameraCapabilityError    EventTopic = "camera.capability_error"

        // Recording events
        TopicRecordingStart    EventTopic = "recording.start"
        TopicRecordingStop     EventTopic = "recording.stop"
        TopicRecordingProgress EventTopic = "recording.progress"
        TopicRecordingError    EventTopic = "recording.error"

        // Snapshot events
        TopicSnapshotTaken EventTopic = "snapshot.taken"
        TopicSnapshotError EventTopic = "snapshot.error"

        // System events
        TopicSystemHealth   EventTopic = "system.health"
        TopicSystemError    EventTopic = "system.error"
        TopicSystemStartup  EventTopic = "system.startup"
        TopicSystemShutdown EventTopic = "system.shutdown"

        // MediaMTX events
        TopicMediaMTXStream           EventTopic = "mediamtx.stream"
        TopicMediaMTXPath             EventTopic = "mediamtx.path"
        TopicMediaMTXError            EventTopic = "mediamtx.error"
        TopicMediaMTXRecordingStarted EventTopic = "mediamtx.recording_started"
        TopicMediaMTXRecordingStopped EventTopic = "mediamtx.recording_stopped"
        TopicMediaMTXRecordingFailed  EventTopic = "mediamtx.recording_failed"
        TopicMediaMTXStreamStarted    EventTopic = "mediamtx.stream_started"
        TopicMediaMTXStreamStopped    EventTopic = "mediamtx.stream_stopped"
)

// EventSubscription represents a client's subscription to specific event topics
type EventSubscription struct {
        ClientID  string                 `json:"client_id"`
        Topics    []EventTopic           `json:"topics"`
        Filters   map[string]interface{} `json:"filters,omitempty"` // See SupportedFilters below
        CreatedAt time.Time              `json:"created_at"`
        LastSeen  time.Time              `json:"last_seen"`
        Active    bool                   `json:"active"`
}

// SupportedFilters documents the supported subscription filter keys and their types
//
// **Supported Client-Facing Filters (per JSON-RPC API specification):**
// - "device" (string): Filter by camera identifier (e.g., "camera0", "camera1") - **PRIMARY FILTER**
// - "topic" (string): Filter by specific event topic
// - "timestamp_after" (string): Filter events after RFC3339 timestamp (optional)
// - "timestamp_before" (string): Filter events before RFC3339 timestamp (optional)
//
// ⚠️ **Internal/Debug Filters (avoid in client applications):**
// - "device_path" (string): Filter by internal device path (e.g., "/dev/video0") - for internal tooling only
//
// **Filter Example (proper abstraction):**
// ```json
//
//        {
//          "device": "camera0",
//          "timestamp_after": "2024-01-01T00:00:00Z"
//        }
//
// ```
//
// **Matching Behavior:**
// - All specified filters must match (AND logic)
// - Exact string matching for device, topic, device_path
// - Timestamp filters use RFC3339 format comparison
// - Missing event fields cause filter to fail (no match)
type SupportedFilters struct {
        // This type exists only for documentation - use map[string]interface{} in practice
}

// EventMessage represents a structured event message
type EventMessage struct {
        Topic     EventTopic             `json:"topic"`
        Data      map[string]interface{} `json:"data"`
        Timestamp time.Time              `json:"timestamp"`
        EventID   string                 `json:"event_id"`
}

// EventManager manages event subscriptions and delivery
type EventManager struct {
        // Subscriptions by client ID
        subscriptions map[string]*EventSubscription

        // Subscriptions by topic for efficient lookup
        topicSubscriptions map[EventTopic]map[string]*EventSubscription

        // Event handlers for custom processing
        eventHandlers map[EventTopic][]func(*EventMessage) error

        // Thread safety
        mu sync.RWMutex

        // Atomic counters for fast statistics
        totalClients        int64 // atomic
        activeSubscriptions int64 // atomic

        // Logging
        logger *logging.Logger
}

// NewEventManager creates a new event manager
func NewEventManager(logger *logging.Logger) *EventManager <span class="cov8" title="1">{
        return &amp;EventManager{
                subscriptions:      make(map[string]*EventSubscription),
                topicSubscriptions: make(map[EventTopic]map[string]*EventSubscription),
                eventHandlers:      make(map[EventTopic][]func(*EventMessage) error),
                logger:             logger,
        }
}</span>

// Subscribe adds a client subscription to specific event topics
func (em *EventManager) Subscribe(clientID string, topics []EventTopic, filters map[string]interface{}) error <span class="cov0" title="0">{
        em.mu.Lock()
        defer em.mu.Unlock()

        // Validate topics
        for _, topic := range topics </span><span class="cov0" title="0">{
                if !em.isValidTopic(topic) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid event topic: %s", topic)
                }</span>
        }

        // Create or update subscription
        <span class="cov0" title="0">subscription := &amp;EventSubscription{
                ClientID:  clientID,
                Topics:    topics,
                Filters:   filters,
                CreatedAt: time.Now(),
                LastSeen:  time.Now(),
                Active:    true,
        }

        // Store subscription by client ID
        em.subscriptions[clientID] = subscription

        // Store subscription by topic for efficient lookup
        for _, topic := range topics </span><span class="cov0" title="0">{
                if em.topicSubscriptions[topic] == nil </span><span class="cov0" title="0">{
                        em.topicSubscriptions[topic] = make(map[string]*EventSubscription)
                }</span>
                <span class="cov0" title="0">em.topicSubscriptions[topic][clientID] = subscription</span>
        }

        // Update atomic counters
        <span class="cov0" title="0">atomic.AddInt64(&amp;em.totalClients, 1)
        atomic.AddInt64(&amp;em.activeSubscriptions, int64(len(topics)))

        em.logger.WithFields(logging.Fields{
                "client_id": clientID,
                "topics":    topics,
                "filters":   filters,
        }).Debug("Client subscribed to event topics")

        return nil</span>
}

// Unsubscribe removes a client's subscription to specific topics
func (em *EventManager) Unsubscribe(clientID string, topics []EventTopic) error <span class="cov0" title="0">{
        em.mu.Lock()
        defer em.mu.Unlock()

        _, exists := em.subscriptions[clientID]
        if !exists </span><span class="cov0" title="0">{
                // Client has no subscriptions - this is the desired state
                em.logger.WithField("client_id", clientID).Debug("Client has no subscriptions to remove")
                return nil
        }</span>

        // Remove topics from subscription
        <span class="cov0" title="0">if len(topics) == 0 </span><span class="cov0" title="0">{
                // Remove all subscriptions for this client
                em.removeClientSubscriptions(clientID)
                // Update atomic counters for complete removal
                atomic.AddInt64(&amp;em.totalClients, -1)
                // Note: activeSubscriptions will be decremented in removeClientSubscriptions
        }</span> else<span class="cov0" title="0"> {
                // Remove specific topics
                for _, topic := range topics </span><span class="cov0" title="0">{
                        em.removeTopicSubscription(clientID, topic)
                }</span>

                // Update subscription topics
                <span class="cov0" title="0">em.updateSubscriptionTopics(clientID, topics, true)
                // Update atomic counter for partial removal
                atomic.AddInt64(&amp;em.activeSubscriptions, -int64(len(topics)))</span>
        }

        <span class="cov0" title="0">em.logger.WithFields(logging.Fields{
                "client_id": clientID,
                "topics":    topics,
        }).Debug("Client unsubscribed from event topics")

        return nil</span>
}

// PublishEvent sends an event to all subscribed clients
func (em *EventManager) PublishEvent(topic EventTopic, data map[string]interface{}) error <span class="cov0" title="0">{
        em.mu.RLock()
        defer em.mu.RUnlock()

        // Create event message
        event := &amp;EventMessage{
                Topic:     topic,
                Data:      data,
                Timestamp: time.Now(),
                EventID:   generateEventID(),
        }

        // Process event through handlers
        if err := em.processEventHandlers(event); err != nil </span><span class="cov0" title="0">{
                em.logger.WithError(err).WithField("topic", string(topic)).Error("Event handler processing failed")
        }</span>

        // Get subscribers for this topic
        <span class="cov0" title="0">subscribers, exists := em.topicSubscriptions[topic]
        if !exists </span><span class="cov0" title="0">{
                em.logger.WithField("topic", string(topic)).Debug("No subscribers for event topic")
                return nil
        }</span>

        // Count interested subscribers
        <span class="cov0" title="0">subscriberCount := 0
        for _, subscription := range subscribers </span><span class="cov0" title="0">{
                if subscription.Active &amp;&amp; em.isClientInterested(subscription, event) </span><span class="cov0" title="0">{
                        subscriberCount++
                }</span>
        }

        <span class="cov0" title="0">em.logger.WithFields(logging.Fields{
                "topic":            topic,
                "subscriber_count": subscriberCount,
                "event_id":         event.EventID,
        }).Debug("Event published to subscribers")

        return nil</span>
}

// GetSubscribersForTopic returns all active subscribers for a specific topic
func (em *EventManager) GetSubscribersForTopic(topic EventTopic) []string <span class="cov0" title="0">{
        em.mu.RLock()
        defer em.mu.RUnlock()

        subscribers, exists := em.topicSubscriptions[topic]
        if !exists </span><span class="cov0" title="0">{
                return []string{}
        }</span>

        <span class="cov0" title="0">var clientIDs []string
        for clientID, subscription := range subscribers </span><span class="cov0" title="0">{
                if subscription.Active </span><span class="cov0" title="0">{
                        clientIDs = append(clientIDs, clientID)
                }</span>
        }

        <span class="cov0" title="0">return clientIDs</span>
}

// GetClientSubscriptions returns all topics a client is subscribed to
func (em *EventManager) GetClientSubscriptions(clientID string) []EventTopic <span class="cov0" title="0">{
        em.mu.RLock()
        defer em.mu.RUnlock()

        subscription, exists := em.subscriptions[clientID]
        if !exists </span><span class="cov0" title="0">{
                return []EventTopic{}
        }</span>

        <span class="cov0" title="0">return subscription.Topics</span>
}

// RemoveClient removes all subscriptions for a client
func (em *EventManager) RemoveClient(clientID string) <span class="cov8" title="1">{
        em.mu.Lock()
        defer em.mu.Unlock()

        // Get subscription count before removal for atomic counter update
        subscription, exists := em.subscriptions[clientID]
        var topicCount int64
        if exists &amp;&amp; subscription != nil </span><span class="cov0" title="0">{
                topicCount = int64(len(subscription.Topics))
        }</span>

        <span class="cov8" title="1">em.removeClientSubscriptions(clientID)

        // Update atomic counters
        if exists </span><span class="cov0" title="0">{
                atomic.AddInt64(&amp;em.totalClients, -1)
                atomic.AddInt64(&amp;em.activeSubscriptions, -topicCount)
        }</span>

        <span class="cov8" title="1">em.logger.WithField("client_id", clientID).Debug("Client removed from event manager")</span>
}

// AddEventHandler adds a custom event handler for a specific topic
func (em *EventManager) AddEventHandler(topic EventTopic, handler func(*EventMessage) error) <span class="cov0" title="0">{
        em.mu.Lock()
        defer em.mu.Unlock()

        em.eventHandlers[topic] = append(em.eventHandlers[topic], handler)
}</span>

// UpdateClientLastSeen updates the last seen timestamp for a client
func (em *EventManager) UpdateClientLastSeen(clientID string) <span class="cov0" title="0">{
        em.mu.Lock()
        defer em.mu.Unlock()

        if subscription, exists := em.subscriptions[clientID]; exists </span><span class="cov0" title="0">{
                subscription.LastSeen = time.Now()
        }</span>
}

// GetSubscriptionStats returns statistics about subscriptions
func (em *EventManager) GetSubscriptionStats() map[string]interface{} <span class="cov0" title="0">{
        // Use atomic operations for fast counter reads
        totalClients := atomic.LoadInt64(&amp;em.totalClients)
        activeSubscriptions := atomic.LoadInt64(&amp;em.activeSubscriptions)

        // Still need mutex for complex map operations
        em.mu.RLock()
        defer em.mu.RUnlock()

        stats := map[string]interface{}{
                "total_clients":        totalClients,
                "total_topics":         len(em.topicSubscriptions),
                "active_subscriptions": activeSubscriptions,
                "topic_distribution":   make(map[string]int),
        }

        // Count topic distribution (still needs mutex for map iteration)
        for topic, subscribers := range em.topicSubscriptions </span><span class="cov0" title="0">{
                stats["topic_distribution"].(map[string]int)[string(topic)] = len(subscribers)
        }</span>

        <span class="cov0" title="0">return stats</span>
}

// Helper methods

func (em *EventManager) isValidTopic(topic EventTopic) bool <span class="cov0" title="0">{
        validTopics := []EventTopic{
                TopicCameraConnected, TopicCameraDisconnected, TopicCameraStatusChange,
                TopicCameraCapabilityDetected, TopicCameraCapabilityError,
                TopicRecordingStart, TopicRecordingStop, TopicRecordingProgress, TopicRecordingError,
                TopicSnapshotTaken, TopicSnapshotError,
                TopicSystemHealth, TopicSystemError, TopicSystemStartup, TopicSystemShutdown,
                TopicMediaMTXStream, TopicMediaMTXPath, TopicMediaMTXError,
                TopicMediaMTXRecordingStarted, TopicMediaMTXRecordingStopped, TopicMediaMTXRecordingFailed,
                TopicMediaMTXStreamStarted, TopicMediaMTXStreamStopped,
        }

        for _, valid := range validTopics </span><span class="cov0" title="0">{
                if topic == valid </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (em *EventManager) removeClientSubscriptions(clientID string) <span class="cov8" title="1">{
        subscription := em.subscriptions[clientID]
        if subscription == nil </span><span class="cov8" title="1">{
                return
        }</span>

        // Remove from topic subscriptions
        <span class="cov0" title="0">for _, topic := range subscription.Topics </span><span class="cov0" title="0">{
                em.removeTopicSubscription(clientID, topic)
        }</span>

        // Remove from client subscriptions
        <span class="cov0" title="0">delete(em.subscriptions, clientID)</span>

        // Note: Atomic counter updates are handled by the calling method
        // to avoid double-counting in different code paths
}

func (em *EventManager) removeTopicSubscription(clientID string, topic EventTopic) <span class="cov0" title="0">{
        if subscribers, exists := em.topicSubscriptions[topic]; exists </span><span class="cov0" title="0">{
                delete(subscribers, clientID)
                if len(subscribers) == 0 </span><span class="cov0" title="0">{
                        delete(em.topicSubscriptions, topic)
                }</span>
        }
}

func (em *EventManager) updateSubscriptionTopics(clientID string, topicsToRemove []EventTopic, remove bool) <span class="cov0" title="0">{
        subscription := em.subscriptions[clientID]
        if subscription == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Create a map for efficient lookup
        <span class="cov0" title="0">topicMap := make(map[EventTopic]bool)
        for _, topic := range subscription.Topics </span><span class="cov0" title="0">{
                topicMap[topic] = true
        }</span>

        // Remove or add topics
        <span class="cov0" title="0">for _, topic := range topicsToRemove </span><span class="cov0" title="0">{
                if remove </span><span class="cov0" title="0">{
                        delete(topicMap, topic)
                }</span> else<span class="cov0" title="0"> {
                        topicMap[topic] = true
                }</span>
        }

        // Convert back to slice
        <span class="cov0" title="0">var newTopics []EventTopic
        for topic := range topicMap </span><span class="cov0" title="0">{
                newTopics = append(newTopics, topic)
        }</span>

        <span class="cov0" title="0">subscription.Topics = newTopics</span>
}

func (em *EventManager) isClientInterested(subscription *EventSubscription, event *EventMessage) bool <span class="cov0" title="0">{
        // Check if client is subscribed to this topic
        topicFound := false
        for _, topic := range subscription.Topics </span><span class="cov0" title="0">{
                if topic == event.Topic </span><span class="cov0" title="0">{
                        topicFound = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !topicFound </span><span class="cov0" title="0">{
                return false
        }</span>

        // Apply filters if specified
        <span class="cov0" title="0">if len(subscription.Filters) &gt; 0 </span><span class="cov0" title="0">{
                return em.applyFilters(subscription.Filters, event.Data)
        }</span>

        <span class="cov0" title="0">return true</span>
}

func (em *EventManager) applyFilters(filters map[string]interface{}, eventData map[string]interface{}) bool <span class="cov0" title="0">{
        for key, expectedValue := range filters </span><span class="cov0" title="0">{
                // Handle special timestamp filters
                if key == "timestamp_after" || key == "timestamp_before" </span><span class="cov0" title="0">{
                        if !em.matchTimestampFilter(key, expectedValue, eventData) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // Handle regular exact-match filters
                <span class="cov0" title="0">if actualValue, exists := eventData[key]; !exists || !em.valuesEqual(actualValue, expectedValue) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// matchTimestampFilter handles timestamp-based filtering with RFC3339 format
func (em *EventManager) matchTimestampFilter(filterKey string, expectedValue interface{}, eventData map[string]interface{}) bool <span class="cov0" title="0">{
        // Get event timestamp
        eventTimestampRaw, exists := eventData["timestamp"]
        if !exists </span><span class="cov0" title="0">{
                return false // No timestamp in event data
        }</span>

        <span class="cov0" title="0">eventTimestampStr, ok := eventTimestampRaw.(string)
        if !ok </span><span class="cov0" title="0">{
                return false // Timestamp is not a string
        }</span>

        // Parse event timestamp
        <span class="cov0" title="0">eventTime, err := time.Parse(time.RFC3339, eventTimestampStr)
        if err != nil </span><span class="cov0" title="0">{
                return false // Invalid timestamp format
        }</span>

        // Parse filter timestamp
        <span class="cov0" title="0">filterTimestampStr, ok := expectedValue.(string)
        if !ok </span><span class="cov0" title="0">{
                return false // Filter value is not a string
        }</span>

        <span class="cov0" title="0">filterTime, err := time.Parse(time.RFC3339, filterTimestampStr)
        if err != nil </span><span class="cov0" title="0">{
                return false // Invalid filter timestamp format
        }</span>

        // Apply timestamp comparison
        <span class="cov0" title="0">switch filterKey </span>{
        case "timestamp_after":<span class="cov0" title="0">
                return eventTime.After(filterTime)</span>
        case "timestamp_before":<span class="cov0" title="0">
                return eventTime.Before(filterTime)</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// valuesEqual safely compares two interface{} values, handling uncomparable types
func (em *EventManager) valuesEqual(a, b interface{}) bool <span class="cov0" title="0">{
        // Handle nil cases
        if a == nil &amp;&amp; b == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if a == nil || b == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Handle uncomparable types first - reject them to prevent panics
        <span class="cov0" title="0">switch a.(type) </span>{
        case map[string]interface{}, []interface{}, func():<span class="cov0" title="0">
                // These types are uncomparable in Go - log warning and return false
                em.logger.WithFields(logging.Fields{
                        "type_a": fmt.Sprintf("%T", a),
                        "type_b": fmt.Sprintf("%T", b),
                }).Warn("Filter comparison skipped for uncomparable types")
                return false</span>
        default:<span class="cov0" title="0">
                // For other types, use direct comparison (should be safe)
                return a == b</span>
        }
}

func (em *EventManager) processEventHandlers(event *EventMessage) error <span class="cov0" title="0">{
        handlers, exists := em.eventHandlers[event.Topic]
        if !exists </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, handler := range handlers </span><span class="cov0" title="0">{
                // Use anonymous function with panic recovery to prevent panics from crashing the server
                func() </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        em.logger.WithFields(logging.Fields{
                                                "event_id": event.EventID,
                                                "topic":    string(event.Topic),
                                                "panic":    r,
                                        }).Error("Event handler panicked - recovered to prevent server crash")
                                }</span>
                        }()

                        <span class="cov0" title="0">if err := handler(event); err != nil </span><span class="cov0" title="0">{
                                em.logger.WithError(err).WithField("event_id", event.EventID).Error("Event handler failed")
                                // Don't return error, continue processing other handlers
                                // This ensures one failing handler doesn't stop other handlers from executing
                        }</span>
                }()
        }

        <span class="cov0" title="0">return nil</span>
}

func generateEventID() string <span class="cov0" title="0">{
        return fmt.Sprintf("evt_%d", time.Now().UnixNano())
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package websocket implements JSON-RPC 2.0 method registration and core API methods.
//
// This package provides the method registration system and implements all
// JSON-RPC 2.0 API methods defined in the API documentation. All methods
// follow the delegation pattern, forwarding business logic to the MediaMTX
// controller while handling protocol-level concerns.
//
// Architecture Compliance:
//   - Delegation Pattern: All business logic forwarded to MediaMTX controller
//   - No Business Logic: Methods contain only protocol handling and validation
//   - Consistent Error Handling: Structured JSON-RPC 2.0 error responses
//   - Security Integration: Authentication and authorization enforcement
//   - Performance Monitoring: Request/response metrics collection
//
// Method Categories:
//   - Core Methods: ping, authenticate, system status
//   - Camera Methods: get_camera_list, get_camera_status, camera operations
//   - Recording Methods: start_recording, stop_recording, recording management
//   - Snapshot Methods: take_snapshot with multi-tier fallback
//   - File Methods: list_recordings, list_snapshots, file operations
//   - Health Methods: get_system_health, component status
//
// Requirements Coverage:
//   - REQ-API-002: Complete JSON-RPC 2.0 protocol implementation
//   - REQ-API-003: Request/response message handling with proper error codes
//   - REQ-API-004: All core method implementations with controller delegation
//
// Test Categories: Unit/Integration
// API Documentation Reference: docs/api/json_rpc_methods.md

package websocket

import (
        "context"
        "fmt"
        "strings"
        "sync/atomic"
        "time"

        "github.com/camerarecorder/mediamtx-camera-service-go/internal/logging"
        "github.com/camerarecorder/mediamtx-camera-service-go/internal/mediamtx"
)

// methodWrapper provides common method execution pattern with structured logging
// and consistent error handling. This centralizes cross-cutting concerns for
// all JSON-RPC method implementations.
func (s *WebSocketServer) methodWrapper(methodName string, handler func() (interface{}, error)) func(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov8" title="1">{
        return func(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) </span><span class="cov8" title="1">{
                s.logger.WithFields(logging.Fields{
                        "client_id": client.ClientID,
                        "method":    methodName,
                        "action":    "method_call",
                }).Debug(fmt.Sprintf("%s method called", methodName))

                result, err := handler()
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithFields(logging.Fields{
                                "client_id": client.ClientID,
                                "method":    methodName,
                                "action":    "method_error",
                                "error":     err.Error(),
                        }).Error(fmt.Sprintf("%s method failed", methodName))

                        // Enhanced error translation based on error content
                        jsonRpcError := s.translateErrorToJsonRpc(err, methodName)
                        return &amp;JsonRpcResponse{
                                JSONRPC: "2.0",
                                Error:   jsonRpcError,
                        }, nil
                }</span>

                <span class="cov8" title="1">s.logger.WithFields(logging.Fields{
                        "client_id": client.ClientID,
                        "method":    methodName,
                        "action":    "method_success",
                }).Debug(fmt.Sprintf("%s method completed successfully", methodName))

                s.assertResponseFields(methodName, result)
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Result:  result,
                }, nil</span>
        }
}

// assertResponseFields performs lightweight dev-only checks against API spec
func (s *WebSocketServer) assertResponseFields(method string, result interface{}) <span class="cov8" title="1">{
        if s == nil || s.logger == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">m, ok := result.(map[string]interface{})
        if !ok </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov0" title="0">required := map[string][]string{
                "get_camera_status": {"device", "status", "name", "resolution", "fps", "streams", "metrics"},
                "get_camera_list":   {"cameras", "total", "connected"},
                "get_stream_url":    {"device", "stream_name", "stream_url", "available"},
                "get_stream_status": {"device", "stream_name", "status", "ready"},
                "take_snapshot":     {"device", "filename", "status", "timestamp", "file_size"},
                "start_recording":   {"device", "filename", "status", "start_time", "format"},
                "stop_recording":    {"device", "status"},
                "start_streaming":   {"device", "stream_name", "stream_url", "status", "start_time"},
                "stop_streaming":    {"device", "stream_name", "status", "end_time", "duration"},
                "list_recordings":   {"files", "total", "limit", "offset"},
                "list_snapshots":    {"files", "total", "limit", "offset"},
                "get_storage_info":  {"total_space", "used_space", "available_space", "usage_percentage", "recordings_size", "snapshots_size", "low_space_warning"},
        }
        if fields, exists := required[method]; exists </span><span class="cov0" title="0">{
                missing := []string{}
                for _, k := range fields </span><span class="cov0" title="0">{
                        if _, ok := m[k]; !ok </span><span class="cov0" title="0">{
                                missing = append(missing, k)
                        }</span>
                }
                <span class="cov0" title="0">if len(missing) &gt; 0 </span><span class="cov0" title="0">{
                        s.logger.WithFields(logging.Fields{
                                "method":  method,
                                "missing": missing,
                        }).Warn("Response missing documented fields (dev-only check)")
                }</span>
        }
}

// authenticatedMethodWrapper wraps methods that require authentication using centralized security check
func (s *WebSocketServer) authenticatedMethodWrapper(methodName string, handler func() (interface{}, error)) func(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov8" title="1">{
        return func(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) </span><span class="cov8" title="1">{
                // Centralized authentication check - replaces 20+ duplicate checks
                if !client.Authenticated </span><span class="cov0" title="0">{
                        s.logger.WithFields(logging.Fields{
                                "client_id": client.ClientID,
                                "method":    methodName,
                                "action":    "auth_required",
                                "component": "security_middleware",
                        }).Warn("Authentication required for method")

                        return &amp;JsonRpcResponse{
                                JSONRPC: "2.0",
                                Error:   NewJsonRpcError(AUTHENTICATION_REQUIRED, "auth_required", "Authentication required", "Authenticate first"),
                        }, nil
                }</span>

                <span class="cov8" title="1">s.logger.WithFields(logging.Fields{
                        "client_id": client.ClientID,
                        "user_id":   client.UserID,
                        "role":      client.Role,
                        "method":    methodName,
                        "action":    "auth_success",
                        "component": "security_middleware",
                }).Debug("Authentication check passed")

                // Call base method wrapper for common logging and error handling
                return s.methodWrapper(methodName, handler)(params, client)</span>
        }
}

// registerBuiltinMethods registers all built-in JSON-RPC methods
func (s *WebSocketServer) registerBuiltinMethods() <span class="cov8" title="1">{
        // Core methods
        s.registerMethod("ping", s.MethodPing, "1.0")
        s.registerMethod("authenticate", s.MethodAuthenticate, "1.0")
        s.registerMethod("get_camera_list", s.MethodGetCameraList, "1.0")
        s.registerMethod("get_camera_status", s.MethodGetCameraStatus, "1.0")

        // System methods
        s.registerMethod("get_metrics", s.MethodGetMetrics, "1.0")
        s.registerMethod("get_camera_capabilities", s.MethodGetCameraCapabilities, "1.0")
        s.registerMethod("get_status", s.MethodGetStatus, "1.0")
        s.registerMethod("get_server_info", s.MethodGetServerInfo, "1.0")
        s.registerMethod("get_streams", s.MethodGetStreams, "1.0")
        s.registerMethod("get_system_status", s.MethodGetSystemStatus, "1.0")

        // File management methods
        s.registerMethod("list_recordings", s.MethodListRecordings, "1.0")
        s.registerMethod("list_snapshots", s.MethodListSnapshots, "1.0")
        s.registerMethod("get_recording_info", s.MethodGetRecordingInfo, "1.0")
        s.registerMethod("get_snapshot_info", s.MethodGetSnapshotInfo, "1.0")
        s.registerMethod("delete_recording", s.MethodDeleteRecording, "1.0")
        s.registerMethod("delete_snapshot", s.MethodDeleteSnapshot, "1.0")
        s.registerMethod("get_storage_info", s.MethodGetStorageInfo, "1.0")
        s.registerMethod("set_retention_policy", s.MethodSetRetentionPolicy, "1.0")
        s.registerMethod("cleanup_old_files", s.MethodCleanupOldFiles, "1.0")

        // Recording and snapshot methods
        s.registerMethod("take_snapshot", s.MethodTakeSnapshot, "1.0")
        s.registerMethod("start_recording", s.MethodStartRecording, "1.0")
        s.registerMethod("stop_recording", s.MethodStopRecording, "1.0")

        // Streaming methods
        s.registerMethod("start_streaming", s.MethodStartStreaming, "1.0")
        s.registerMethod("stop_streaming", s.MethodStopStreaming, "1.0")
        s.registerMethod("get_stream_url", s.MethodGetStreamURL, "1.0")
        s.registerMethod("get_stream_status", s.MethodGetStreamStatus, "1.0")

        // Notification methods
        s.registerMethod("camera_status_update", s.MethodCameraStatusUpdate, "1.0")
        s.registerMethod("recording_status_update", s.MethodRecordingStatusUpdate, "1.0")

        // Event subscription methods
        s.registerMethod("subscribe_events", s.MethodSubscribeEvents, "1.0")
        s.registerMethod("unsubscribe_events", s.MethodUnsubscribeEvents, "1.0")
        s.registerMethod("get_subscription_stats", s.MethodGetSubscriptionStats, "1.0")

        // External stream discovery methods
        s.registerMethod("discover_external_streams", s.MethodDiscoverExternalStreams, "1.0")
        s.registerMethod("add_external_stream", s.MethodAddExternalStream, "1.0")
        s.registerMethod("remove_external_stream", s.MethodRemoveExternalStream, "1.0")
        s.registerMethod("get_external_streams", s.MethodGetExternalStreams, "1.0")
        s.registerMethod("set_discovery_interval", s.MethodSetDiscoveryInterval, "1.0")

        s.logger.WithField("action", "register_methods").Info("Built-in methods registered")
}</span>

// registerMethod registers a JSON-RPC method handler
func (s *WebSocketServer) registerMethod(name string, handler MethodHandler, version string) <span class="cov8" title="1">{
        // Wrap the handler to ensure security, readiness, and metrics are always applied
        wrappedHandler := func(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) </span><span class="cov8" title="1">{
                startTime := time.Now()

                // Apply security checks
                if err := s.checkRateLimit(client); err != nil </span><span class="cov0" title="0">{
                        return &amp;JsonRpcResponse{
                                JSONRPC: "2.0",
                                Error:   NewJsonRpcError(RATE_LIMIT_EXCEEDED, "rate_limit", err.Error(), "Reduce request rate or wait"),
                        }, nil
                }</span>

                <span class="cov8" title="1">if err := s.checkMethodPermissions(client, name); err != nil </span><span class="cov0" title="0">{
                        return &amp;JsonRpcResponse{
                                JSONRPC: "2.0",
                                Error:   NewJsonRpcError(INSUFFICIENT_PERMISSIONS, "insufficient_permissions", err.Error(), "Check user role and permissions"),
                        }, nil
                }</span>

                // Progressive Readiness: Check controller readiness for non-authentication methods
                <span class="cov8" title="1">if name != "authenticate" &amp;&amp; name != "ping" </span><span class="cov8" title="1">{
                        if !s.isSystemReady() </span><span class="cov0" title="0">{
                                return &amp;JsonRpcResponse{
                                        JSONRPC: "2.0",
                                        Error:   NewJsonRpcError(MEDIAMTX_UNAVAILABLE, "service_initializing", "Service is still initializing, please retry", "Wait for service to complete startup"),
                                }, nil
                        }</span>
                }

                // Call the original handler
                <span class="cov8" title="1">response, err := handler(params, client)

                // Record metrics
                duration := time.Since(startTime).Seconds()
                s.recordRequest(name, duration)

                // Handle errors
                if err != nil </span><span class="cov0" title="0">{
                        // Use atomic operation for ErrorCount
                        atomic.AddInt64(&amp;s.metrics.ErrorCount, 1)
                }</span>

                <span class="cov8" title="1">return response, err</span>
        }

        // Store method handler in mutex-protected map
        <span class="cov8" title="1">s.logger.WithFields(logging.Fields{
                "method":       name,
                "handler_type": fmt.Sprintf("%T", wrappedHandler),
                "action":       "storing_method",
        }).Info("Storing method handler in map")

        s.methodsMutex.Lock()
        s.methods[name] = wrappedHandler
        s.methodsMutex.Unlock()

        // Verify storage
        s.methodsMutex.RLock()
        if stored, exists := s.methods[name]; exists </span><span class="cov8" title="1">{
                s.logger.WithFields(logging.Fields{
                        "method":      name,
                        "stored_type": fmt.Sprintf("%T", stored),
                        "action":      "verification_success",
                }).Info("Method handler stored successfully")
        }</span> else<span class="cov0" title="0"> {
                s.logger.WithFields(logging.Fields{
                        "method": name,
                        "action": "verification_failed",
                }).Error("Failed to store method handler")
        }</span>
        <span class="cov8" title="1">s.methodsMutex.RUnlock()

        // Store method version (still needs mutex for map operations)
        s.methodVersionsMutex.Lock()
        s.methodVersions[name] = version
        s.methodVersionsMutex.Unlock()

        s.logger.WithFields(logging.Fields{
                "method":  name,
                "version": version,
                "action":  "register_method",
        }).Debug("Method registered with security and metrics wrapper")</span>
}

// MethodPing implements the ping method
// Authentication: Not required (per API documentation)
// Purpose: Connectivity + envelope sanity check before authenticate
func (s *WebSocketServer) MethodPing(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        // Record performance metrics
        startTime := time.Now()
        duration := time.Since(startTime).Seconds()
        s.recordRequest("ping", duration)

        // Return "pong" as specified in API documentation
        // No authentication required - this is the only method that works without auth
        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result:  "pong",
                ID:      nil, // Will be set by the server from the original request
        }, nil
}</span>

// MethodAuthenticate implements the authenticate method
func (s *WebSocketServer) MethodAuthenticate(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov8" title="1">{
        // Handle authentication errors directly to return proper error codes
        // Extract auth_token parameter
        authToken, ok := params["auth_token"].(string)
        if !ok || authToken == "" </span><span class="cov0" title="0">{
                s.logger.WithFields(logging.Fields{
                        "client_id": client.ClientID,
                        "method":    "authenticate",
                        "action":    "auth_error",
                        "error":     "auth_token parameter is required",
                }).Warn("Authentication failed: missing auth_token parameter")

                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error:   NewJsonRpcError(AUTHENTICATION_REQUIRED, "auth_required", "auth_token parameter is required", "Provide valid auth_token"),
                }, nil
        }</span>

        // Validate JWT token
        <span class="cov8" title="1">claims, err := s.jwtHandler.ValidateToken(authToken)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithFields(logging.Fields{
                        "client_id": client.ClientID,
                        "method":    "authenticate",
                        "action":    "auth_error",
                        "error":     err.Error(),
                }).Warn("JWT token validation failed")

                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error:   NewJsonRpcError(AUTHENTICATION_REQUIRED, "auth_failed", "Invalid or expired token", "Provide valid token"),
                }, nil
        }</span>

        // Update client authentication state
        <span class="cov8" title="1">client.Authenticated = true
        client.UserID = claims.UserID
        client.Role = claims.Role
        client.AuthMethod = "jwt"

        // Calculate expiration time
        expiresAt := time.Unix(claims.EXP, 0)

        // Record performance metrics
        startTime := time.Now()
        duration := time.Since(startTime).Seconds()
        s.recordRequest("authenticate", duration)

        s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "user_id":   client.UserID,
                "role":      client.Role,
                "method":    "authenticate",
                "action":    "auth_success",
        }).Info("Authentication successful")

        // Return authentication result following Python implementation
        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result: map[string]interface{}{
                        "authenticated": true,
                        "role":          claims.Role,
                        "permissions":   s.permissionChecker.GetPermissionsForRole(claims.Role), // Delegate to security module
                        "expires_at":    expiresAt.Format(time.RFC3339),
                        "session_id":    client.ClientID,
                },
        }, nil</span>
}

// MethodGetCameraList implements the get_camera_list method
func (s *WebSocketServer) MethodGetCameraList(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov8" title="1">{
        // Delegates to MediaMTX Controller for business logic
        return s.authenticatedMethodWrapper("get_camera_list", func() (interface{}, error) </span><span class="cov8" title="1">{
                // Delegate to MediaMTX controller - returns API-ready APICameraInfo format
                cameraListResponse, err := s.mediaMTXController.GetCameraList(context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // MediaMTX Controller handles the API formatting through PathManager abstraction
                // Simply return the API-ready response
                <span class="cov8" title="1">return cameraListResponse, nil</span>
        })(params, client)
}

func (s *WebSocketServer) MethodGetCameraStatus(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        // REFACTORED: 56 lines → 15 lines (SRP compliance + centralized error handling)
        return s.authenticatedMethodWrapper("get_camera_status", func() (interface{}, error) </span><span class="cov0" title="0">{
                // Validate device parameter using centralized validation
                validationResult := s.validationHelper.ValidateDeviceParameter(params)
                if !validationResult.Valid </span><span class="cov0" title="0">{
                        s.validationHelper.LogValidationWarnings(validationResult, "get_camera_status", client.ClientID)
                        return nil, fmt.Errorf("validation failed: %v", validationResult.Errors)
                }</span>

                // Extract device parameter
                <span class="cov0" title="0">cameraID, ok := params["device"].(string)
                if !ok || cameraID == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("device parameter is required")
                }</span>

                // Delegate to controller - let wrapper handle error translation
                <span class="cov0" title="0">return s.mediaMTXController.GetCameraStatus(context.Background(), cameraID)</span>
        })(params, client)
}

// MethodGetMetrics implements the get_metrics method
// Thin delegation - Controller returns API-ready GetMetricsResponse
func (s *WebSocketServer) MethodGetMetrics(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        // Uses wrapper helpers for consistent method execution
        return s.authenticatedMethodWrapper("get_metrics", func() (interface{}, error) </span><span class="cov0" title="0">{
                // Pure delegation to Controller - returns complete API-ready response
                return s.mediaMTXController.GetMetrics(context.Background())
        }</span>)(params, client)
}

func (s *WebSocketServer) MethodGetCameraCapabilities(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        // Centralized authentication check
        if !client.Authenticated </span><span class="cov0" title="0">{
                s.logger.WithFields(logging.Fields{
                        "client_id": client.ClientID,
                        "method":    "get_camera_capabilities",
                        "action":    "auth_required",
                        "component": "security_middleware",
                }).Warn("Authentication required for method")

                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error:   NewJsonRpcError(AUTHENTICATION_REQUIRED, "auth_required", "Authentication required", "Authenticate first"),
                }, nil
        }</span>

        // Validate device parameter using centralized validation
        <span class="cov0" title="0">validationResult := s.validationHelper.ValidateDeviceParameter(params)
        if !validationResult.Valid </span><span class="cov0" title="0">{
                // Log validation warnings for debugging
                s.validationHelper.LogValidationWarnings(validationResult, "get_camera_capabilities", client.ClientID)
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error:   NewJsonRpcError(INVALID_PARAMS, "invalid_params", fmt.Sprintf("validation failed: %v", validationResult.Errors), "Provide valid device parameter"),
                }, nil
        }</span>

        // Extract validated device parameter
        <span class="cov0" title="0">device := validationResult.Data["device"].(string)

        // Pure delegation to Controller - returns API-ready GetCameraCapabilitiesResponse
        capabilitiesResponse, err := s.mediaMTXController.GetCameraCapabilities(context.Background(), device)
        if err != nil </span><span class="cov0" title="0">{
                // ✅ FIX 1: Map camera-specific errors to proper API error codes
                if strings.Contains(err.Error(), "not found") || strings.Contains(err.Error(), "not available") </span><span class="cov0" title="0">{
                        return &amp;JsonRpcResponse{
                                JSONRPC: "2.0",
                                Error:   NewJsonRpcError(CAMERA_NOT_FOUND, "camera_not_found", "Camera not found or disconnected", "Check camera identifier"),
                        }, nil
                }</span>
                // For other errors, return internal error
                <span class="cov0" title="0">return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error:   NewJsonRpcError(INTERNAL_ERROR, "internal_error", fmt.Sprintf("camera '%s' capabilities error: %v", device, err), "Retry or contact support if persistent"),
                }, nil</span>
        }

        <span class="cov0" title="0">return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result:  capabilitiesResponse,
        }, nil</span>
}

// MethodGetStatus implements the get_status method
func (s *WebSocketServer) MethodGetStatus(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        // Uses wrapper helpers for consistent method execution
        return s.authenticatedMethodWrapper("get_status", func() (interface{}, error) </span><span class="cov0" title="0">{

                // Pure delegation to MediaMTX controller - returns API-ready response with comprehensive health status
                if s.mediaMTXController != nil </span><span class="cov0" title="0">{
                        health, err := s.mediaMTXController.GetHealth(context.Background())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to get health status: %w", err)
                        }</span>

                        // Return the health response directly from the controller
                        <span class="cov0" title="0">return map[string]interface{}{
                                "status":     health.Status,
                                "uptime":     health.Uptime,
                                "version":    health.Version,
                                "components": health.Components,
                        }, nil</span>
                }

                // Fallback if controller is not available
                <span class="cov0" title="0">return map[string]interface{}{
                        "status":  "unhealthy",
                        "uptime":  float64(0),
                        "version": "unknown",
                        "components": map[string]interface{}{
                                "websocket_server": "error",
                                "camera_monitor":   "error",
                                "mediamtx":         "error",
                        },
                }, nil</span>
        })(params, client)
}

// MethodGetSystemStatus implements the get_system_status method
// Returns detailed system readiness information
func (s *WebSocketServer) MethodGetSystemStatus(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        // Uses wrapper helpers for consistent method execution
        return s.authenticatedMethodWrapper("get_system_status", func() (interface{}, error) </span><span class="cov0" title="0">{
                // Return system readiness response - no additional processing needed
                return s.getSystemReadinessResponse(), nil
        }</span>)(params, client)
}

// MethodGetServerInfo implements the get_server_info method
func (s *WebSocketServer) MethodGetServerInfo(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        // Uses wrapper helpers for consistent method execution
        return s.authenticatedMethodWrapper("get_server_info", func() (interface{}, error) </span><span class="cov0" title="0">{
                // Pure delegation to Controller - returns API-ready GetServerInfoResponse
                return s.mediaMTXController.GetServerInfo(context.Background())
        }</span>)(params, client)
}

// MethodGetStreams implements the get_streams method
func (s *WebSocketServer) MethodGetStreams(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        // Uses wrapper helpers for consistent method execution
        return s.authenticatedMethodWrapper("get_streams", func() (interface{}, error) </span><span class="cov0" title="0">{
                // Delegate to MediaMTX controller - investigate what it returns
                streams, err := s.mediaMTXController.GetStreams(context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get streams from MediaMTX service: %v", err)
                }</span>

                // Return Controller's API-ready response directly - thin delegation
                <span class="cov0" title="0">return streams, nil</span>
        })(params, client)
}

// MethodListRecordings implements the list_recordings method
func (s *WebSocketServer) MethodListRecordings(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        return s.authenticatedMethodWrapper("list_recordings", func() (interface{}, error) </span><span class="cov0" title="0">{
                // Extract parameters WITHOUT defaults
                limit := 0  // No default!
                offset := 0 // No default!

                if limitParam, exists := params["limit"]; exists </span><span class="cov0" title="0">{
                        if limitVal, ok := limitParam.(float64); ok </span><span class="cov0" title="0">{
                                limit = int(limitVal)
                        }</span>
                }

                <span class="cov0" title="0">if offsetParam, exists := params["offset"]; exists </span><span class="cov0" title="0">{
                        if offsetVal, ok := offsetParam.(float64); ok </span><span class="cov0" title="0">{
                                offset = int(offsetVal)
                        }</span>
                }

                // Pure delegation - RecordingManager handles defaults
                <span class="cov0" title="0">fileList, err := s.mediaMTXController.ListRecordings(context.Background(), limit, offset)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error getting recordings list: %v", err)
                }</span>

                // Return Controller's API-ready response directly - thin delegation
                <span class="cov0" title="0">return fileList, nil</span>
        })(params, client)
}

// MethodDeleteRecording implements the delete_recording method
func (s *WebSocketServer) MethodDeleteRecording(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        // REFACTORED: 81 lines → 20 lines → 14 lines (SRP compliance + centralized error handling)
        return s.authenticatedMethodWrapper("delete_recording", func() (interface{}, error) </span><span class="cov0" title="0">{

                // Validate parameters
                if params == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("filename parameter is required")
                }</span>

                <span class="cov0" title="0">filename, ok := params["filename"].(string)
                if !ok || filename == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("filename must be a non-empty string")
                }</span>

                // Delegate to controller - let wrapper handle error translation
                <span class="cov0" title="0">err := s.mediaMTXController.DeleteRecording(context.Background(), filename)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error deleting recording: %v", err)
                }</span>

                // Return success response
                <span class="cov0" title="0">return map[string]interface{}{
                        "filename": filename,
                        "deleted":  true,
                        "message":  "Recording file deleted successfully",
                }, nil</span>
        })(params, client)
}

// MethodDeleteSnapshot implements the delete_snapshot method
func (s *WebSocketServer) MethodDeleteSnapshot(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        // Centralized authentication check
        if !client.Authenticated </span><span class="cov0" title="0">{
                s.logger.WithFields(logging.Fields{
                        "client_id": client.ClientID,
                        "method":    "delete_snapshot",
                        "action":    "auth_required",
                        "component": "security_middleware",
                }).Warn("Authentication required for method")

                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error:   NewJsonRpcError(AUTHENTICATION_REQUIRED, "auth_required", "Authentication required", "Authenticate first"),
                }, nil
        }</span>

        // Validate filename parameter
        <span class="cov0" title="0">validationResult := s.validationHelper.ValidateFilenameParameter(params)
        if !validationResult.Valid </span><span class="cov0" title="0">{
                s.validationHelper.LogValidationWarnings(validationResult, "delete_snapshot", client.ClientID)
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error:   NewJsonRpcError(INVALID_PARAMS, "invalid_params", "validation failed", "Provide valid filename parameter"),
                }, nil
        }</span>

        // Extract validated filename
        <span class="cov0" title="0">filename := validationResult.Data["filename"].(string)

        // Use MediaMTX controller to delete snapshot - thin delegation
        err := s.mediaMTXController.DeleteSnapshot(context.Background(), filename)
        if err != nil </span><span class="cov0" title="0">{
                // Map specific errors to JSON-RPC error codes
                if strings.Contains(strings.ToLower(err.Error()), "not found") </span><span class="cov0" title="0">{
                        return &amp;JsonRpcResponse{
                                JSONRPC: "2.0",
                                Error:   NewJsonRpcError(FILE_NOT_FOUND, "file_not_found", "File not found or inaccessible", "Verify filename"),
                        }, nil
                }</span>
                // For other errors, return internal error
                <span class="cov0" title="0">return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error:   NewJsonRpcError(INTERNAL_ERROR, "internal_error", fmt.Sprintf("error deleting snapshot: %v", err), "Retry or contact support if persistent"),
                }, nil</span>
        }

        // Return success response
        <span class="cov0" title="0">return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result: map[string]interface{}{
                        "filename": filename,
                        "deleted":  true,
                        "message":  "Snapshot file deleted successfully",
                },
        }, nil</span>
}

func (s *WebSocketServer) MethodGetStorageInfo(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        return s.authenticatedMethodWrapper("get_storage_info", func() (interface{}, error) </span><span class="cov0" title="0">{

                // Get storage info from controller (thin delegation)
                info, err := s.mediaMTXController.GetStorageInfo(context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error getting storage information: %v", err)
                }</span>

                // Return Controller's API-ready response directly - thin delegation
                <span class="cov0" title="0">return info, nil</span>
        })(params, client)
}

func (s *WebSocketServer) MethodCleanupOldFiles(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{

        return s.authenticatedMethodWrapper("cleanup_old_files", func() (interface{}, error) </span><span class="cov0" title="0">{
                // Delegate to Controller for cleanup logic (single source of truth)
                result, err := s.mediaMTXController.CleanupOldFiles(context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to cleanup old files: %v", err)
                }</span>
                <span class="cov0" title="0">return result, nil</span>
        })(params, client)
}

// MethodSetRetentionPolicy implements the set_retention_policy method
func (s *WebSocketServer) MethodSetRetentionPolicy(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        return s.authenticatedMethodWrapper("set_retention_policy", func() (interface{}, error) </span><span class="cov0" title="0">{
                // Validate retention policy parameters
                validationResult := s.validationHelper.ValidateRetentionPolicyParameters(params)
                if !validationResult.Valid </span><span class="cov0" title="0">{
                        s.validationHelper.LogValidationWarnings(validationResult, "set_retention_policy", client.ClientID)
                        return nil, fmt.Errorf("validation failed: %s", "validation failed")
                }</span>

                // Extract validated parameters
                <span class="cov0" title="0">policyType := validationResult.Data["policy_type"].(string)
                enabled := validationResult.Data["enabled"].(bool)

                // Delegate to Controller for retention policy logic (single source of truth)
                result, err := s.mediaMTXController.SetRetentionPolicy(context.Background(), enabled, policyType, params)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to set retention policy: %v", err)
                }</span>
                <span class="cov0" title="0">return result, nil</span>
        })(params, client)
}

func (s *WebSocketServer) MethodListSnapshots(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        return s.authenticatedMethodWrapper("list_snapshots", func() (interface{}, error) </span><span class="cov0" title="0">{

                // Validate pagination parameters
                validationResult := s.validationHelper.ValidatePaginationParams(params)
                if !validationResult.Valid </span><span class="cov0" title="0">{
                        s.validationHelper.LogValidationWarnings(validationResult, "list_snapshots", client.ClientID)
                        return nil, fmt.Errorf("validation failed: %s", "validation failed")
                }</span>

                // Extract validated parameters
                <span class="cov0" title="0">limit := validationResult.Data["limit"].(int)
                offset := validationResult.Data["offset"].(int)

                // Use MediaMTX controller to get snapshots list - thin delegation
                fileList, err := s.mediaMTXController.ListSnapshots(context.Background(), limit, offset)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error getting snapshots list: %v", err)
                }</span>

                // Check if no snapshots found
                <span class="cov0" title="0">if fileList.Total == 0 </span><span class="cov0" title="0">{
                        // API doc: return success with empty result object, not an error
                        return map[string]interface{}{
                                "files":  []map[string]interface{}{},
                                "total":  0,
                                "limit":  limit,
                                "offset": offset,
                        }, nil
                }</span>

                // Convert SnapshotFileInfo to map for JSON response
                <span class="cov0" title="0">files := make([]map[string]interface{}, len(fileList.Snapshots))
                for i, file := range fileList.Snapshots </span><span class="cov0" title="0">{
                        fileData := map[string]interface{}{
                                "filename":      file.Filename,
                                "file_size":     file.FileSize,
                                "modified_time": file.ModifiedTime, // API compliant field name
                                "download_url":  file.DownloadURL,
                        }

                        files[i] = fileData
                }</span>

                // Return snapshots list
                <span class="cov0" title="0">return map[string]interface{}{
                        "files":  files,
                        "total":  fileList.Total,
                        "limit":  fileList.Limit,
                        "offset": fileList.Offset,
                }, nil</span>
        })(params, client)
}

// MethodTakeSnapshot implements the take_snapshot method
func (s *WebSocketServer) MethodTakeSnapshot(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov8" title="1">{
        return s.authenticatedMethodWrapper("take_snapshot", func() (interface{}, error) </span><span class="cov8" title="1">{
                // 1. Input validation only (API contract validation)
                validationResult := s.validationHelper.ValidateSnapshotParameters(params)
                if !validationResult.Valid </span><span class="cov0" title="0">{
                        s.validationHelper.LogValidationWarnings(validationResult, "take_snapshot", client.ClientID)
                        return nil, fmt.Errorf("validation failed")
                }</span>

                // 2. Extract parameters and convert to strongly-typed options
                <span class="cov8" title="1">devicePath := validationResult.Data["device"].(string)
                optionsMap := validationResult.Data["options"].(map[string]interface{})

                // Convert map to strongly-typed SnapshotOptions for type safety
                options := mediamtx.SnapshotOptionsFromMap(optionsMap)

                // 3. Pure delegation - Controller and SnapshotManager handle all business logic
                // No duplicate validation, no response formatting, no business logic
                snapshot, err := s.mediaMTXController.TakeAdvancedSnapshot(context.Background(), devicePath, options)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to take snapshot: %v", err)
                }</span>

                // 4. Return snapshot as-is - SnapshotManager should provide API-ready response
                <span class="cov8" title="1">return snapshot, nil</span>
        })(params, client)
}

// MethodStartRecording implements the start_recording method
func (s *WebSocketServer) MethodStartRecording(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        // Centralized authentication check
        if !client.Authenticated </span><span class="cov0" title="0">{
                s.logger.WithFields(logging.Fields{
                        "client_id": client.ClientID,
                        "method":    "start_recording",
                        "action":    "auth_required",
                        "component": "security_middleware",
                }).Warn("Authentication required for method")

                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error:   NewJsonRpcError(AUTHENTICATION_REQUIRED, "auth_required", "Authentication required", "Authenticate first"),
                }, nil
        }</span>

        // 1. Input validation only (JSON-RPC API contract validation)
        <span class="cov0" title="0">validationResult := s.validationHelper.ValidateRecordingParameters(params)
        if !validationResult.Valid </span><span class="cov0" title="0">{
                s.validationHelper.LogValidationWarnings(validationResult, "start_recording", client.ClientID)
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error:   NewJsonRpcError(INVALID_PARAMS, "invalid_params", "validation failed", "Provide valid recording parameters"),
                }, nil
        }</span>

        // 2. Extract JSON-RPC API parameters only (per docs/api/json_rpc_methods.md)
        <span class="cov0" title="0">device := validationResult.Data["device"].(string)

        // 3. Build PathConf with only JSON-RPC API parameters (no internal MediaMTX fields)
        options := &amp;mediamtx.PathConf{}
        if format, ok := params["format"].(string); ok &amp;&amp; format != "" </span><span class="cov0" title="0">{
                options.RecordFormat = format
        }</span>
        <span class="cov0" title="0">if duration, ok := params["duration"].(int); ok &amp;&amp; duration &gt; 0 </span><span class="cov0" title="0">{
                options.RecordDeleteAfter = fmt.Sprintf("%ds", duration) // Convert to MediaMTX duration format
        }</span>

        // 4. Pure delegation - Controller returns API-ready response
        <span class="cov0" title="0">recordingResponse, err := s.mediaMTXController.StartRecording(context.Background(), device, options)
        if err != nil </span><span class="cov0" title="0">{
                // ✅ FIX 1: Map camera-specific errors to proper API error codes
                if strings.Contains(err.Error(), "not found") || strings.Contains(err.Error(), "not available") </span><span class="cov0" title="0">{
                        return &amp;JsonRpcResponse{
                                JSONRPC: "2.0",
                                Error:   NewJsonRpcError(CAMERA_NOT_FOUND, "camera_not_found", "Camera not found or disconnected", "Check camera identifier"),
                        }, nil
                }</span>
                <span class="cov0" title="0">if strings.Contains(err.Error(), "recording") &amp;&amp; strings.Contains(err.Error(), "progress") </span><span class="cov0" title="0">{
                        return &amp;JsonRpcResponse{
                                JSONRPC: "2.0",
                                Error:   NewJsonRpcError(RECORDING_IN_PROGRESS, "recording_in_progress", "Recording already in progress", "Stop current recording first"),
                        }, nil
                }</span>
                // For other errors, return internal error
                <span class="cov0" title="0">return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error:   NewJsonRpcError(INTERNAL_ERROR, "internal_error", fmt.Sprintf("start_recording error: %v", err), "Retry or contact support if persistent"),
                }, nil</span>
        }

        <span class="cov0" title="0">return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result:  recordingResponse,
        }, nil</span>
}

// MethodStopRecording implements the stop_recording method
func (s *WebSocketServer) MethodStopRecording(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        return s.authenticatedMethodWrapper("stop_recording", func() (interface{}, error) </span><span class="cov0" title="0">{
                // Validate parameters
                if params == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("device parameter is required")
                }</span>

                <span class="cov0" title="0">cameraID, ok := params["device"].(string)
                if !ok || cameraID == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("device parameter is required")
                }</span>

                // Validate device parameter using centralized validation
                <span class="cov0" title="0">val := s.validationHelper.ValidateDeviceParameter(map[string]interface{}{"device": cameraID})
                if !val.Valid </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid device parameter: %v", val.Errors)
                }</span>

                // Pure delegation to Controller - returns API-ready StopRecordingResponse
                <span class="cov0" title="0">return s.mediaMTXController.StopRecording(context.Background(), cameraID)</span>
        })(params, client)
}

func (s *WebSocketServer) MethodGetRecordingInfo(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        // Centralized authentication check
        if !client.Authenticated </span><span class="cov0" title="0">{
                s.logger.WithFields(logging.Fields{
                        "client_id": client.ClientID,
                        "method":    "get_recording_info",
                        "action":    "auth_required",
                        "component": "security_middleware",
                }).Warn("Authentication required for method")

                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error:   NewJsonRpcError(AUTHENTICATION_REQUIRED, "auth_required", "Authentication required", "Authenticate first"),
                }, nil
        }</span>

        // Validate filename parameter
        <span class="cov0" title="0">validationResult := s.validationHelper.ValidateFilenameParameter(params)
        if !validationResult.Valid </span><span class="cov0" title="0">{
                s.validationHelper.LogValidationWarnings(validationResult, "get_recording_info", client.ClientID)
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error:   NewJsonRpcError(INVALID_PARAMS, "invalid_params", "validation failed", "Provide valid filename parameter"),
                }, nil
        }</span>

        // Extract validated filename parameter
        <span class="cov0" title="0">filename := validationResult.Data["filename"].(string)

        // Pure delegation to Controller - returns API-ready GetRecordingInfoResponse
        recordingInfo, err := s.mediaMTXController.GetRecordingInfo(context.Background(), filename)
        if err != nil </span><span class="cov0" title="0">{
                // Map specific errors to JSON-RPC error codes
                if strings.Contains(strings.ToLower(err.Error()), "not found") </span><span class="cov0" title="0">{
                        return &amp;JsonRpcResponse{
                                JSONRPC: "2.0",
                                Error:   NewJsonRpcError(FILE_NOT_FOUND, "file_not_found", "File not found or inaccessible", "Verify filename"),
                        }, nil
                }</span>
                // For other errors, return internal error
                <span class="cov0" title="0">return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error:   NewJsonRpcError(INTERNAL_ERROR, "internal_error", fmt.Sprintf("error getting recording info: %v", err), "Retry or contact support if persistent"),
                }, nil</span>
        }

        // Return success response
        <span class="cov0" title="0">return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result:  recordingInfo,
        }, nil</span>
}

// MethodGetSnapshotInfo implements the get_snapshot_info method
func (s *WebSocketServer) MethodGetSnapshotInfo(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        return s.authenticatedMethodWrapper("get_snapshot_info", func() (interface{}, error) </span><span class="cov0" title="0">{

                // Validate filename parameter
                validationResult := s.validationHelper.ValidateFilenameParameter(params)
                if !validationResult.Valid </span><span class="cov0" title="0">{
                        s.validationHelper.LogValidationWarnings(validationResult, "get_snapshot_info", client.ClientID)
                        return nil, fmt.Errorf("validation failed: %s", "validation failed")
                }</span>

                // Extract validated filename parameter
                <span class="cov0" title="0">filename := validationResult.Data["filename"].(string)

                // Pure delegation to Controller - returns API-ready GetSnapshotInfoResponse
                return s.mediaMTXController.GetSnapshotInfo(context.Background(), filename)</span>
        })(params, client)
}

// MethodCameraStatusUpdate handles camera status update notifications
// SECURITY: This method should not be called directly by clients - it's for server-generated notifications only
// PURPOSE: WebSocket event system for real-time camera status notifications (REQ-API-020/021)
func (s *WebSocketServer) MethodCameraStatusUpdate(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        // REQ-API-020: WebSocket server shall support camera_status_update notifications
        // REQ-API-021: Notifications shall include device, status, name, resolution, fps, and streams

        // SECURITY: Prevent direct client calls to notification methods
        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Error:   NewJsonRpcError(METHOD_NOT_FOUND, "method_not_found", "camera_status_update", "Verify method name"),
        }, nil
}</span>

// MethodRecordingStatusUpdate handles recording status update notifications
// SECURITY: This method should not be called directly by clients - it's for server-generated notifications only
func (s *WebSocketServer) MethodRecordingStatusUpdate(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        // REQ-API-022: WebSocket server shall support recording_status_update notifications
        // REQ-API-023: Notifications shall include device, status, filename, and duration

        // SECURITY: Prevent direct client calls to notification methods
        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Error:   NewJsonRpcError(METHOD_NOT_FOUND, "method_not_found", "recording_status_update", "Verify method name"),
        }, nil
}</span>

// MethodSubscribeEvents handles client subscription to event topics
func (s *WebSocketServer) MethodSubscribeEvents(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        return s.authenticatedMethodWrapper("subscribe_events", func() (interface{}, error) </span><span class="cov0" title="0">{
                // Validate required parameters
                topicsParam, exists := params["topics"]
                if !exists </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("topics parameter is required")
                }</span>

                // Parse topics parameter
                <span class="cov0" title="0">var topics []EventTopic
                switch v := topicsParam.(type) </span>{
                case []interface{}:<span class="cov0" title="0">
                        for _, topic := range v </span><span class="cov0" title="0">{
                                if topicStr, ok := topic.(string); ok </span><span class="cov0" title="0">{
                                        topics = append(topics, EventTopic(topicStr))
                                }</span>
                        }
                case []string:<span class="cov0" title="0">
                        for _, topic := range v </span><span class="cov0" title="0">{
                                topics = append(topics, EventTopic(topic))
                        }</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("topics must be an array of strings")</span>
                }

                <span class="cov0" title="0">if len(topics) == 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("at least one topic must be specified")
                }</span>

                // Parse optional filters
                <span class="cov0" title="0">var filters map[string]interface{}
                if filtersParam, exists := params["filters"]; exists </span><span class="cov0" title="0">{
                        if filtersMap, ok := filtersParam.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                filters = filtersMap
                        }</span>
                }

                // Subscribe client to events
                <span class="cov0" title="0">err := s.eventManager.Subscribe(client.ClientID, topics, filters)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to subscribe to events: %v", err)
                }</span>

                // Update client last seen
                <span class="cov0" title="0">s.eventManager.UpdateClientLastSeen(client.ClientID)

                // Return subscription result
                return map[string]interface{}{
                        "subscribed": true,
                        "topics":     topics,
                        "filters":    filters,
                }, nil</span>
        })(params, client)
}

// MethodUnsubscribeEvents handles client unsubscription from event topics
func (s *WebSocketServer) MethodUnsubscribeEvents(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        return s.authenticatedMethodWrapper("unsubscribe_events", func() (interface{}, error) </span><span class="cov0" title="0">{
                // Parse optional topics parameter (if not provided, unsubscribe from all)
                var topics []EventTopic
                if topicsParam, exists := params["topics"]; exists </span><span class="cov0" title="0">{
                        switch v := topicsParam.(type) </span>{
                        case []interface{}:<span class="cov0" title="0">
                                for _, topic := range v </span><span class="cov0" title="0">{
                                        if topicStr, ok := topic.(string); ok </span><span class="cov0" title="0">{
                                                topics = append(topics, EventTopic(topicStr))
                                        }</span>
                                }
                        case []string:<span class="cov0" title="0">
                                for _, topic := range v </span><span class="cov0" title="0">{
                                        topics = append(topics, EventTopic(topic))
                                }</span>
                        }
                }

                // Unsubscribe client from events
                <span class="cov0" title="0">err := s.eventManager.Unsubscribe(client.ClientID, topics)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unsubscribe: %v", err)
                }</span>

                // Update client last seen
                <span class="cov0" title="0">s.eventManager.UpdateClientLastSeen(client.ClientID)

                // Return unsubscription result
                return map[string]interface{}{
                        "unsubscribed": true,
                        "topics":       topics,
                }, nil</span>
        })(params, client)
}

// MethodGetSubscriptionStats returns statistics about event subscriptions
func (s *WebSocketServer) MethodGetSubscriptionStats(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        return s.methodWrapper("get_subscription_stats", func() (interface{}, error) </span><span class="cov0" title="0">{
                // Get subscription statistics
                stats := s.eventManager.GetSubscriptionStats()

                // Get client's own subscriptions
                clientTopics := s.eventManager.GetClientSubscriptions(client.ClientID)

                return map[string]interface{}{
                        "global_stats":  stats,
                        "client_topics": clientTopics,
                        "client_id":     client.ClientID,
                }, nil
        }</span>)(params, client)
}

// MethodStartStreaming starts a live streaming session for the specified camera device
func (s *WebSocketServer) MethodStartStreaming(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        return s.authenticatedMethodWrapper("start_streaming", func() (interface{}, error) </span><span class="cov0" title="0">{
                // Validate device parameter using centralized validation
                validationResult := s.validationHelper.ValidateDeviceParameter(params)
                if !validationResult.Valid </span><span class="cov0" title="0">{
                        // Log validation warnings for debugging
                        s.validationHelper.LogValidationWarnings(validationResult, "start_streaming", client.ClientID)
                        return nil, fmt.Errorf("validation failed: %v", validationResult.Errors)
                }</span>

                // Extract validated device parameter
                <span class="cov0" title="0">device := validationResult.Data["device"].(string)

                // Pure delegation to Controller - returns API-ready GetStreamURLResponse
                return s.mediaMTXController.StartStreaming(context.Background(), device)</span>
        })(params, client)
}

// MethodStopStreaming stops the active streaming session for the specified camera device
func (s *WebSocketServer) MethodStopStreaming(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        return s.authenticatedMethodWrapper("stop_streaming", func() (interface{}, error) </span><span class="cov0" title="0">{
                // Validate device parameter using centralized validation
                validationResult := s.validationHelper.ValidateDeviceParameter(params)
                if !validationResult.Valid </span><span class="cov0" title="0">{
                        // Log validation warnings for debugging
                        s.validationHelper.LogValidationWarnings(validationResult, "stop_streaming", client.ClientID)
                        return nil, fmt.Errorf("validation failed: %v", validationResult.Errors)
                }</span>

                // Extract validated device parameter
                <span class="cov0" title="0">device := validationResult.Data["device"].(string)

                // Stop streaming using controller (maps internally)
                err := s.mediaMTXController.StopStreaming(context.Background(), device)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to stop streaming: %v", err)
                }</span>

                // Return stop result
                <span class="cov0" title="0">return map[string]interface{}{
                        "device":           device,
                        "stream_name":      fmt.Sprintf("%s_viewing", device),
                        "status":           "STOPPED",
                        "start_time":       time.Now().Add(-5 * time.Minute).Format(time.RFC3339),
                        "end_time":         time.Now().Format(time.RFC3339),
                        "duration":         300,
                        "stream_continues": false,
                }, nil</span>
        })(params, client)
}

// MethodGetStreamURL gets the stream URL for a specific camera device
func (s *WebSocketServer) MethodGetStreamURL(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        return s.authenticatedMethodWrapper("get_stream_url", func() (interface{}, error) </span><span class="cov0" title="0">{
                // Validate device parameter using centralized validation
                validationResult := s.validationHelper.ValidateDeviceParameter(params)
                if !validationResult.Valid </span><span class="cov0" title="0">{
                        // Log validation warnings for debugging
                        s.validationHelper.LogValidationWarnings(validationResult, "get_stream_url", client.ClientID)
                        return nil, fmt.Errorf("validation failed: %v", validationResult.Errors)
                }</span>

                // Extract validated device parameter
                <span class="cov0" title="0">device := validationResult.Data["device"].(string)

                // ULTRA THIN: Delegate to Controller - returns complete API-ready response
                streamURLResp, err := s.mediaMTXController.GetStreamURL(context.Background(), device)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get stream URL: %v", err)
                }</span>

                // Return Controller's API-ready response directly - no business logic duplication
                <span class="cov0" title="0">return streamURLResp, nil</span>
        })(params, client)
}

// MethodGetStreamStatus gets detailed status information for a specific camera stream
func (s *WebSocketServer) MethodGetStreamStatus(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        return s.authenticatedMethodWrapper("get_stream_status", func() (interface{}, error) </span><span class="cov0" title="0">{
                // Validate device parameter using centralized validation
                validationResult := s.validationHelper.ValidateDeviceParameter(params)
                if !validationResult.Valid </span><span class="cov0" title="0">{
                        // Log validation warnings for debugging
                        s.validationHelper.LogValidationWarnings(validationResult, "get_stream_status", client.ClientID)
                        return nil, fmt.Errorf("validation failed: %v", validationResult.Errors)
                }</span>

                // Extract validated device parameter
                <span class="cov0" title="0">device := validationResult.Data["device"].(string)

                // Get stream status from controller using camera ID
                stream, err := s.mediaMTXController.GetStreamStatus(context.Background(), device)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("stream not found or not active: %v", err)
                }</span>

                // ULTRA THIN: Return Controller's API-ready response directly - no business logic duplication
                <span class="cov0" title="0">return stream, nil</span>
        })(params, client)
}

// MethodDiscoverExternalStreams discovers external streams (Skydio UAVs, etc.)
func (s *WebSocketServer) MethodDiscoverExternalStreams(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        return s.authenticatedMethodWrapper("discover_external_streams", func() (interface{}, error) </span><span class="cov0" title="0">{
                // Get discovery options from params
                options := mediamtx.DiscoveryOptions{
                        SkydioEnabled:  true,  // Default to Skydio discovery
                        GenericEnabled: false, // Default to disabled
                }

                if skydioEnabled, ok := params["skydio_enabled"].(bool); ok </span><span class="cov0" title="0">{
                        options.SkydioEnabled = skydioEnabled
                }</span>
                <span class="cov0" title="0">if genericEnabled, ok := params["generic_enabled"].(bool); ok </span><span class="cov0" title="0">{
                        options.GenericEnabled = genericEnabled
                }</span>
                <span class="cov0" title="0">if forceRescan, ok := params["force_rescan"].(bool); ok </span><span class="cov0" title="0">{
                        options.ForceRescan = forceRescan
                }</span>
                <span class="cov0" title="0">if includeOffline, ok := params["include_offline"].(bool); ok </span><span class="cov0" title="0">{
                        options.IncludeOffline = includeOffline
                }</span>

                // Trigger discovery with options
                <span class="cov0" title="0">result, err := s.mediaMTXController.DiscoverExternalStreams(context.Background(), options)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">return result, nil</span>
        })(params, client)
}

// MethodAddExternalStream adds an external stream to the system
func (s *WebSocketServer) MethodAddExternalStream(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        return s.authenticatedMethodWrapper("add_external_stream", func() (interface{}, error) </span><span class="cov0" title="0">{
                // Extract stream parameters
                streamURL, ok := params["stream_url"].(string)
                if !ok || streamURL == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("stream_url parameter is required")
                }</span>

                <span class="cov0" title="0">streamName, ok := params["stream_name"].(string)
                if !ok || streamName == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("stream_name parameter is required")
                }</span>

                <span class="cov0" title="0">streamType, ok := params["stream_type"].(string)
                if !ok </span><span class="cov0" title="0">{
                        streamType = "generic_rtsp" // Default type
                }</span>

                // Create external stream
                <span class="cov0" title="0">stream := &amp;mediamtx.ExternalStream{
                        URL:          streamURL,
                        Name:         streamName,
                        Type:         streamType,
                        Status:       "discovered",
                        DiscoveredAt: time.Now(),
                        LastSeen:     time.Now(),
                        Capabilities: map[string]interface{}{
                                "protocol": "rtsp",
                                "source":   "external",
                        },
                }

                // Pure delegation to Controller - returns API-ready AddExternalStreamResponse
                return s.mediaMTXController.AddExternalStream(context.Background(), stream)</span>
        })(params, client)
}

// MethodRemoveExternalStream removes an external stream from the system
func (s *WebSocketServer) MethodRemoveExternalStream(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        return s.authenticatedMethodWrapper("remove_external_stream", func() (interface{}, error) </span><span class="cov0" title="0">{
                // Extract stream URL
                streamURL, ok := params["stream_url"].(string)
                if !ok || streamURL == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("stream_url parameter is required")
                }</span>

                // Pure delegation to Controller - returns API-ready RemoveExternalStreamResponse
                <span class="cov0" title="0">return s.mediaMTXController.RemoveExternalStream(context.Background(), streamURL)</span>
        })(params, client)
}

// MethodGetExternalStreams returns all discovered external streams
func (s *WebSocketServer) MethodGetExternalStreams(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        return s.authenticatedMethodWrapper("get_external_streams", func() (interface{}, error) </span><span class="cov0" title="0">{
                // Pure delegation to Controller - returns API-ready GetExternalStreamsResponse
                return s.mediaMTXController.GetExternalStreams(context.Background())
        }</span>)(params, client)
}

// MethodSetDiscoveryInterval sets the discovery scan interval
func (s *WebSocketServer) MethodSetDiscoveryInterval(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        return s.authenticatedMethodWrapper("set_discovery_interval", func() (interface{}, error) </span><span class="cov0" title="0">{
                // Extract interval parameter
                interval, ok := params["scan_interval"].(float64)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("scan_interval parameter is required and must be a number")
                }</span>

                // Validate interval (0 = on-demand only, &gt;0 = periodic scanning)
                <span class="cov0" title="0">if interval &lt; 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("scan_interval must be &gt;= 0")
                }</span>

                // Pure delegation to Controller - returns API-ready SetDiscoveryIntervalResponse
                <span class="cov0" title="0">return s.mediaMTXController.SetDiscoveryInterval(int(interval))</span>
        })(params, client)
}

// translateErrorToJsonRpc converts business logic errors to appropriate JSON-RPC errors
func (s *WebSocketServer) translateErrorToJsonRpc(err error, methodName string) *JsonRpcError <span class="cov0" title="0">{
        errMsg := err.Error()

        // External discovery disabled error - check for both variations
        if (strings.Contains(strings.ToLower(errMsg), "external stream discovery") ||
                strings.Contains(strings.ToLower(errMsg), "external discovery")) &amp;&amp;
                (strings.Contains(errMsg, "disabled") || strings.Contains(errMsg, "not configured")) </span><span class="cov0" title="0">{
                return NewJsonRpcError(UNSUPPORTED, "feature_disabled",
                        "External stream discovery is disabled in configuration", "Enable external discovery in configuration")
        }</span>

        // Check for specific error patterns from Phase 1 enhanced error messages
        <span class="cov0" title="0">if strings.Contains(errMsg, "status 404") </span><span class="cov0" title="0">{
                // MediaMTX path not found
                return NewJsonRpcError(CAMERA_NOT_FOUND, "RECORDINGS_NOT_FOUND",
                        "No recordings found", "Check if recordings exist")
        }</span>
        <span class="cov0" title="0">if strings.Contains(errMsg, "status 503") || strings.Contains(errMsg, "failed to connect") </span><span class="cov0" title="0">{
                // MediaMTX service unavailable
                return NewJsonRpcError(MEDIAMTX_UNAVAILABLE, "SERVICE_UNAVAILABLE",
                        "MediaMTX service is not responding", "Try again later")
        }</span>
        <span class="cov0" title="0">if strings.Contains(errMsg, "status 403") </span><span class="cov0" title="0">{
                // Permission denied
                return NewJsonRpcError(INSUFFICIENT_PERMISSIONS, "ACCESS_DENIED",
                        "Access to recordings denied", "Check permissions")
        }</span>

        // Camera-specific errors
        <span class="cov0" title="0">if strings.Contains(errMsg, "not found") || strings.Contains(errMsg, "not available") || strings.Contains(errMsg, "camera device not found") </span><span class="cov0" title="0">{
                return NewJsonRpcError(CAMERA_NOT_FOUND, "camera_not_found",
                        "Camera not found or disconnected", "Check camera identifier")
        }</span>

        // File operation errors
        <span class="cov0" title="0">if strings.Contains(errMsg, "file not found") </span><span class="cov0" title="0">{
                return NewJsonRpcError(FILE_NOT_FOUND, "file_not_found",
                        "File not found or inaccessible", "Verify filename and path")
        }</span>

        // Generic error fallback
        <span class="cov0" title="0">return NewJsonRpcError(INTERNAL_ERROR, "METHOD_ERROR",
                fmt.Sprintf("%s: %v", methodName, err), "Contact support if issue persists")</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package websocket implements the Layer 6 (API) WebSocket JSON-RPC 2.0 server.
//
// This package provides the protocol layer implementation with NO business logic,
// following the architectural constraint that all operations are delegated to
// the MediaMTX controller (single source of truth).
//
// Architecture Compliance:
//   - Protocol Layer Only: No business logic, pure JSON-RPC 2.0 implementation
//   - Delegation Pattern: All operations forwarded to MediaMTX controller
//   - High Concurrency: Supports 1000+ simultaneous WebSocket connections
//   - Security Integration: JWT authentication with role-based access control
//   - Event System: Real-time client notifications via event manager
//
// Key Responsibilities:
//   - WebSocket connection management and lifecycle
//   - JSON-RPC 2.0 protocol implementation and message handling
//   - Authentication enforcement and session management
//   - Input validation and security protection (rate limiting)
//   - Real-time event broadcasting to connected clients
//   - Performance metrics collection and monitoring
//
// Thread Safety: All components are designed for concurrent access with
// appropriate synchronization primitives protecting shared state.
//
// Requirements Coverage:
//   - REQ-API-001: WebSocket JSON-RPC 2.0 API endpoint on port 8002
//   - REQ-API-002: Complete JSON-RPC 2.0 protocol implementation
//   - REQ-API-003: Request/response message handling with proper error codes
//   - REQ-API-011: API methods respond within specified time limits (&lt;2s for V4L2 hardware)
//
// Test Categories: Unit/Integration
// API Documentation Reference: docs/api/json_rpc_methods.md

package websocket

import (
        "context"
        "encoding/json"
        "fmt"
        "net"
        "net/http"
        "runtime"
        "strconv"
        "sync"
        "sync/atomic"
        "time"

        "github.com/camerarecorder/mediamtx-camera-service-go/internal/config"
        "github.com/camerarecorder/mediamtx-camera-service-go/internal/logging"
        "github.com/camerarecorder/mediamtx-camera-service-go/internal/mediamtx"
        "github.com/camerarecorder/mediamtx-camera-service-go/internal/security"
        "github.com/gorilla/websocket"
)

// WebSocketServer implements the Layer 6 (API) WebSocket JSON-RPC 2.0 server.
// This server contains NO business logic and delegates all operations to the
// MediaMTX controller following architectural constraints.
//
// Performance Targets:
//   - 1000+ simultaneous WebSocket connections
//   - &lt;2s response time for 95% of V4L2 hardware operations
//   - &lt;20ms event notification delivery latency
//
// Thread Safety: All shared state is protected by appropriate synchronization:
//   - clientsMutex: Protects clients map and clientCounter
//   - metricsMutex: Protects performance metrics
//   - methodsMutex: Protects method registration map
//   - eventHandlersMutex: Protects event handler slice
//   - stopOnce: Ensures single close operation on stopChan
type WebSocketServer struct {
        // Configuration and Dependencies
        config *ServerConfig // Server-specific configuration (ports, timeouts, etc.)

        // Dependency Injection - All external dependencies injected via constructor
        configManager      *config.ConfigManager       // Configuration management
        logger             *logging.Logger             // Structured logging
        jwtHandler         *security.JWTHandler        // JWT authentication and rate limiting
        mediaMTXController mediamtx.MediaMTXController // Business logic delegation target

        // Security Framework Components
        permissionChecker *security.PermissionChecker // Role-based access control
        validationHelper  *ValidationHelper           // Input validation and sanitization

        // WebSocket Protocol Implementation
        upgrader websocket.Upgrader // WebSocket connection upgrader with CORS settings
        server   *http.Server       // HTTP server for WebSocket endpoint
        running  int32              // Atomic boolean for thread-safe running state (0=false, 1=true)

        // Connection Management - High concurrency support (1000+ connections)
        clients       map[string]*ClientConnection // Active client connections indexed by client ID
        clientsMutex  sync.RWMutex                 // Protects clients map modifications
        clientCounter int64                        // Atomic counter for unique client ID generation
        clientCount   int64                        // Atomic counter for fast client count queries

        // JSON-RPC Method Registration
        methods             map[string]MethodHandler // Registered JSON-RPC methods
        methodsMutex        sync.RWMutex             // Protects method map modifications
        methodVersions      map[string]string        // Method version tracking
        methodVersionsMutex sync.RWMutex             // Protects version map modifications
        builtinMethodsReady int32                    // Atomic flag for builtin method initialization

        // Performance Monitoring
        metrics      *PerformanceMetrics // Request/response performance tracking
        metricsMutex sync.RWMutex        // Protects metrics updates

        // Real-Time Event System
        eventManager       *EventManager               // Event broadcasting manager
        eventHandlers      []func(string, interface{}) // Registered event handlers
        eventHandlersMutex sync.RWMutex                // Protects event handler slice
        eventHandlerCount  int64                       // Atomic counter for handler count

        // Graceful Shutdown Coordination
        stopChan chan struct{}  // Shutdown signal channel
        stopOnce sync.Once      // Ensures single shutdown execution
        wg       sync.WaitGroup // Tracks active goroutines for clean shutdown
}

// isSystemReady checks if the MediaMTX controller is ready to handle requests.
// This implements the progressive readiness pattern where the API becomes available
// as the underlying business logic components complete initialization.
func (s *WebSocketServer) isSystemReady() bool <span class="cov8" title="1">{
        if s.mediaMTXController == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Use the IsReady method from MediaMTXController interface
        <span class="cov8" title="1">return s.mediaMTXController.IsReady()</span>
}

// getSystemReadinessResponse returns a standardized readiness response
func (s *WebSocketServer) getSystemReadinessResponse() map[string]interface{} <span class="cov0" title="0">{
        response := map[string]interface{}{
                "status":            "starting",
                "message":           "System is initializing, please wait",
                "available_cameras": []string{},
                "discovery_active":  false,
        }

        if s.mediaMTXController == nil </span><span class="cov0" title="0">{
                return response
        }</span>

        // Get detailed readiness state if available
        <span class="cov0" title="0">if stateProvider, ok := s.mediaMTXController.(interface{ GetReadinessState() map[string]interface{} }); ok </span><span class="cov0" title="0">{
                state := stateProvider.GetReadinessState()

                if cameras, ok := state["available_cameras"].([]string); ok </span><span class="cov0" title="0">{
                        response["available_cameras"] = cameras
                }</span>

                <span class="cov0" title="0">if cameraReady, ok := state["camera_monitor_ready"].(bool); ok </span><span class="cov0" title="0">{
                        response["discovery_active"] = !cameraReady
                }</span>

                <span class="cov0" title="0">if len(response["available_cameras"].([]string)) &gt; 0 </span><span class="cov0" title="0">{
                        response["status"] = "partial"
                        response["message"] = "Some cameras available, discovery in progress"
                }</span>
        }

        <span class="cov0" title="0">return response</span>
}

// checkMethodPermissions checks if a client has permission to access a specific method
func (s *WebSocketServer) checkMethodPermissions(client *ClientConnection, methodName string) error <span class="cov8" title="1">{
        // Skip permission check for authentication and ping methods
        if methodName == "authenticate" || methodName == "ping" </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Check for nil client to prevent panic
        <span class="cov8" title="1">if client == nil </span><span class="cov0" title="0">{
                s.logger.WithField("method", methodName).Error("Cannot check permissions: client is nil")
                return fmt.Errorf("client is nil")
        }</span>

        // Convert client role to security.Role
        <span class="cov8" title="1">userRole, err := s.permissionChecker.ValidateRole(client.Role)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithFields(logging.Fields{
                        "client_id": client.ClientID,
                        "role":      client.Role,
                        "method":    methodName,
                }).Warn("Invalid role for permission check")
                return fmt.Errorf("invalid role: %s", client.Role)
        }</span>

        // Check permission using existing PermissionChecker
        <span class="cov8" title="1">if !s.permissionChecker.HasPermission(userRole, methodName) </span><span class="cov0" title="0">{
                s.logger.WithFields(logging.Fields{
                        "client_id": client.ClientID,
                        "role":      client.Role,
                        "method":    methodName,
                }).Warn("Permission denied for method")
                return fmt.Errorf("insufficient permissions for method %s", methodName)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// checkRateLimit checks if a client has exceeded the rate limit
func (s *WebSocketServer) checkRateLimit(client *ClientConnection) error <span class="cov8" title="1">{
        // Check for nil client to prevent panic
        if client == nil </span><span class="cov0" title="0">{
                s.logger.Error("Cannot check rate limit: client is nil")
                return fmt.Errorf("client is nil")
        }</span>

        <span class="cov8" title="1">if !s.jwtHandler.CheckRateLimit(client.ClientID) </span><span class="cov0" title="0">{
                s.logger.WithField("client_id", client.ClientID).Warn("Rate limit exceeded")
                return fmt.Errorf("rate limit exceeded")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Real-time notification methods (Phase 3 enhancement)

// notifyRecordingStatusUpdate sends real-time recording status updates to clients
func (s *WebSocketServer) notifyRecordingStatusUpdate(device, status, filename string, duration time.Duration) <span class="cov0" title="0">{
        // Determine event topic based on status
        var topic EventTopic
        switch status </span>{
        case "started":<span class="cov0" title="0">
                topic = TopicRecordingStart</span>
        case "stopped":<span class="cov0" title="0">
                topic = TopicRecordingStop</span>
        case "error":<span class="cov0" title="0">
                topic = TopicRecordingError</span>
        default:<span class="cov0" title="0">
                topic = TopicRecordingProgress</span>
        }

        <span class="cov0" title="0">eventData := map[string]interface{}{
                "device":    device,
                "status":    status,
                "filename":  filename,
                "duration":  duration.Seconds(),
                "timestamp": time.Now().Format(time.RFC3339),
        }

        s.logger.WithFields(logging.Fields{
                "device":   device,
                "status":   status,
                "filename": filename,
                "duration": duration,
                "topic":    topic,
        }).Info("Sending recording status notification")

        // Use new efficient event system
        if err := s.sendEventToSubscribers(topic, eventData); err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).WithField("topic", string(topic)).Error("Failed to send recording status event")
                // Fallback to broadcast for backward compatibility
                s.broadcastEvent("recording_update", eventData)
        }</span>
}

// notifyCameraStatusUpdate sends real-time camera status updates to clients
func (s *WebSocketServer) notifyCameraStatusUpdate(device, status, name string) <span class="cov0" title="0">{
        // Determine event topic based on status
        var topic EventTopic
        switch status </span>{
        case "connected":<span class="cov0" title="0">
                topic = TopicCameraConnected</span>
        case "disconnected":<span class="cov0" title="0">
                topic = TopicCameraDisconnected</span>
        default:<span class="cov0" title="0">
                topic = TopicCameraStatusChange</span>
        }

        <span class="cov0" title="0">eventData := map[string]interface{}{
                "device":    device,
                "status":    status,
                "name":      name,
                "timestamp": time.Now().Format(time.RFC3339),
        }

        s.logger.WithFields(logging.Fields{
                "device": device,
                "status": status,
                "name":   name,
                "topic":  topic,
        }).Info("Sending camera status notification")

        // Use new efficient event system
        if err := s.sendEventToSubscribers(topic, eventData); err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).WithField("topic", string(topic)).Error("Failed to send camera status event")
                // Fallback to broadcast for backward compatibility
                s.broadcastEvent("camera_status_update", eventData)
        }</span>
}

// notifySnapshotTaken sends real-time snapshot notifications to clients
func (s *WebSocketServer) notifySnapshotTaken(device, filename, resolution string) <span class="cov0" title="0">{
        eventData := map[string]interface{}{
                "device":     device,
                "filename":   filename,
                "resolution": resolution,
                "timestamp":  time.Now().Format(time.RFC3339),
        }

        s.logger.WithFields(logging.Fields{
                "device":     device,
                "filename":   filename,
                "resolution": resolution,
                "topic":      TopicSnapshotTaken,
        }).Info("Sending snapshot notification")

        // Use new efficient event system
        if err := s.sendEventToSubscribers(TopicSnapshotTaken, eventData); err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).Error("Failed to send snapshot event")
                // Fallback to broadcast for backward compatibility
                s.broadcastEvent("snapshot_taken", eventData)
        }</span>
}

// notifySystemEvent sends system-level event notifications to clients
func (s *WebSocketServer) notifySystemEvent(eventType string, data map[string]interface{}) <span class="cov0" title="0">{
        var topic EventTopic
        switch eventType </span>{
        case "startup":<span class="cov0" title="0">
                topic = TopicSystemStartup</span>
        case "shutdown":<span class="cov0" title="0">
                topic = TopicSystemShutdown</span>
        case "health":<span class="cov0" title="0">
                topic = TopicSystemHealth</span>
        default:<span class="cov0" title="0">
                topic = TopicSystemError</span>
        }

        // Initialize data map if nil
        <span class="cov0" title="0">if data == nil </span><span class="cov0" title="0">{
                data = make(map[string]interface{})
        }</span>

        // Add timestamp if not present
        <span class="cov0" title="0">if _, exists := data["timestamp"]; !exists </span><span class="cov0" title="0">{
                data["timestamp"] = time.Now().Format(time.RFC3339)
        }</span>

        <span class="cov0" title="0">s.logger.WithFields(logging.Fields{
                "event_type": eventType,
                "topic":      topic,
                "data":       data,
        }).Info("Sending system event notification")

        // Use new efficient event system
        if err := s.sendEventToSubscribers(topic, data); err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).WithField("topic", string(topic)).Error("Failed to send system event")
                // Fallback to broadcast for backward compatibility
                s.broadcastEvent("system_event", data)
        }</span>
}

// broadcastEvent broadcasts an event to all connected clients
// sendEventToAllClients broadcasts events to all connected clients.
// For efficient topic-based delivery, use sendEventToSubscribers instead.
func (s *WebSocketServer) broadcastEvent(eventType string, data interface{}) <span class="cov0" title="0">{
        s.eventHandlersMutex.RLock()
        defer s.eventHandlersMutex.RUnlock()

        // Send to all connected clients
        s.clientsMutex.RLock()
        for clientID, client := range s.clients </span><span class="cov0" title="0">{
                if client.Authenticated &amp;&amp; client.Conn != nil </span><span class="cov0" title="0">{
                        // Create notification message
                        notification := &amp;JsonRpcNotification{
                                JSONRPC: "2.0",
                                Method:  eventType,
                                Params:  data.(map[string]interface{}),
                        }

                        // Send message to client
                        if err := client.Conn.SetWriteDeadline(time.Now().Add(s.config.WriteTimeout)); err != nil </span><span class="cov0" title="0">{
                                s.logger.WithError(err).WithFields(logging.Fields{
                                        "client_id":  clientID,
                                        "event_type": eventType,
                                }).Warn("Failed to set write deadline for notification")
                        }</span>
                        <span class="cov0" title="0">if err := client.Conn.WriteJSON(notification); err != nil </span><span class="cov0" title="0">{
                                s.logger.WithError(err).WithFields(logging.Fields{
                                        "client_id":  clientID,
                                        "event_type": eventType,
                                }).Error("Failed to send notification to client")
                        }</span> else<span class="cov0" title="0"> {
                                s.logger.WithFields(logging.Fields{
                                        "client_id":  clientID,
                                        "event_type": eventType,
                                }).Info("Notification sent to client")
                        }</span>
                }
        }
        <span class="cov0" title="0">s.clientsMutex.RUnlock()</span>
}

// sendEventToSubscribers sends an event only to clients subscribed to the specific topic
func (s *WebSocketServer) sendEventToSubscribers(topic EventTopic, data map[string]interface{}) error <span class="cov0" title="0">{
        // Publish event through event manager
        if err := s.eventManager.PublishEvent(topic, data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to publish event: %w", err)
        }</span>

        // Get subscribers for this topic
        <span class="cov0" title="0">subscribers := s.eventManager.GetSubscribersForTopic(topic)
        if len(subscribers) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Send event only to subscribed clients
        <span class="cov0" title="0">s.clientsMutex.RLock()
        defer s.clientsMutex.RUnlock()

        notification := &amp;JsonRpcNotification{
                JSONRPC: "2.0",
                Method:  string(topic),
                Params:  data,
        }

        sentCount := 0
        for _, clientID := range subscribers </span><span class="cov0" title="0">{
                if client, exists := s.clients[clientID]; exists &amp;&amp; client.Authenticated &amp;&amp; client.Conn != nil </span><span class="cov0" title="0">{
                        // Send message to client
                        if err := client.Conn.SetWriteDeadline(time.Now().Add(s.config.WriteTimeout)); err != nil </span><span class="cov0" title="0">{
                                s.logger.WithError(err).WithFields(logging.Fields{
                                        "client_id": clientID,
                                        "topic":     topic,
                                }).Warn("Failed to set write deadline for event")
                        }</span>
                        <span class="cov0" title="0">if err := client.Conn.WriteJSON(notification); err != nil </span><span class="cov0" title="0">{
                                s.logger.WithError(err).WithFields(logging.Fields{
                                        "client_id": clientID,
                                        "topic":     topic,
                                }).Error("Failed to send event to subscribed client")
                        }</span> else<span class="cov0" title="0"> {
                                sentCount++
                                s.logger.WithFields(logging.Fields{
                                        "client_id": clientID,
                                        "topic":     topic,
                                }).Info("Event sent to subscribed client")
                        }</span>
                }
        }

        <span class="cov0" title="0">s.logger.WithFields(logging.Fields{
                "topic":       topic,
                "subscribers": len(subscribers),
                "sent_count":  sentCount,
        }).Info("Event delivered to subscribed clients")

        return nil</span>
}

// addEventHandler adds a new event handler
func (s *WebSocketServer) addEventHandler(handler func(string, interface{})) <span class="cov0" title="0">{
        s.eventHandlersMutex.Lock()
        defer s.eventHandlersMutex.Unlock()

        s.eventHandlers = append(s.eventHandlers, handler)
        atomic.AddInt64(&amp;s.eventHandlerCount, 1)
}</span>

// NewWebSocketServer creates a new WebSocket server with proper dependency injection
func NewWebSocketServer(
        configManager *config.ConfigManager,
        logger *logging.Logger,
        jwtHandler *security.JWTHandler,
        mediaMTXController mediamtx.MediaMTXController,
) (*WebSocketServer, error) <span class="cov8" title="1">{
        if configManager == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("configManager cannot be nil")
        }</span>

        <span class="cov8" title="1">if logger == nil </span><span class="cov0" title="0">{
                logger = logging.GetLogger("websocket.server") // Component-specific logger naming
        }</span>

        <span class="cov8" title="1">if jwtHandler == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("jwtHandler cannot be nil - use existing internal/security/JWTHandler")
        }</span>

        <span class="cov8" title="1">if mediaMTXController == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("mediaMTXController cannot be nil - use existing internal/mediamtx/MediaMTXController")
        }</span>

        // Get configuration from config manager
        <span class="cov8" title="1">cfg := configManager.GetConfig()
        if cfg == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no configuration loaded")
        }</span>

        // Create server configuration
        <span class="cov8" title="1">serverConfig := &amp;ServerConfig{
                Host:           cfg.Server.Host,
                Port:           cfg.Server.Port,
                WebSocketPath:  cfg.Server.WebSocketPath,
                MaxConnections: cfg.Server.MaxConnections,
                ReadTimeout:    cfg.Server.ReadTimeout,
                WriteTimeout:   cfg.Server.WriteTimeout,
                PingInterval:   cfg.Server.PingInterval,
                PongWait:       cfg.Server.PongWait,
                MaxMessageSize: cfg.Server.MaxMessageSize,
                AutoCloseAfter: cfg.Server.AutoCloseAfter,
        }

        server := &amp;WebSocketServer{
                config:             serverConfig,
                configManager:      configManager,
                logger:             logger,
                jwtHandler:         jwtHandler,
                mediaMTXController: mediaMTXController,

                // Security extensions initialization (Phase 1 enhancement)
                permissionChecker: security.NewPermissionChecker(),

                // Input validation initialization (wire real validator with config adapter)
                validationHelper: NewValidationHelper(security.NewInputValidator(logger, security.NewConfigAdapter(&amp;cfg.Security, &amp;cfg.Logging)), logger),

                // WebSocket upgrader configuration
                upgrader: websocket.Upgrader{
                        ReadBufferSize:  cfg.Server.ReadBufferSize,
                        WriteBufferSize: cfg.Server.WriteBufferSize,
                        CheckOrigin: func(r *http.Request) bool </span><span class="cov8" title="1">{
                                return validateCORSOrigin(r, cfg, logger)
                        }</span>,
                },

                // Client management
                clients:       make(map[string]*ClientConnection),
                clientCounter: 0,

                // Method registration
                methods:        make(map[string]MethodHandler),
                methodsMutex:   sync.RWMutex{},
                methodVersions: make(map[string]string),

                // Performance metrics
                metrics: &amp;PerformanceMetrics{
                        RequestCount:      0,
                        ResponseTimes:     make(map[string][]float64),
                        ErrorCount:        0,
                        ActiveConnections: 0,
                        StartTime:         time.Now(),
                },

                // Event handling
                eventManager:  NewEventManager(logger),
                eventHandlers: make([]func(string, interface{}), 0),

                // Graceful shutdown
                stopChan: make(chan struct{}, 10), // Buffered to prevent deadlock during shutdown
                stopOnce: sync.Once{},
        }

        // Register built-in methods
        <span class="cov8" title="1">server.registerBuiltinMethods()

        // Mark builtin methods as ready
        atomic.StoreInt32(&amp;server.builtinMethodsReady, 1)

        return server, nil</span>
}

// Start starts the WebSocket server
func (s *WebSocketServer) Start() error <span class="cov0" title="0">{
        // Idempotency: set running flag atomically to prevent double start races
        if !atomic.CompareAndSwapInt32(&amp;s.running, 0, 1) </span><span class="cov0" title="0">{
                s.logger.Warn("WebSocket server is already running")
                return fmt.Errorf("WebSocket server is already running")
        }</span>

        <span class="cov0" title="0">s.logger.WithFields(logging.Fields{
                "host":   s.config.Host,
                "port":   s.config.Port,
                "path":   s.config.WebSocketPath,
                "action": "start_server",
        }).Info("Starting WebSocket JSON-RPC server")

        // Create HTTP server
        mux := http.NewServeMux()
        mux.HandleFunc(s.config.WebSocketPath, s.handleWebSocket)

        s.server = &amp;http.Server{
                Addr:         fmt.Sprintf("%s:%d", s.config.Host, s.config.Port),
                Handler:      mux,
                ReadTimeout:  s.config.ReadTimeout,
                WriteTimeout: s.config.WriteTimeout,
        }

        // Start server in goroutine
        s.wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer s.wg.Done()

                if err := s.server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        s.logger.WithError(err).Error("WebSocket server failed")
                        // Reset running flag on failure
                        atomic.StoreInt32(&amp;s.running, 0)
                }</span>
        }()

        // Server should be ready immediately with proper atomic flag handling

        <span class="cov0" title="0">s.logger.WithFields(logging.Fields{
                "host":   s.config.Host,
                "port":   s.config.Port,
                "path":   s.config.WebSocketPath,
                "action": "start_server",
                "status": "success",
        }).Info("WebSocket server started successfully")

        return nil</span>
}

// StartWithListener starts the server using an existing listener (for race-free testing)
func (s *WebSocketServer) StartWithListener(listener net.Listener) error <span class="cov8" title="1">{
        // Idempotency: set running flag atomically to prevent double start races
        if !atomic.CompareAndSwapInt32(&amp;s.running, 0, 1) </span><span class="cov0" title="0">{
                s.logger.Warn("WebSocket server is already running")
                return fmt.Errorf("WebSocket server is already running")
        }</span>

        <span class="cov8" title="1">s.logger.WithFields(logging.Fields{
                "addr":   listener.Addr().String(),
                "path":   s.config.WebSocketPath,
                "action": "start_server_with_listener",
        }).Info("Starting WebSocket JSON-RPC server with existing listener")

        // Create HTTP server
        mux := http.NewServeMux()
        mux.HandleFunc(s.config.WebSocketPath, s.handleWebSocket)

        s.server = &amp;http.Server{
                Handler:      mux,
                ReadTimeout:  s.config.ReadTimeout,
                WriteTimeout: s.config.WriteTimeout,
        }

        // Start server in goroutine using existing listener
        s.wg.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer s.wg.Done()

                if err := s.server.Serve(listener); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        s.logger.WithError(err).Error("WebSocket server failed")
                        // Reset running flag on failure
                        atomic.StoreInt32(&amp;s.running, 0)
                }</span>
        }()

        <span class="cov8" title="1">s.logger.WithFields(logging.Fields{
                "addr":   listener.Addr().String(),
                "path":   s.config.WebSocketPath,
                "action": "start_server_with_listener",
                "status": "success",
        }).Info("WebSocket server started successfully with existing listener")

        return nil</span>
}

// Stop stops the WebSocket server gracefully with context-aware cancellation
func (s *WebSocketServer) Stop(ctx context.Context) error <span class="cov8" title="1">{
        if atomic.LoadInt32(&amp;s.running) == 0 </span><span class="cov0" title="0">{
                s.logger.Warn("WebSocket server is not running")
                return fmt.Errorf("WebSocket server is not running")
        }</span>

        <span class="cov8" title="1">s.logger.Info("Stopping WebSocket server")

        // Signal shutdown - use sync.Once to ensure single close operation
        s.stopOnce.Do(func() </span><span class="cov8" title="1">{
                close(s.stopChan)
        }</span>)

        // Close all client connections with timeout
        <span class="cov8" title="1">s.closeAllClientConnections()

        // Shutdown HTTP server with context
        if s.server != nil </span><span class="cov8" title="1">{
                if err := s.server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        s.logger.WithError(err).Error("Error shutting down HTTP server")
                        // Note: Error is logged but not returned as this is cleanup operation
                }</span>
        }

        // Wait for all goroutines to finish with context timeout
        <span class="cov8" title="1">done := make(chan struct{})
        go func() </span><span class="cov8" title="1">{
                s.wg.Wait()
                close(done)
        }</span>()

        <span class="cov8" title="1">select </span>{
        case &lt;-done:<span class="cov8" title="1"></span>
                // Clean shutdown
        case &lt;-ctx.Done():<span class="cov0" title="0">
                s.logger.Warn("WebSocket server shutdown timeout, forcing stop")
                // Reflect state accurately; server may still be up
                return fmt.Errorf("shutdown timeout")</span>
        }

        <span class="cov8" title="1">atomic.StoreInt32(&amp;s.running, 0)

        s.logger.Info("WebSocket server stopped successfully")
        return nil</span>
}

// closeAllClientConnections closes all client connections with timeout
func (s *WebSocketServer) closeAllClientConnections() <span class="cov8" title="1">{
        s.logger.Info("Starting client connection cleanup")

        // Create cleanup context with timeout
        ctx, cancel := context.WithTimeout(context.Background(), s.config.ClientCleanupTimeout)
        defer cancel()

        // Get list of clients to close
        s.clientsMutex.Lock()
        clientsToClose := make([]*ClientConnection, 0, len(s.clients))
        for _, client := range s.clients </span><span class="cov0" title="0">{
                clientsToClose = append(clientsToClose, client)
        }</span>
        <span class="cov8" title="1">s.clientsMutex.Unlock()

        if len(clientsToClose) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        // Close connections concurrently with timeout
        <span class="cov0" title="0">var wg sync.WaitGroup

        // Create channel for cleanup results
        cleanupResults := make(chan error, len(clientsToClose))

        for _, client := range clientsToClose </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(client *ClientConnection) </span><span class="cov0" title="0">{
                        defer wg.Done()

                        // Set close deadline
                        if err := client.Conn.SetWriteDeadline(time.Now().Add(s.config.ClientCleanupTimeout)); err != nil </span><span class="cov0" title="0">{
                                s.logger.WithError(err).WithField("client_id", client.ClientID).Warn("Failed to set write deadline for close message")
                        }</span>

                        // Send close message
                        <span class="cov0" title="0">closeMsg := websocket.FormatCloseMessage(websocket.CloseGoingAway, "server shutdown")
                        if err := client.Conn.WriteControl(websocket.CloseMessage, closeMsg, time.Now().Add(s.config.ClientCleanupTimeout)); err != nil </span><span class="cov0" title="0">{
                                s.logger.WithError(err).WithField("client_id", client.ClientID).Warn("Failed to send close message")
                        }</span>

                        // Close connection
                        <span class="cov0" title="0">if err := client.Conn.Close(); err != nil </span><span class="cov0" title="0">{
                                // Safe channel send - won't panic if channel is closed
                                select </span>{
                                case cleanupResults &lt;- fmt.Errorf("failed to close connection for client %s: %w", client.ClientID, err):<span class="cov0" title="0"></span>
                                default:<span class="cov0" title="0"></span>
                                        // Channel closed or full, ignore
                                }
                                <span class="cov0" title="0">return</span>
                        }

                        // Remove client from map and update metrics atomically
                        <span class="cov0" title="0">s.clientsMutex.Lock()
                        if _, exists := s.clients[client.ClientID]; exists </span><span class="cov0" title="0">{
                                delete(s.clients, client.ClientID)
                                atomic.AddInt64(&amp;s.clientCount, -1)
                        }</span>
                        <span class="cov0" title="0">s.clientsMutex.Unlock()

                        // Remove event subscriptions
                        s.eventManager.RemoveClient(client.ClientID)

                        // Use atomic operation for metrics update
                        atomic.AddInt64(&amp;s.metrics.ActiveConnections, -1)

                        // Safe channel send - won't panic if channel is closed
                        select </span>{
                        case cleanupResults &lt;- nil:<span class="cov0" title="0"></span>
                        default:<span class="cov0" title="0"></span>
                                // Channel closed or full, ignore
                        }
                }(client)
        }

        // Wait for cleanup with timeout
        <span class="cov0" title="0">cleanupDone := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(cleanupDone)
        }</span>()

        <span class="cov0" title="0">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                s.logger.Warn("Client cleanup timeout reached, forcing connection closure")
                // Force close remaining connections
                for _, client := range clientsToClose </span><span class="cov0" title="0">{
                        if err := client.Conn.Close(); err != nil </span><span class="cov0" title="0">{
                                s.logger.WithError(err).WithField("client_id", client.ClientID).Warn("Failed to force close connection")
                        }</span>
                }
        case &lt;-cleanupDone:<span class="cov0" title="0"></span>
        }

        // Check cleanup results
        <span class="cov0" title="0">errorCount := 0
        for i := 0; i &lt; len(clientsToClose); i++ </span><span class="cov0" title="0">{
                select </span>{
                case err := &lt;-cleanupResults:<span class="cov0" title="0">
                        if err != nil </span><span class="cov0" title="0">{
                                errorCount++
                                s.logger.WithError(err).Warn("Client cleanup error")
                        }</span>
                case &lt;-time.After(5 * time.Second):<span class="cov0" title="0">
                        s.logger.Warn("Timeout waiting for cleanup result")
                        break</span>
                }
        }

        <span class="cov0" title="0">if errorCount &gt; 0 </span><span class="cov0" title="0">{
                s.logger.WithField("error_count", fmt.Sprintf("%d", errorCount)).Warn("Some client connections had cleanup errors")
        }</span> else<span class="cov0" title="0"> {
                s.logger.Info("All client connections cleaned up successfully")
        }</span>
}

// handleWebSocket handles WebSocket upgrade and connection management
func (s *WebSocketServer) handleWebSocket(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Check connection limit with atomic operation (lock-free)
        if atomic.LoadInt64(&amp;s.metrics.ActiveConnections) &gt;= int64(s.config.MaxConnections) </span><span class="cov0" title="0">{
                s.logger.Warn("Maximum connections reached")
                http.Error(w, "Maximum connections reached", http.StatusServiceUnavailable)
                return
        }</span>

        // Upgrade HTTP connection to WebSocket
        <span class="cov8" title="1">conn, err := s.upgrader.Upgrade(w, r, nil)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).Error("Failed to upgrade connection to WebSocket")
                return
        }</span>

        // Generate client ID with atomic operations (lock-free)
        <span class="cov8" title="1">clientCounter := atomic.AddInt64(&amp;s.clientCounter, 1)
        clientID := "client_" + strconv.FormatInt(clientCounter, 10)

        // Create client connection
        client := &amp;ClientConnection{
                ClientID:      clientID,
                Authenticated: false,
                ConnectedAt:   time.Now(),
                Subscriptions: make(map[string]bool),
                Conn:          conn,
        }

        // Add client to connections and update metrics atomically
        s.clientsMutex.Lock()
        s.clients[clientID] = client
        atomic.AddInt64(&amp;s.clientCount, 1)
        s.clientsMutex.Unlock()

        // Update metrics with atomic operation
        atomic.AddInt64(&amp;s.metrics.ActiveConnections, 1)

        s.logger.WithFields(logging.Fields{
                "client_id": clientID,
                "action":    "client_connected",
        }).Info("Client connected")

        // Handle connection in goroutine
        s.wg.Add(1)
        go s.handleClientConnection(conn, client)</span>
}

// handleClientConnection handles individual client connections
func (s *WebSocketServer) handleClientConnection(conn *websocket.Conn, client *ClientConnection) <span class="cov8" title="1">{
        // Create error channel for panic recovery
        panicChan := make(chan error, 1)

        defer func() </span><span class="cov8" title="1">{
                // Recover from panics in goroutine and propagate as errors
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        // Get stack trace for debugging
                        stack := make([]byte, 4096)
                        length := runtime.Stack(stack, false)
                        stackTrace := string(stack[:length])

                        panicErr := fmt.Errorf("panic in client connection handler for client %s: %v", client.ClientID, r)
                        s.logger.WithFields(logging.Fields{
                                "client_id":   client.ClientID,
                                "panic":       r,
                                "action":      "panic_recovered",
                                "stack_trace": stackTrace,
                        }).Error("Recovered from panic in client connection handler")

                        // Propagate panic as error instead of swallowing it
                        select </span>{
                        case panicChan &lt;- panicErr:<span class="cov0" title="0"></span>
                        default:<span class="cov0" title="0">
                                s.logger.WithError(panicErr).Warn("Panic channel overflow, panic error dropped")</span>
                        }
                }

                // Remove client from connections and update metrics atomically
                <span class="cov8" title="1">s.clientsMutex.Lock()
                if _, exists := s.clients[client.ClientID]; exists </span><span class="cov8" title="1">{
                        delete(s.clients, client.ClientID)
                        atomic.AddInt64(&amp;s.clientCount, -1)
                }</span>
                <span class="cov8" title="1">s.clientsMutex.Unlock()

                // Remove event subscriptions
                s.eventManager.RemoveClient(client.ClientID)

                // Update metrics with atomic operation
                atomic.AddInt64(&amp;s.metrics.ActiveConnections, -1)

                // Close connection
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.WithError(err).WithField("client_id", client.ClientID).Warn("Failed to close connection")
                }</span>

                <span class="cov8" title="1">s.logger.WithFields(logging.Fields{
                        "client_id": client.ClientID,
                        "action":    "client_disconnected",
                }).Info("Client disconnected")

                s.wg.Done()</span>
        }()

        // Set connection parameters
        <span class="cov8" title="1">conn.SetReadLimit(s.config.MaxMessageSize)
        if err := conn.SetReadDeadline(time.Now().Add(s.config.PongWait)); err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).WithField("client_id", client.ClientID).Warn("Failed to set initial read deadline")
        }</span>
        <span class="cov8" title="1">conn.SetPongHandler(func(string) error </span><span class="cov0" title="0">{
                if err := conn.SetReadDeadline(time.Now().Add(s.config.PongWait)); err != nil </span><span class="cov0" title="0">{
                        s.logger.WithError(err).WithField("client_id", client.ClientID).Warn("Failed to set pong read deadline")
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        // Start ping ticker
        <span class="cov8" title="1">ticker := time.NewTicker(s.config.PingInterval)
        defer ticker.Stop()

        // Create message handling context with timeout
        msgCtx, msgCancel := context.WithCancel(context.Background())
        defer msgCancel()

        // Message handling loop
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-s.stopChan:<span class="cov0" title="0">
                        return</span>
                case &lt;-msgCtx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        // Set write deadline for ping
                        if err := conn.SetWriteDeadline(time.Now().Add(s.config.WriteTimeout)); err != nil </span><span class="cov0" title="0">{
                                s.logger.WithError(err).WithField("client_id", client.ClientID).Warn("Failed to set write deadline for ping")
                        }</span>
                        <span class="cov0" title="0">if err := conn.WriteControl(websocket.PingMessage, []byte{}, time.Now().Add(s.config.WriteTimeout)); err != nil </span><span class="cov0" title="0">{
                                s.logger.WithError(err).WithField("client_id", client.ClientID).Error("Failed to send ping")
                                return
                        }</span>
                default:<span class="cov8" title="1">
                        // Set read deadline for message
                        if err := conn.SetReadDeadline(time.Now().Add(s.config.ReadTimeout)); err != nil </span><span class="cov0" title="0">{
                                s.logger.WithError(err).WithField("client_id", client.ClientID).Warn("Failed to set read deadline for message")
                        }</span>

                        // Read message with timeout
                        <span class="cov8" title="1">_, message, err := conn.ReadMessage()
                        if err != nil </span><span class="cov8" title="1">{
                                if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) </span><span class="cov0" title="0">{
                                        s.logger.WithError(err).WithField("client_id", client.ClientID).Error("WebSocket read error")
                                }</span> else<span class="cov8" title="1"> if websocket.IsCloseError(err, websocket.CloseNormalClosure, websocket.CloseGoingAway) </span>{<span class="cov0" title="0">
                                }</span>
                                <span class="cov8" title="1">return</span>
                        }

                        // Handle message
                        <span class="cov8" title="1">s.handleMessage(conn, client, message)</span>
                }
        }
}

// handleMessage processes incoming WebSocket messages
func (s *WebSocketServer) handleMessage(conn *websocket.Conn, client *ClientConnection, message []byte) <span class="cov8" title="1">{
        startTime := time.Now()

        s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "action":    "handle_message",
        }).Info("Processing WebSocket message")

        // Parse JSON-RPC request
        var request JsonRpcRequest
        if err := json.Unmarshal(message, &amp;request); err != nil </span><span class="cov0" title="0">{
                // Standardized error
                if sendErr := s.sendResponse(conn, &amp;JsonRpcResponse{JSONRPC: "2.0", ID: nil, Error: NewJsonRpcError(INVALID_REQUEST, "invalid_request", "Invalid JSON-RPC request", "Ensure valid JSON-RPC 2.0 structure")}); sendErr != nil </span><span class="cov0" title="0">{
                        s.logger.WithError(sendErr).Error("Failed to send invalid request error response")
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Validate JSON-RPC version
        <span class="cov8" title="1">if request.JSONRPC != "2.0" </span><span class="cov0" title="0">{
                if sendErr := s.sendResponse(conn, &amp;JsonRpcResponse{JSONRPC: "2.0", ID: request.ID, Error: NewJsonRpcError(INVALID_REQUEST, "invalid_version", "Invalid JSON-RPC version", "Set jsonrpc to '2.0'")}); sendErr != nil </span><span class="cov0" title="0">{
                        s.logger.WithError(sendErr).Error("Failed to send invalid version error response")
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Check if this is a notification (ID is null)
        <span class="cov8" title="1">isNotification := request.ID == nil

        // Handle request
        response, err := s.handleRequest(&amp;request, client)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).WithFields(logging.Fields{
                        "client_id": client.ClientID,
                        "method":    request.Method,
                }).Error("Request handling error")
                // Only send error response for requests, not notifications
                if !isNotification </span><span class="cov0" title="0">{
                        if sendErr := s.sendResponse(conn, &amp;JsonRpcResponse{JSONRPC: "2.0", ID: request.ID, Error: NewJsonRpcError(INTERNAL_ERROR, "internal_error", err.Error(), "Retry or contact support")}); sendErr != nil </span><span class="cov0" title="0">{
                                s.logger.WithError(sendErr).Error("Failed to send internal error response")
                        }</span>
                }
                <span class="cov0" title="0">return</span>
        }

        // Only send response for requests, not notifications
        <span class="cov8" title="1">if !isNotification </span><span class="cov8" title="1">{
                // Attach API metadata
                if response != nil </span><span class="cov8" title="1">{
                        if response.Metadata == nil </span><span class="cov8" title="1">{
                                response.Metadata = make(map[string]interface{})
                        }</span>
                        <span class="cov8" title="1">response.Metadata["processing_time_ms"] = time.Since(startTime).Milliseconds()
                        response.Metadata["server_timestamp"] = time.Now().Format(time.RFC3339)
                        response.Metadata["request_id"] = request.ID</span>
                }
                <span class="cov8" title="1">if err := s.sendResponse(conn, response); err != nil </span><span class="cov0" title="0">{
                        s.logger.WithError(err).WithField("client_id", client.ClientID).Error("Failed to send response")
                        return
                }</span>
        }

        // Record performance metrics
        <span class="cov8" title="1">duration := time.Since(startTime).Seconds()
        s.recordRequest(request.Method, duration)

        s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    request.Method,
                "duration":  duration,
                "action":    "request_completed",
        }).Info("Request completed")</span>
}

// handleRequest processes JSON-RPC requests
func (s *WebSocketServer) handleRequest(request *JsonRpcRequest, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov8" title="1">{
        // Security extensions: Rate limiting check (Phase 1 enhancement)
        if err := s.checkRateLimit(client); err != nil </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        ID:      request.ID,
                        Error:   NewJsonRpcError(RATE_LIMIT_EXCEEDED, "rate_limit", err.Error(), "Reduce request rate or wait"),
                }, nil
        }</span>

        // Find method handler with mutex-protected lookup
        <span class="cov8" title="1">s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    request.Method,
                "action":    "method_lookup",
        }).Info("Looking up method handler")

        s.methodsMutex.RLock()
        handler, exists := s.methods[request.Method]
        s.methodsMutex.RUnlock()

        s.logger.WithFields(logging.Fields{
                "client_id":    client.ClientID,
                "method":       request.Method,
                "exists":       exists,
                "handler_type": fmt.Sprintf("%T", handler),
                "action":       "method_lookup_result",
        }).Info("Method lookup completed")

        if !exists </span><span class="cov0" title="0">{
                s.logger.WithFields(logging.Fields{
                        "client_id": client.ClientID,
                        "method":    request.Method,
                        "action":    "method_not_found",
                }).Info("Method not found")
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        ID:      request.ID,
                        Error:   NewJsonRpcError(METHOD_NOT_FOUND, "method_not_found", request.Method, "Verify method name"),
                }, nil
        }</span>

        // Security extensions: Authentication check (Phase 1 enhancement) - FIRST GATE
        // Authentication must happen before any other checks, including readiness
        // ping method is the only exception - it works without authentication per API spec
        <span class="cov8" title="1">if request.Method != "authenticate" &amp;&amp; request.Method != "ping" </span><span class="cov8" title="1">{
                if !client.Authenticated </span><span class="cov0" title="0">{
                        s.logger.WithFields(logging.Fields{
                                "client_id": client.ClientID,
                                "method":    request.Method,
                                "action":    "auth_required",
                                "component": "security_middleware",
                        }).Warn("Authentication required for method")
                        return &amp;JsonRpcResponse{
                                JSONRPC: "2.0",
                                ID:      request.ID,
                                Error:   NewJsonRpcError(AUTHENTICATION_REQUIRED, "auth_required", "Authentication required", "Authenticate first"),
                        }, nil
                }</span>
        }

        // PROGRESSIVE READINESS ARCHITECTURE: Remove blocking system readiness check
        // Each operation implements its own Progressive Readiness pattern with fallback behavior
        // This follows the architectural requirement: "System accepts connections immediately"
        <span class="cov8" title="1">s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    request.Method,
                "action":    "progressive_readiness_enabled",
        }).Info("Progressive Readiness: Attempting operation with potential fallback")

        // Security extensions: Permission check (Phase 1 enhancement)
        // Skip permission check for authenticate and ping methods
        if request.Method != "authenticate" &amp;&amp; request.Method != "ping" </span><span class="cov8" title="1">{
                s.logger.WithFields(logging.Fields{
                        "client_id": client.ClientID,
                        "method":    request.Method,
                        "action":    "permission_check",
                }).Info("Checking method permissions")

                if err := s.checkMethodPermissions(client, request.Method); err != nil </span><span class="cov0" title="0">{
                        s.logger.WithFields(logging.Fields{
                                "client_id": client.ClientID,
                                "method":    request.Method,
                                "error":     err.Error(),
                                "action":    "permission_denied",
                        }).Info("Permission check failed")
                        return &amp;JsonRpcResponse{
                                JSONRPC: "2.0",
                                ID:      request.ID,
                                Error:   NewJsonRpcError(INSUFFICIENT_PERMISSIONS, "permission_denied", err.Error(), "Use an account with permission"),
                        }, nil
                }</span>
        }

        // Call method handler
        <span class="cov8" title="1">s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    request.Method,
                "action":    "calling_handler",
        }).Info("Calling method handler")

        response, err := handler(request.Params, client)
        if err != nil </span><span class="cov0" title="0">{
                // Update error metrics with atomic operation
                atomic.AddInt64(&amp;s.metrics.ErrorCount, 1)

                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        ID:      request.ID,
                        Error:   NewJsonRpcError(INTERNAL_ERROR, "handler_error", err.Error(), "Retry or contact support"),
                }, nil
        }</span>

        // Set JSON-RPC version and ID
        <span class="cov8" title="1">response.JSONRPC = "2.0"
        response.ID = request.ID

        return response, nil</span>
}

// sendResponse sends a JSON-RPC response to the client
func (s *WebSocketServer) sendResponse(conn *websocket.Conn, response *JsonRpcResponse) error <span class="cov8" title="1">{
        if err := conn.SetWriteDeadline(time.Now().Add(s.config.WriteTimeout)); err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).Warn("Failed to set write deadline for response")
                // Continue with WriteJSON - the operation might still succeed
        }</span>
        <span class="cov8" title="1">return conn.WriteJSON(response)</span>
}

// sendErrorResponse sends a JSON-RPC error response to the client
func (s *WebSocketServer) sendErrorResponse(conn *websocket.Conn, id interface{}, code int, message string) <span class="cov0" title="0">{
        // Check for nil connection to prevent panic
        if conn == nil </span><span class="cov0" title="0">{
                s.logger.WithFields(logging.Fields{
                        "error_code": code,
                        "message":    message,
                }).Error("Cannot send error response: connection is nil")
                return
        }</span>

        <span class="cov0" title="0">response := &amp;JsonRpcResponse{JSONRPC: "2.0", ID: id, Error: NewJsonRpcError(code, "error", message, "See documentation")}

        if err := s.sendResponse(conn, response); err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).Error("Failed to send error response")
        }</span>
}

// recordRequest records performance metrics for a request
func (s *WebSocketServer) recordRequest(method string, duration float64) <span class="cov8" title="1">{
        // Use atomic operation for RequestCount
        atomic.AddInt64(&amp;s.metrics.RequestCount, 1)

        // ResponseTimes still needs mutex protection due to map operations
        s.metricsMutex.Lock()
        defer s.metricsMutex.Unlock()

        if s.metrics.ResponseTimes[method] == nil </span><span class="cov8" title="1">{
                s.metrics.ResponseTimes[method] = make([]float64, 0)
        }</span>
        <span class="cov8" title="1">s.metrics.ResponseTimes[method] = append(s.metrics.ResponseTimes[method], duration)</span>
}

// GetMetrics returns current performance metrics
func (s *WebSocketServer) GetMetrics() *PerformanceMetrics <span class="cov0" title="0">{
        // Use atomic operations for reading counters
        requestCount := atomic.LoadInt64(&amp;s.metrics.RequestCount)
        errorCount := atomic.LoadInt64(&amp;s.metrics.ErrorCount)
        activeConnections := atomic.LoadInt64(&amp;s.metrics.ActiveConnections)

        // ResponseTimes still needs mutex protection due to map operations
        s.metricsMutex.RLock()
        defer s.metricsMutex.RUnlock()

        // Note: Average response time calculation is available for future use
        // when extending the metrics functionality
        // Example: allResponseTimes := make([]float64, 0)
        // for _, times := range s.metrics.ResponseTimes {
        //     allResponseTimes = append(allResponseTimes, times...)
        // }

        // Create a deep copy to prevent race conditions
        responseTimesCopy := make(map[string][]float64)
        for method, times := range s.metrics.ResponseTimes </span><span class="cov0" title="0">{
                timesCopy := make([]float64, len(times))
                copy(timesCopy, times)
                responseTimesCopy[method] = timesCopy
        }</span>

        <span class="cov0" title="0">return &amp;PerformanceMetrics{
                RequestCount:      requestCount,
                ResponseTimes:     responseTimesCopy,
                ErrorCount:        errorCount,
                ActiveConnections: activeConnections,
                StartTime:         s.metrics.StartTime,
        }</span>
}

// IsRunning returns whether the server is currently running
func (s *WebSocketServer) IsRunning() bool <span class="cov0" title="0">{
        return atomic.LoadInt32(&amp;s.running) == 1
}</span>

// GetClientCount returns the current number of connected clients using atomic operation
func (s *WebSocketServer) GetClientCount() int64 <span class="cov0" title="0">{
        return atomic.LoadInt64(&amp;s.clientCount)
}</span>

// IsBuiltinMethodsReady returns whether builtin methods are registered using atomic operation
func (s *WebSocketServer) IsBuiltinMethodsReady() bool <span class="cov0" title="0">{
        return atomic.LoadInt32(&amp;s.builtinMethodsReady) == 1
}</span>

// GetEventHandlerCount returns the current number of event handlers using atomic operation
// validateCORSOrigin validates the origin header against configured CORS origins
func validateCORSOrigin(r *http.Request, cfg *config.Config, logger *logging.Logger) bool <span class="cov8" title="1">{
        origin := r.Header.Get("Origin")

        // Allow same-origin requests (no Origin header)
        if origin == "" </span><span class="cov8" title="1">{
                return true
        }</span>

        // Check against configured allowed origins
        <span class="cov0" title="0">for _, allowed := range cfg.Security.CORSOrigins </span><span class="cov0" title="0">{
                if origin == allowed </span><span class="cov0" title="0">{
                        logger.WithFields(logging.Fields{
                                "origin":  origin,
                                "allowed": true,
                        }).Info("CORS origin validated successfully")
                        return true
                }</span>
        }

        // Log rejected origin for security monitoring
        <span class="cov0" title="0">logger.WithFields(logging.Fields{
                "origin":          origin,
                "allowed_origins": cfg.Security.CORSOrigins,
                "allowed":         false,
        }).Warn("CORS origin rejected")

        return false</span>
}

func (s *WebSocketServer) GetEventHandlerCount() int64 <span class="cov0" title="0">{
        return atomic.LoadInt64(&amp;s.eventHandlerCount)
}</span>

// GetConfig returns the server configuration (for testing purposes)
func (s *WebSocketServer) GetConfig() *ServerConfig <span class="cov0" title="0">{
        return s.config
}</span>

// SetConfig sets the server configuration (for testing purposes)
func (s *WebSocketServer) SetConfig(config *ServerConfig) <span class="cov0" title="0">{
        s.config = config
}</span>

// SetMediaMTXController sets the MediaMTX controller (for testing purposes)
func (s *WebSocketServer) SetMediaMTXController(controller mediamtx.MediaMTXController) <span class="cov0" title="0">{
        s.mediaMTXController = controller
}</span>

// GetEventManager returns the event manager for external integration
func (s *WebSocketServer) GetEventManager() *EventManager <span class="cov0" title="0">{
        return s.eventManager
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
WebSocket JSON-RPC 2.0 types and structures.

Provides JSON-RPC 2.0 request, response, and notification structures
following the Python WebSocketJsonRpcServer patterns and project architecture standards.

Requirements Coverage:
- REQ-API-001: WebSocket JSON-RPC 2.0 API endpoint
- REQ-API-002: JSON-RPC 2.0 protocol implementation
- REQ-API-003: Request/response message handling

Test Categories: Unit/Integration
API Documentation Reference: docs/api/json_rpc_methods.md
*/

package websocket

import (
        "encoding/json"
        "time"

        "github.com/camerarecorder/mediamtx-camera-service-go/internal/constants"
        "github.com/gorilla/websocket"
)

// JSON-RPC Error Codes - Using common constants for consistency
const (
        // Standard JSON-RPC 2.0 Error Codes
        INVALID_REQUEST  = constants.JSONRPC_INVALID_REQUEST
        METHOD_NOT_FOUND = constants.JSONRPC_METHOD_NOT_FOUND
        INVALID_PARAMS   = constants.JSONRPC_INVALID_PARAMS
        INTERNAL_ERROR   = constants.JSONRPC_INTERNAL_ERROR

        // Service-Specific Error Codes (aligned with API documentation)
        AUTHENTICATION_REQUIRED = constants.API_AUTHENTICATION_REQUIRED
        PERMISSION_DENIED       = constants.API_PERMISSION_DENIED
        INVALID_STATE           = constants.API_INVALID_STATE
        UNSUPPORTED             = constants.API_UNSUPPORTED
        RATE_LIMIT_EXCEEDED     = constants.API_RATE_LIMIT_EXCEEDED
        DEPENDENCY_FAILED       = constants.API_DEPENDENCY_FAILED
        NOT_FOUND               = constants.API_NOT_FOUND

        // Additional error codes
        INSUFFICIENT_STORAGE     = -32007
        CAPABILITY_NOT_SUPPORTED = -32008

        // Legacy constants for backward compatibility (deprecated)
        INSUFFICIENT_PERMISSIONS = constants.API_INSUFFICIENT_PERMISSIONS
        CAMERA_NOT_FOUND         = constants.API_CAMERA_NOT_FOUND
        RECORDING_IN_PROGRESS    = constants.API_RECORDING_IN_PROGRESS
        MEDIAMTX_UNAVAILABLE     = constants.API_MEDIAMTX_UNAVAILABLE
        FILE_NOT_FOUND           = constants.API_FILE_NOT_FOUND

        // Enhanced Recording Management Error Codes
        ERROR_CAMERA_NOT_FOUND         = constants.ERROR_CAMERA_NOT_FOUND
        ERROR_CAMERA_NOT_AVAILABLE     = constants.ERROR_CAMERA_NOT_AVAILABLE
        ERROR_RECORDING_IN_PROGRESS    = constants.ERROR_RECORDING_IN_PROGRESS
        ERROR_MEDIAMTX_ERROR           = constants.ERROR_MEDIAMTX_ERROR
        ERROR_CAMERA_ALREADY_RECORDING = constants.ERROR_CAMERA_ALREADY_RECORDING
        ERROR_STORAGE_LOW              = constants.ERROR_STORAGE_LOW
        ERROR_STORAGE_CRITICAL         = constants.ERROR_STORAGE_CRITICAL
)

// ErrorMessages maps error codes to their corresponding messages
// Using common constants for consistency with API documentation
var ErrorMessages = constants.APIErrorMessages

// JsonRpcRequest represents a JSON-RPC 2.0 request structure
// Following Python JsonRpcRequest dataclass
type JsonRpcRequest struct {
        JSONRPC string                 `json:"jsonrpc"`
        Method  string                 `json:"method"`
        ID      interface{}            `json:"id,omitempty"`
        Params  map[string]interface{} `json:"params,omitempty"`
}

// JsonRpcResponse represents a JSON-RPC 2.0 response structure
// Following Python JsonRpcResponse dataclass
type JsonRpcResponse struct {
        JSONRPC  string                 `json:"jsonrpc"`
        ID       interface{}            `json:"id,omitempty"`
        Result   interface{}            `json:"result,omitempty"`
        Error    *JsonRpcError          `json:"error,omitempty"`
        Metadata map[string]interface{} `json:"metadata,omitempty"`
}

// JsonRpcNotification represents a JSON-RPC 2.0 notification structure
// Following Python JsonRpcNotification dataclass
type JsonRpcNotification struct {
        JSONRPC string                 `json:"jsonrpc"`
        Method  string                 `json:"method"`
        Params  map[string]interface{} `json:"params,omitempty"`
}

// JsonRpcError represents a JSON-RPC 2.0 error structure
type JsonRpcError struct {
        Code    int         `json:"code"`
        Message string      `json:"message"`
        Data    interface{} `json:"data,omitempty"`
}

// Error implements the error interface
func (e *JsonRpcError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// ErrorData standardizes JSON-RPC error data payloads
type ErrorData struct {
        Reason     string `json:"reason,omitempty"`
        Details    string `json:"details,omitempty"`
        Suggestion string `json:"suggestion,omitempty"`
}

// NewJsonRpcError creates a standardized JSON-RPC error
func NewJsonRpcError(code int, reason, details, suggestion string) *JsonRpcError <span class="cov0" title="0">{
        return &amp;JsonRpcError{
                Code:    code,
                Message: ErrorMessages[code],
                Data: &amp;ErrorData{
                        Reason:     reason,
                        Details:    details,
                        Suggestion: suggestion,
                },
        }
}</span>

// ClientConnection represents a connected WebSocket client
// Following Python ClientConnection class
type ClientConnection struct {
        ClientID      string
        Authenticated bool
        UserID        string
        Role          string
        AuthMethod    string
        ConnectedAt   time.Time
        Subscriptions map[string]bool
        Conn          *websocket.Conn `json:"-"` // WebSocket connection for sending messages
}

// PerformanceMetrics tracks WebSocket server performance
// Following Python PerformanceMetrics class
// Note: RequestCount, ErrorCount, and ActiveConnections use atomic operations for thread safety
type PerformanceMetrics struct {
        RequestCount      int64
        ResponseTimes     map[string][]float64
        ErrorCount        int64
        ActiveConnections int64
        StartTime         time.Time
}

// MethodHandler defines the signature for JSON-RPC method handlers
type MethodHandler func(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error)

// WebSocketMessage represents a WebSocket message with metadata
type WebSocketMessage struct {
        Type      string          `json:"type"`
        Data      json.RawMessage `json:"data"`
        Timestamp time.Time       `json:"timestamp"`
        ClientID  string          `json:"client_id,omitempty"`
}

// ServerConfig contains WebSocket server configuration
// Following Python server configuration patterns
type ServerConfig struct {
        Host                 string        `mapstructure:"host"`
        Port                 int           `mapstructure:"port"`
        WebSocketPath        string        `mapstructure:"websocket_path"`
        MaxConnections       int           `mapstructure:"max_connections"`
        ReadTimeout          time.Duration `mapstructure:"read_timeout"`
        WriteTimeout         time.Duration `mapstructure:"write_timeout"`
        PingInterval         time.Duration `mapstructure:"ping_interval"`
        PongWait             time.Duration `mapstructure:"pong_wait"`
        MaxMessageSize       int64         `mapstructure:"max_message_size"`
        ReadBufferSize       int           `mapstructure:"read_buffer_size"`
        WriteBufferSize      int           `mapstructure:"write_buffer_size"`
        ShutdownTimeout      time.Duration `mapstructure:"shutdown_timeout"`       // Default: 30 seconds
        ClientCleanupTimeout time.Duration `mapstructure:"client_cleanup_timeout"` // Default: 10 seconds
        AutoCloseAfter       time.Duration `mapstructure:"auto_close_after"`       // Default: 0 (never auto-close)
}

// DefaultServerConfig returns default WebSocket server configuration
// Optimized for Epic E3 performance requirements: &lt;50ms response time, 1000+ connections
func DefaultServerConfig() *ServerConfig <span class="cov0" title="0">{
        return &amp;ServerConfig{
                Host:                 constants.WEBSOCKET_DEFAULT_HOST,
                Port:                 constants.WEBSOCKET_DEFAULT_PORT,
                WebSocketPath:        constants.WEBSOCKET_DEFAULT_PATH,
                MaxConnections:       constants.WEBSOCKET_MAX_CONNECTIONS_PRODUCTION,
                ReadTimeout:          constants.WEBSOCKET_READ_TIMEOUT,
                WriteTimeout:         constants.WEBSOCKET_WRITE_TIMEOUT,
                PingInterval:         constants.WEBSOCKET_PING_INTERVAL,
                PongWait:             constants.WEBSOCKET_PONG_WAIT,
                MaxMessageSize:       constants.WEBSOCKET_MAX_MESSAGE_SIZE,
                ReadBufferSize:       constants.WEBSOCKET_READ_BUFFER_SIZE,
                WriteBufferSize:      constants.WEBSOCKET_WRITE_BUFFER_SIZE,
                ShutdownTimeout:      constants.WEBSOCKET_SHUTDOWN_TIMEOUT,
                ClientCleanupTimeout: constants.WEBSOCKET_CLIENT_CLEANUP_TIMEOUT,
                AutoCloseAfter:       0, // Default: never auto-close
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package websocket

import (
        "strconv"

        "github.com/camerarecorder/mediamtx-camera-service-go/internal/logging"
        "github.com/camerarecorder/mediamtx-camera-service-go/internal/security"
)

// ValidationHelper provides centralized validation for JSON-RPC method parameters
type ValidationHelper struct {
        inputValidator *security.InputValidator
        logger         *logging.Logger
}

// NewValidationHelper creates a new validation helper
func NewValidationHelper(inputValidator *security.InputValidator, logger *logging.Logger) *ValidationHelper <span class="cov8" title="1">{
        return &amp;ValidationHelper{
                inputValidator: inputValidator,
                logger:         logger,
        }
}</span>

// ValidationResult contains validation results with error details
type ValidationResult struct {
        Valid    bool
        Errors   []string
        Warnings []string
        Data     map[string]interface{}
}

// NewValidationResult creates a new validation result
func NewValidationResult() *ValidationResult <span class="cov8" title="1">{
        return &amp;ValidationResult{
                Valid:    true,
                Errors:   make([]string, 0),
                Warnings: make([]string, 0),
                Data:     make(map[string]interface{}),
        }
}</span>

// AddError adds a validation error
func (vr *ValidationResult) AddError(message string) <span class="cov0" title="0">{
        vr.Valid = false
        vr.Errors = append(vr.Errors, message)
}</span>

// AddWarning adds a validation warning
func (vr *ValidationResult) AddWarning(message string) <span class="cov0" title="0">{
        vr.Warnings = append(vr.Warnings, message)
}</span>

// AddData adds data to the validation result
func (vr *ValidationResult) AddData(key string, value interface{}) <span class="cov8" title="1">{
        vr.Data[key] = value
}</span>

// GetFirstError returns the first error message or empty string
func (vr *ValidationResult) GetFirstError() string <span class="cov0" title="0">{
        if len(vr.Errors) &gt; 0 </span><span class="cov0" title="0">{
                return vr.Errors[0]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// ValidatePaginationParams validates limit and offset parameters
func (vh *ValidationHelper) ValidatePaginationParams(params map[string]interface{}) *ValidationResult <span class="cov0" title="0">{
        result := NewValidationResult()

        if params == nil </span><span class="cov0" title="0">{
                // Use defaults for nil params
                result.AddData("limit", 100)
                result.AddData("offset", 0)
                return result
        }</span>

        // Validate limit
        <span class="cov0" title="0">limit := 100 // Default
        if limitVal, exists := params["limit"]; exists </span><span class="cov0" title="0">{
                if limitResult := vh.inputValidator.ValidateLimit(limitVal); limitResult.HasErrors() </span><span class="cov0" title="0">{
                        result.AddError(limitResult.GetErrorMessages()[0])
                        return result
                }</span>
                // Extract validated limit
                <span class="cov0" title="0">switch v := limitVal.(type) </span>{
                case int:<span class="cov0" title="0">
                        limit = v</span>
                case float64:<span class="cov0" title="0">
                        limit = int(v)</span>
                case string:<span class="cov0" title="0">
                        if limitInt, err := strconv.Atoi(v); err == nil </span><span class="cov0" title="0">{
                                limit = limitInt
                        }</span>
                }
        }

        // Validate offset
        <span class="cov0" title="0">offset := 0 // Default
        if offsetVal, exists := params["offset"]; exists </span><span class="cov0" title="0">{
                if offsetResult := vh.inputValidator.ValidateOffset(offsetVal); offsetResult.HasErrors() </span><span class="cov0" title="0">{
                        result.AddError(offsetResult.GetErrorMessages()[0])
                        return result
                }</span>
                // Extract validated offset
                <span class="cov0" title="0">switch v := offsetVal.(type) </span>{
                case int:<span class="cov0" title="0">
                        offset = v</span>
                case float64:<span class="cov0" title="0">
                        offset = int(v)</span>
                case string:<span class="cov0" title="0">
                        if offsetInt, err := strconv.Atoi(v); err == nil </span><span class="cov0" title="0">{
                                offset = offsetInt
                        }</span>
                }
        }

        <span class="cov0" title="0">result.AddData("limit", limit)
        result.AddData("offset", offset)
        return result</span>
}

// ValidateDeviceParameter validates the device parameter
func (vh *ValidationHelper) ValidateDeviceParameter(params map[string]interface{}) *ValidationResult <span class="cov8" title="1">{
        result := NewValidationResult()

        if params == nil </span><span class="cov0" title="0">{
                result.AddError("device parameter is required")
                return result
        }</span>

        <span class="cov8" title="1">deviceVal, exists := params["device"]
        if !exists </span><span class="cov0" title="0">{
                result.AddError("device parameter is required")
                return result
        }</span>

        <span class="cov8" title="1">if deviceResult := vh.inputValidator.ValidateDevicePath(deviceVal); deviceResult.HasErrors() </span><span class="cov0" title="0">{
                result.AddError(deviceResult.GetErrorMessages()[0])
                return result
        }</span>

        // Extract validated device path
        <span class="cov8" title="1">devicePath, ok := deviceVal.(string)
        if !ok </span><span class="cov0" title="0">{
                result.AddError("device parameter must be a string")
                return result
        }</span>

        <span class="cov8" title="1">result.AddData("device", devicePath)
        return result</span>
}

// ValidateFilenameParameter validates the filename parameter
func (vh *ValidationHelper) ValidateFilenameParameter(params map[string]interface{}) *ValidationResult <span class="cov0" title="0">{
        result := NewValidationResult()

        if params == nil </span><span class="cov0" title="0">{
                result.AddError("filename parameter is required")
                return result
        }</span>

        <span class="cov0" title="0">filenameVal, exists := params["filename"]
        if !exists </span><span class="cov0" title="0">{
                result.AddError("filename parameter is required")
                return result
        }</span>

        <span class="cov0" title="0">if filenameResult := vh.inputValidator.ValidateFilename(filenameVal); filenameResult.HasErrors() </span><span class="cov0" title="0">{
                result.AddError(filenameResult.GetErrorMessages()[0])
                return result
        }</span>

        // Extract validated filename
        <span class="cov0" title="0">filename, ok := filenameVal.(string)
        if !ok </span><span class="cov0" title="0">{
                result.AddError("filename parameter must be a string")
                return result
        }</span>

        <span class="cov0" title="0">result.AddData("filename", filename)
        return result</span>
}

// ValidateRecordingParameters validates recording-specific parameters
func (vh *ValidationHelper) ValidateRecordingParameters(params map[string]interface{}) *ValidationResult <span class="cov0" title="0">{
        result := NewValidationResult()

        if params == nil </span><span class="cov0" title="0">{
                result.AddError("parameters are required")
                return result
        }</span>

        // Validate device parameter first
        <span class="cov0" title="0">deviceResult := vh.ValidateDeviceParameter(params)
        if !deviceResult.Valid </span><span class="cov0" title="0">{
                result.AddError(deviceResult.GetFirstError())
                return result
        }</span>
        <span class="cov0" title="0">result.AddData("device", deviceResult.Data["device"])

        // Validate optional parameters
        options := make(map[string]interface{})

        // Duration validation (0 = unlimited recording)
        if duration, exists := params["duration"]; exists </span><span class="cov0" title="0">{
                if durationResult := vh.inputValidator.ValidateNonNegativeInteger(duration, "duration"); durationResult.HasErrors() </span><span class="cov0" title="0">{
                        result.AddError(durationResult.GetErrorMessages()[0])
                        return result
                }</span>
                // Extract validated duration
                <span class="cov0" title="0">switch v := duration.(type) </span>{
                case int:<span class="cov0" title="0">
                        options["max_duration"] = v</span>
                case float64:<span class="cov0" title="0">
                        options["max_duration"] = int(v)</span>
                case string:<span class="cov0" title="0">
                        if durationInt, err := strconv.Atoi(v); err == nil </span><span class="cov0" title="0">{
                                options["max_duration"] = durationInt
                        }</span>
                }
        }

        // Format validation
        <span class="cov0" title="0">if format, exists := params["format"]; exists </span><span class="cov0" title="0">{
                if formatResult := vh.inputValidator.ValidateOptionalString(format, "format"); formatResult.HasErrors() </span><span class="cov0" title="0">{
                        result.AddError(formatResult.GetErrorMessages()[0])
                        return result
                }</span>
                <span class="cov0" title="0">if formatStr, ok := format.(string); ok &amp;&amp; formatStr != "" </span><span class="cov0" title="0">{
                        options["output_format"] = formatStr
                }</span>
        }

        // Codec validation
        <span class="cov0" title="0">if codec, exists := params["codec"]; exists </span><span class="cov0" title="0">{
                if codecResult := vh.inputValidator.ValidateOptionalString(codec, "codec"); codecResult.HasErrors() </span><span class="cov0" title="0">{
                        result.AddError(codecResult.GetErrorMessages()[0])
                        return result
                }</span>
                <span class="cov0" title="0">if codecStr, ok := codec.(string); ok &amp;&amp; codecStr != "" </span><span class="cov0" title="0">{
                        options["codec"] = codecStr
                }</span>
        }

        // Quality validation
        <span class="cov0" title="0">if quality, exists := params["quality"]; exists </span><span class="cov0" title="0">{
                if qualityResult := vh.inputValidator.ValidatePositiveInteger(quality, "quality"); qualityResult.HasErrors() </span><span class="cov0" title="0">{
                        result.AddError(qualityResult.GetErrorMessages()[0])
                        return result
                }</span>
                // Extract validated quality
                <span class="cov0" title="0">switch v := quality.(type) </span>{
                case int:<span class="cov0" title="0">
                        options["crf"] = v</span>
                case float64:<span class="cov0" title="0">
                        options["crf"] = int(v)</span>
                case string:<span class="cov0" title="0">
                        if qualityInt, err := strconv.Atoi(v); err == nil </span><span class="cov0" title="0">{
                                options["crf"] = qualityInt
                        }</span>
                }
        }

        // Use case validation
        <span class="cov0" title="0">if useCase, exists := params["use_case"]; exists </span><span class="cov0" title="0">{
                if useCaseResult := vh.inputValidator.ValidateOptionalString(useCase, "use_case"); useCaseResult.HasErrors() </span><span class="cov0" title="0">{
                        result.AddError(useCaseResult.GetErrorMessages()[0])
                        return result
                }</span>
                <span class="cov0" title="0">if useCaseStr, ok := useCase.(string); ok &amp;&amp; useCaseStr != "" </span><span class="cov0" title="0">{
                        options["use_case"] = useCaseStr
                }</span>
        }

        // Priority validation
        <span class="cov0" title="0">if priority, exists := params["priority"]; exists </span><span class="cov0" title="0">{
                if priorityResult := vh.inputValidator.ValidatePositiveInteger(priority, "priority"); priorityResult.HasErrors() </span><span class="cov0" title="0">{
                        result.AddError(priorityResult.GetErrorMessages()[0])
                        return result
                }</span>
                // Extract validated priority
                <span class="cov0" title="0">switch v := priority.(type) </span>{
                case int:<span class="cov0" title="0">
                        options["priority"] = v</span>
                case float64:<span class="cov0" title="0">
                        options["priority"] = int(v)</span>
                case string:<span class="cov0" title="0">
                        if priorityInt, err := strconv.Atoi(v); err == nil </span><span class="cov0" title="0">{
                                options["priority"] = priorityInt
                        }</span>
                }
        }

        // Auto cleanup validation
        <span class="cov0" title="0">if autoCleanup, exists := params["auto_cleanup"]; exists </span><span class="cov0" title="0">{
                if autoCleanupResult := vh.inputValidator.ValidateBooleanParameter(autoCleanup, "auto_cleanup"); autoCleanupResult.HasErrors() </span><span class="cov0" title="0">{
                        result.AddError(autoCleanupResult.GetErrorMessages()[0])
                        return result
                }</span>
                // Extract validated auto cleanup
                <span class="cov0" title="0">switch v := autoCleanup.(type) </span>{
                case bool:<span class="cov0" title="0">
                        options["auto_cleanup"] = v</span>
                case int:<span class="cov0" title="0">
                        options["auto_cleanup"] = v == 1</span>
                case float64:<span class="cov0" title="0">
                        options["auto_cleanup"] = v == 1.0</span>
                case string:<span class="cov0" title="0">
                        options["auto_cleanup"] = v == "true"</span>
                }
        }

        // Retention days validation
        <span class="cov0" title="0">if retentionDays, exists := params["retention_days"]; exists </span><span class="cov0" title="0">{
                if retentionResult := vh.inputValidator.ValidatePositiveInteger(retentionDays, "retention_days"); retentionResult.HasErrors() </span><span class="cov0" title="0">{
                        result.AddError(retentionResult.GetErrorMessages()[0])
                        return result
                }</span>
                // Extract validated retention days
                <span class="cov0" title="0">switch v := retentionDays.(type) </span>{
                case int:<span class="cov0" title="0">
                        options["retention_days"] = v</span>
                case float64:<span class="cov0" title="0">
                        options["retention_days"] = int(v)</span>
                case string:<span class="cov0" title="0">
                        if retentionInt, err := strconv.Atoi(v); err == nil </span><span class="cov0" title="0">{
                                options["retention_days"] = retentionInt
                        }</span>
                }
        }

        <span class="cov0" title="0">result.AddData("options", options)
        return result</span>
}

// ValidateSnapshotParameters validates snapshot-specific parameters
func (vh *ValidationHelper) ValidateSnapshotParameters(params map[string]interface{}) *ValidationResult <span class="cov8" title="1">{
        result := NewValidationResult()

        if params == nil </span><span class="cov0" title="0">{
                result.AddError("parameters are required")
                return result
        }</span>

        // Validate device parameter first
        <span class="cov8" title="1">deviceResult := vh.ValidateDeviceParameter(params)
        if !deviceResult.Valid </span><span class="cov0" title="0">{
                result.AddError(deviceResult.GetFirstError())
                return result
        }</span>
        <span class="cov8" title="1">result.AddData("device", deviceResult.Data["device"])

        // Validate optional parameters
        options := make(map[string]interface{})

        // Filename validation
        if filename, exists := params["filename"]; exists </span><span class="cov8" title="1">{
                if filenameResult := vh.inputValidator.ValidateOptionalString(filename, "filename"); filenameResult.HasErrors() </span><span class="cov0" title="0">{
                        result.AddError(filenameResult.GetErrorMessages()[0])
                        return result
                }</span>
                <span class="cov8" title="1">if filenameStr, ok := filename.(string); ok &amp;&amp; filenameStr != "" </span><span class="cov8" title="1">{
                        options["filename"] = filenameStr
                }</span>
        }

        // Format validation
        <span class="cov8" title="1">if format, exists := params["format"]; exists </span><span class="cov0" title="0">{
                if formatResult := vh.inputValidator.ValidateOptionalString(format, "format"); formatResult.HasErrors() </span><span class="cov0" title="0">{
                        result.AddError(formatResult.GetErrorMessages()[0])
                        return result
                }</span>
                <span class="cov0" title="0">if formatStr, ok := format.(string); ok &amp;&amp; formatStr != "" </span><span class="cov0" title="0">{
                        options["format"] = formatStr
                }</span>
        }

        // Quality validation
        <span class="cov8" title="1">if quality, exists := params["quality"]; exists </span><span class="cov0" title="0">{
                if qualityResult := vh.inputValidator.ValidatePositiveInteger(quality, "quality"); qualityResult.HasErrors() </span><span class="cov0" title="0">{
                        result.AddError(qualityResult.GetErrorMessages()[0])
                        return result
                }</span>
                // Extract validated quality
                <span class="cov0" title="0">switch v := quality.(type) </span>{
                case int:<span class="cov0" title="0">
                        options["quality"] = v</span>
                case float64:<span class="cov0" title="0">
                        options["quality"] = int(v)</span>
                case string:<span class="cov0" title="0">
                        if qualityInt, err := strconv.Atoi(v); err == nil </span><span class="cov0" title="0">{
                                options["quality"] = qualityInt
                        }</span>
                }
        }

        <span class="cov8" title="1">result.AddData("options", options)
        return result</span>
}

// ValidateRetentionPolicyParameters validates retention policy parameters
func (vh *ValidationHelper) ValidateRetentionPolicyParameters(params map[string]interface{}) *ValidationResult <span class="cov0" title="0">{
        result := NewValidationResult()

        if params == nil </span><span class="cov0" title="0">{
                result.AddError("parameters are required")
                return result
        }</span>

        // Validate policy type
        <span class="cov0" title="0">policyTypeVal, exists := params["policy_type"]
        if !exists </span><span class="cov0" title="0">{
                result.AddError("policy_type parameter is required")
                return result
        }</span>

        <span class="cov0" title="0">policyType, ok := policyTypeVal.(string)
        if !ok </span><span class="cov0" title="0">{
                result.AddError("policy_type parameter must be a string")
                return result
        }</span>

        <span class="cov0" title="0">if policyType != "age" &amp;&amp; policyType != "size" </span><span class="cov0" title="0">{
                result.AddError("policy_type must be either 'age' or 'size'")
                return result
        }</span>

        // Validate enabled flag
        <span class="cov0" title="0">enabledVal, exists := params["enabled"]
        if !exists </span><span class="cov0" title="0">{
                result.AddError("enabled parameter is required")
                return result
        }</span>

        <span class="cov0" title="0">var enabled bool
        switch v := enabledVal.(type) </span>{
        case bool:<span class="cov0" title="0">
                enabled = v</span>
        case int:<span class="cov0" title="0">
                enabled = v == 1</span>
        case float64:<span class="cov0" title="0">
                enabled = v == 1.0</span>
        case string:<span class="cov0" title="0">
                enabled = v == "true"</span>
        default:<span class="cov0" title="0">
                result.AddError("enabled parameter must be a boolean")
                return result</span>
        }

        // Validate policy-specific parameters
        <span class="cov0" title="0">switch policyType </span>{
        case "age":<span class="cov0" title="0">
                if maxAgeDays, exists := params["max_age_days"]; exists </span><span class="cov0" title="0">{
                        if maxAgeResult := vh.inputValidator.ValidatePositiveInteger(maxAgeDays, "max_age_days"); maxAgeResult.HasErrors() </span><span class="cov0" title="0">{
                                result.AddError(maxAgeResult.GetErrorMessages()[0])
                                return result
                        }</span>
                }
        case "size":<span class="cov0" title="0">
                if maxSizeGB, exists := params["max_size_gb"]; exists </span><span class="cov0" title="0">{
                        if maxSizeResult := vh.inputValidator.ValidatePositiveInteger(maxSizeGB, "max_size_gb"); maxSizeResult.HasErrors() </span><span class="cov0" title="0">{
                                result.AddError(maxSizeResult.GetErrorMessages()[0])
                                return result
                        }</span>
                }
        }

        <span class="cov0" title="0">result.AddData("policy_type", policyType)
        result.AddData("enabled", enabled)
        return result</span>
}

// CreateValidationErrorResponse creates a JSON-RPC error response from validation results
func (vh *ValidationHelper) CreateValidationErrorResponse(validationResult *ValidationResult) *JsonRpcResponse <span class="cov0" title="0">{
        reason := "validation_failed"
        details := ""
        if len(validationResult.Errors) &gt; 0 </span><span class="cov0" title="0">{
                details = validationResult.Errors[0]
        }</span>

        <span class="cov0" title="0">return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Error:   NewJsonRpcError(INVALID_PARAMS, reason, details, "Check parameter types and values"),
        }</span>
}

// LogValidationWarnings logs validation warnings for debugging
func (vh *ValidationHelper) LogValidationWarnings(validationResult *ValidationResult, method string, clientID string) <span class="cov0" title="0">{
        if len(validationResult.Warnings) &gt; 0 </span><span class="cov0" title="0">{
                vh.logger.WithFields(logging.Fields{
                        "client_id": clientID,
                        "method":    method,
                        "warnings":  validationResult.Warnings,
                }).Warn("Validation warnings during parameter processing")
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
