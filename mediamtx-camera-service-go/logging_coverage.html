
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>logging: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/camerarecorder/mediamtx-camera-service-go/internal/logging/logger.go (26.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package logging

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "sync"

        "github.com/google/uuid"
        "github.com/sirupsen/logrus"
        "gopkg.in/natefinch/lumberjack.v2"

        "github.com/camerarecorder/mediamtx-camera-service-go/internal/config"
)

// Logger represents the main logging interface with correlation ID support.
// It wraps logrus.Logger and adds correlation ID tracking and component identification.
type Logger struct {
        *logrus.Logger
        correlationID string
        component     string
        mu            sync.RWMutex
}

// LoggingConfig represents logging configuration settings.
// It mirrors the configuration structure from the main config system.
type LoggingConfig struct {
        Level          string `mapstructure:"level"`           // Log level (debug, info, warn, error, fatal)
        Format         string `mapstructure:"format"`          // Output format (text, json)
        FileEnabled    bool   `mapstructure:"file_enabled"`    // Enable file logging
        FilePath       string `mapstructure:"file_path"`       // Log file path
        MaxFileSize    int    `mapstructure:"max_file_size"`   // Maximum file size in MB
        BackupCount    int    `mapstructure:"backup_count"`    // Number of backup files to keep
        ConsoleEnabled bool   `mapstructure:"console_enabled"` // Enable console logging
}

// NewLoggingConfigFromConfig creates a LoggingConfig from config.LoggingConfig.
// This function provides integration between the logging system and the main configuration system.
func NewLoggingConfigFromConfig(cfg *config.LoggingConfig) *LoggingConfig <span class="cov0" title="0">{
        return &amp;LoggingConfig{
                Level:          cfg.Level,
                Format:         cfg.Format,
                FileEnabled:    cfg.FileEnabled,
                FilePath:       cfg.FilePath,
                MaxFileSize:    int(cfg.MaxFileSize),
                BackupCount:    cfg.BackupCount,
                ConsoleEnabled: cfg.ConsoleEnabled,
        }
}</span>

// CorrelationIDKey is the context key for correlation IDs.
// Used for storing and retrieving correlation IDs from context.Context.
const CorrelationIDKey = "correlation_id"

// Global logger instance with thread-safe initialization
var (
        globalLogger *Logger
        once         sync.Once
)

// NewLogger creates a new logger instance for the specified component.
// The component name is used for identification in log messages.
func NewLogger(component string) *Logger <span class="cov8" title="1">{
        logger := &amp;Logger{
                Logger:    logrus.New(),
                component: component,
        }

        // Set default formatter with timestamp
        logger.SetFormatter(&amp;logrus.TextFormatter{
                FullTimestamp:   true,
                TimestampFormat: "2006-01-02 15:04:05",
        })

        return logger
}</span>

// GetLogger returns the global logger instance.
// Uses singleton pattern with thread-safe initialization.
func GetLogger() *Logger <span class="cov8" title="1">{
        once.Do(func() </span><span class="cov8" title="1">{
                globalLogger = NewLogger("camera-service")
        }</span>)
        <span class="cov8" title="1">return globalLogger</span>
}

// SetupLogging initializes the logging system with the given configuration.
// Configures log level, formatters, and output handlers based on the provided config.
func SetupLogging(config *LoggingConfig) error <span class="cov0" title="0">{
        logger := GetLogger()

        // Parse and set log level
        level, err := logrus.ParseLevel(strings.ToLower(config.Level))
        if err != nil </span><span class="cov0" title="0">{
                level = logrus.InfoLevel // Fallback to info level
        }</span>
        <span class="cov0" title="0">logger.SetLevel(level)

        // Clear existing hooks to avoid duplication
        logger.ReplaceHooks(logrus.LevelHooks{})

        // Setup console handler if enabled
        if config.ConsoleEnabled </span><span class="cov0" title="0">{
                consoleHandler := logrus.New()
                consoleHandler.SetOutput(os.Stdout)
                consoleHandler.SetFormatter(createConsoleFormatter(config.Format))
                consoleHandler.SetLevel(level)

                // Add console handler to logger
                logger.SetOutput(consoleHandler.Out)
                logger.SetFormatter(consoleHandler.Formatter)
        }</span>

        // Setup file handler if enabled
        <span class="cov0" title="0">if config.FileEnabled &amp;&amp; config.FilePath != "" </span><span class="cov0" title="0">{
                if err := setupFileHandler(logger, config); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to setup file handler: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// setupFileHandler configures file-based logging with rotation.
// Creates log directory if it doesn't exist and sets up lumberjack for log rotation.
func setupFileHandler(logger *Logger, config *LoggingConfig) error <span class="cov0" title="0">{
        // Ensure log directory exists
        logDir := filepath.Dir(config.FilePath)
        if err := os.MkdirAll(logDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create log directory: %w", err)
        }</span>

        // Create rotating file handler
        <span class="cov0" title="0">fileHandler := &amp;lumberjack.Logger{
                Filename:   config.FilePath,
                MaxSize:    config.MaxFileSize / (1024 * 1024), // Convert to MB
                MaxBackups: config.BackupCount,
                MaxAge:     30, // Keep logs for 30 days
                Compress:   true,
        }

        // Create file formatter
        fileFormatter := createFileFormatter(config.Format)

        // Set file handler
        logger.SetOutput(fileHandler)
        logger.SetFormatter(fileFormatter)

        return nil</span>
}

// createConsoleFormatter creates a console-friendly formatter.
// Uses text format with colors and timestamps for console output.
func createConsoleFormatter(format string) logrus.Formatter <span class="cov0" title="0">{
        return &amp;logrus.TextFormatter{
                FullTimestamp:   true,
                TimestampFormat: "2006-01-02 15:04:05",
                DisableColors:   false,
                ForceColors:     true,
        }
}</span>

// createFileFormatter creates a file formatter (JSON for production, text for development).
// Automatically selects JSON format for production environment or when explicitly requested.
func createFileFormatter(format string) logrus.Formatter <span class="cov0" title="0">{
        // Check if we should use JSON format
        if strings.Contains(strings.ToLower(format), "json") ||
                os.Getenv("CAMERA_SERVICE_ENV") == "production" </span><span class="cov0" title="0">{
                return &amp;logrus.JSONFormatter{
                        TimestampFormat: "2006-01-02T15:04:05",
                }
        }</span>

        // Use text format for development
        <span class="cov0" title="0">return &amp;logrus.TextFormatter{
                FullTimestamp:   true,
                TimestampFormat: "2006-01-02 15:04:05",
                DisableColors:   true,
        }</span>
}

// WithCorrelationID creates a new logger with correlation ID.
// Thread-safe method that returns a new logger instance with the specified correlation ID.
func (l *Logger) WithCorrelationID(id string) *Logger <span class="cov8" title="1">{
        l.mu.Lock()
        defer l.mu.Unlock()

        newLogger := &amp;Logger{
                Logger:        l.Logger,
                correlationID: id,
                component:     l.component,
        }

        return newLogger
}</span>

// WithField adds a field to the logger.
// Returns a new logger instance with the specified key-value field added.
func (l *Logger) WithField(key, value string) *Logger <span class="cov8" title="1">{
        return &amp;Logger{
                Logger:        l.Logger.WithField(key, value).Logger,
                correlationID: l.correlationID,
                component:     l.component,
        }
}</span>

// WithError adds an error to the logger.
// Returns a new logger instance with the specified error added.
func (l *Logger) WithError(err error) *Logger <span class="cov8" title="1">{
        return &amp;Logger{
                Logger:        l.Logger.WithError(err).Logger,
                correlationID: l.correlationID,
                component:     l.component,
        }
}</span>

// LogWithContext logs a message with context information.
// Automatically adds correlation ID from context and component information to log entries.
func (l *Logger) LogWithContext(ctx context.Context, level logrus.Level, msg string) <span class="cov0" title="0">{
        entry := l.Logger.WithFields(logrus.Fields{
                "component": l.component,
        })

        // Add correlation ID if available
        if l.correlationID != "" </span><span class="cov0" title="0">{
                entry = entry.WithField("correlation_id", l.correlationID)
        }</span>

        // Add correlation ID from context if not already set
        <span class="cov0" title="0">if correlationID := GetCorrelationIDFromContext(ctx); correlationID != "" </span><span class="cov0" title="0">{
                entry = entry.WithField("correlation_id", correlationID)
        }</span>

        <span class="cov0" title="0">entry.Log(level, msg)</span>
}

// GenerateCorrelationID generates a new correlation ID.
// Returns a UUID v4 string for request tracing and correlation.
func GenerateCorrelationID() string <span class="cov8" title="1">{
        return uuid.New().String()
}</span>

// GetCorrelationIDFromContext extracts correlation ID from context.
// Returns empty string if no correlation ID is found in the context.
func GetCorrelationIDFromContext(ctx context.Context) string <span class="cov8" title="1">{
        if ctx == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">if correlationID, ok := ctx.Value(CorrelationIDKey).(string); ok </span><span class="cov8" title="1">{
                return correlationID
        }</span>

        <span class="cov8" title="1">return ""</span>
}

// WithCorrelationID adds correlation ID to context.
// Creates a new context with the specified correlation ID value.
func WithCorrelationID(ctx context.Context, id string) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, CorrelationIDKey, id)
}</span>

// LogWithCorrelationID logs a message with correlation ID from context.
// Convenience function that uses the global logger to log with context correlation ID.
func LogWithCorrelationID(ctx context.Context, level logrus.Level, msg string) <span class="cov0" title="0">{
        logger := GetLogger()
        logger.LogWithContext(ctx, level, msg)
}</span>

// SetLevel sets the log level for the logger.
// Controls which log messages are output based on their severity level.
func (l *Logger) SetLevel(level logrus.Level) <span class="cov0" title="0">{
        l.Logger.SetLevel(level)
}</span>

// SetComponentLevel sets the log level for a specific component.
// Currently uses a single logger instance; could be extended for component-specific loggers.
func (l *Logger) SetComponentLevel(component string, level logrus.Level) <span class="cov0" title="0">{
        // For now, we use a single logger instance
        // In a more complex implementation, we could maintain component-specific loggers
        l.SetLevel(level)
}</span>

// GetEffectiveLevel returns the effective log level.
// Returns the current log level for the specified component.
func (l *Logger) GetEffectiveLevel(component string) logrus.Level <span class="cov0" title="0">{
        return l.Logger.GetLevel()
}</span>

// IsLevelEnabled checks if a level is enabled.
// Returns true if the specified log level is enabled for output.
func (l *Logger) IsLevelEnabled(level logrus.Level) bool <span class="cov0" title="0">{
        return l.Logger.IsLevelEnabled(level)
}</span>

// DebugWithContext logs a debug message with context information.
func (l *Logger) DebugWithContext(ctx context.Context, msg string) <span class="cov0" title="0">{
        l.LogWithContext(ctx, logrus.DebugLevel, msg)
}</span>

func (l *Logger) InfoWithContext(ctx context.Context, msg string) <span class="cov0" title="0">{
        l.LogWithContext(ctx, logrus.InfoLevel, msg)
}</span>

func (l *Logger) WarnWithContext(ctx context.Context, msg string) <span class="cov0" title="0">{
        l.LogWithContext(ctx, logrus.WarnLevel, msg)
}</span>

func (l *Logger) ErrorWithContext(ctx context.Context, msg string) <span class="cov0" title="0">{
        l.LogWithContext(ctx, logrus.ErrorLevel, msg)
}</span>

func (l *Logger) FatalWithContext(ctx context.Context, msg string) <span class="cov0" title="0">{
        l.LogWithContext(ctx, logrus.FatalLevel, msg)
        os.Exit(1)
}</span>

// SetupLoggingSimple provides a simple logging setup.
// Creates a basic logging configuration with file and console output.
func SetupLoggingSimple(logPath string, level string) error <span class="cov0" title="0">{
        config := &amp;LoggingConfig{
                Level:          level,
                FileEnabled:    logPath != "",
                FilePath:       logPath,
                ConsoleEnabled: true,
                MaxFileSize:    10485760, // 10MB
                BackupCount:    5,
        }

        return SetupLogging(config)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
