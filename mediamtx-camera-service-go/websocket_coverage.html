
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>websocket: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/camerarecorder/mediamtx-camera-service-go/internal/websocket/event_integration.go (65.6%)</option>
				
				<option value="file1">github.com/camerarecorder/mediamtx-camera-service-go/internal/websocket/events.go (96.5%)</option>
				
				<option value="file2">github.com/camerarecorder/mediamtx-camera-service-go/internal/websocket/methods.go (15.6%)</option>
				
				<option value="file3">github.com/camerarecorder/mediamtx-camera-service-go/internal/websocket/server.go (64.4%)</option>
				
				<option value="file4">github.com/camerarecorder/mediamtx-camera-service-go/internal/websocket/test_helpers.go (72.3%)</option>
				
				<option value="file5">github.com/camerarecorder/mediamtx-camera-service-go/internal/websocket/types.go (100.0%)</option>
				
				<option value="file6">github.com/camerarecorder/mediamtx-camera-service-go/internal/websocket/validation_helper.go (73.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Event System Integration Layer

Connects camera monitor and other components to the WebSocket event system,
implementing the EventNotifier interface for seamless event propagation.

Requirements Coverage:
- REQ-API-001: Efficient event delivery
- REQ-API-002: Component integration
- REQ-API-003: Event routing

Test Categories: Unit/Integration
API Documentation Reference: docs/api/json_rpc_methods.md
*/

package websocket

import (
        "time"

        "github.com/camerarecorder/mediamtx-camera-service-go/internal/camera"
        "github.com/camerarecorder/mediamtx-camera-service-go/internal/logging"
)

// EventIntegration connects camera monitor and other components to the event system
type EventIntegration struct {
        eventManager *EventManager
        logger       *logging.Logger
}

// NewEventIntegration creates a new event integration layer
func NewEventIntegration(eventManager *EventManager, logger *logging.Logger) *EventIntegration <span class="cov8" title="1">{
        return &amp;EventIntegration{
                eventManager: eventManager,
                logger:       logger,
        }
}</span>

// CameraEventNotifier implements the camera.EventNotifier interface
type CameraEventNotifier struct {
        eventManager *EventManager
        logger       *logging.Logger
}

// NewCameraEventNotifier creates a new camera event notifier
func NewCameraEventNotifier(eventManager *EventManager, logger *logging.Logger) *CameraEventNotifier <span class="cov8" title="1">{
        return &amp;CameraEventNotifier{
                eventManager: eventManager,
                logger:       logger,
        }
}</span>

// NotifyCameraConnected notifies when a camera is connected
func (n *CameraEventNotifier) NotifyCameraConnected(device *camera.CameraDevice) <span class="cov8" title="1">{
        // Check for nil device to prevent panic
        if device == nil </span><span class="cov8" title="1">{
                n.logger.Error("Cannot notify camera connected: device is nil")
                return
        }</span>

        <span class="cov0" title="0">eventData := logging.Fields{
                "device":    device.Path,
                "name":      device.Name,
                "status":    string(device.Status),
                "driver":    device.Capabilities.DriverName,
                "card_name": device.Capabilities.CardName,
                "timestamp": time.Now().Format(time.RFC3339),
        }

        if err := n.eventManager.PublishEvent(TopicCameraConnected, eventData); err != nil </span><span class="cov0" title="0">{
                n.logger.WithError(err).WithField("device", device.Path).Error("Failed to publish camera connected event")
        }</span> else<span class="cov0" title="0"> {
                n.logger.WithFields(logging.Fields{
                        "device": device.Path,
                        "name":   device.Name,
                        "topic":  TopicCameraConnected,
                }).Debug("Published camera connected event")
        }</span>
}

// NotifyCameraDisconnected notifies when a camera is disconnected
func (n *CameraEventNotifier) NotifyCameraDisconnected(devicePath string) <span class="cov8" title="1">{
        eventData := logging.Fields{
                "device":    devicePath,
                "status":    "disconnected",
                "timestamp": time.Now().Format(time.RFC3339),
        }

        if err := n.eventManager.PublishEvent(TopicCameraDisconnected, eventData); err != nil </span><span class="cov0" title="0">{
                n.logger.WithError(err).WithField("device", devicePath).Error("Failed to publish camera disconnected event")
        }</span> else<span class="cov8" title="1"> {
                n.logger.WithFields(logging.Fields{
                        "device": devicePath,
                        "topic":  TopicCameraDisconnected,
                }).Debug("Published camera disconnected event")
        }</span>
}

// NotifyCameraStatusChange notifies when camera status changes
func (n *CameraEventNotifier) NotifyCameraStatusChange(device *camera.CameraDevice, oldStatus, newStatus camera.DeviceStatus) <span class="cov8" title="1">{
        // Check for nil device to prevent panic
        if device == nil </span><span class="cov8" title="1">{
                n.logger.Error("Cannot notify camera status change: device is nil")
                return
        }</span>

        <span class="cov0" title="0">eventData := logging.Fields{
                "device":     device.Path,
                "name":       device.Name,
                "old_status": string(oldStatus),
                "new_status": string(newStatus),
                "timestamp":  time.Now().Format(time.RFC3339),
        }

        if err := n.eventManager.PublishEvent(TopicCameraStatusChange, eventData); err != nil </span><span class="cov0" title="0">{
                n.logger.WithError(err).WithField("device", device.Path).Error("Failed to publish camera status change event")
        }</span> else<span class="cov0" title="0"> {
                n.logger.WithFields(logging.Fields{
                        "device":     device.Path,
                        "old_status": oldStatus,
                        "new_status": newStatus,
                        "topic":      TopicCameraStatusChange,
                }).Debug("Published camera status change event")
        }</span>
}

// NotifyCapabilityDetected notifies when camera capabilities are detected
func (n *CameraEventNotifier) NotifyCapabilityDetected(device *camera.CameraDevice, capabilities camera.V4L2Capabilities) <span class="cov8" title="1">{
        // Check for nil device to prevent panic
        if device == nil </span><span class="cov8" title="1">{
                n.logger.Error("Cannot notify capability detected: device is nil")
                return
        }</span>

        <span class="cov0" title="0">eventData := logging.Fields{
                "device":       device.Path,
                "name":         device.Name,
                "driver":       capabilities.DriverName,
                "card_name":    capabilities.CardName,
                "bus_info":     capabilities.BusInfo,
                "capabilities": capabilities.Capabilities,
                "timestamp":    time.Now().Format(time.RFC3339),
        }

        if err := n.eventManager.PublishEvent(TopicCameraCapabilityDetected, eventData); err != nil </span><span class="cov0" title="0">{
                n.logger.WithError(err).WithField("device", device.Path).Error("Failed to publish capability detected event")
        }</span> else<span class="cov0" title="0"> {
                n.logger.WithFields(logging.Fields{
                        "device": device.Path,
                        "driver": capabilities.DriverName,
                        "topic":  TopicCameraCapabilityDetected,
                }).Debug("Published capability detected event")
        }</span>
}

// NotifyCapabilityError notifies when camera capability detection fails
func (n *CameraEventNotifier) NotifyCapabilityError(devicePath string, errorMsg string) <span class="cov8" title="1">{
        eventData := logging.Fields{
                "device":    devicePath,
                "error":     errorMsg,
                "timestamp": time.Now().Format(time.RFC3339),
        }

        if err := n.eventManager.PublishEvent(TopicCameraCapabilityError, eventData); err != nil </span><span class="cov0" title="0">{
                n.logger.WithError(err).WithField("device", devicePath).Error("Failed to publish capability error event")
        }</span> else<span class="cov8" title="1"> {
                n.logger.WithFields(logging.Fields{
                        "device": devicePath,
                        "error":  errorMsg,
                        "topic":  TopicCameraCapabilityError,
                }).Debug("Published capability error event")
        }</span>
}

// MediaMTXEventNotifier implements MediaMTX event notifications
type MediaMTXEventNotifier struct {
        eventManager *EventManager
        logger       *logging.Logger
}

// NewMediaMTXEventNotifier creates a new MediaMTX event notifier
func NewMediaMTXEventNotifier(eventManager *EventManager, logger *logging.Logger) *MediaMTXEventNotifier <span class="cov8" title="1">{
        return &amp;MediaMTXEventNotifier{
                eventManager: eventManager,
                logger:       logger,
        }
}</span>

// NotifyRecordingStarted notifies when MediaMTX recording starts
func (n *MediaMTXEventNotifier) NotifyRecordingStarted(device, sessionID, filename string) <span class="cov8" title="1">{
        eventData := logging.Fields{
                "device":     device,
                "session_id": sessionID,
                "filename":   filename,
                "timestamp":  time.Now().Format(time.RFC3339),
        }

        if err := n.eventManager.PublishEvent(TopicMediaMTXRecordingStarted, eventData); err != nil </span><span class="cov0" title="0">{
                n.logger.WithError(err).WithField("device", device).Error("Failed to publish recording started event")
        }</span> else<span class="cov8" title="1"> {
                n.logger.WithFields(logging.Fields{
                        "device":     device,
                        "session_id": sessionID,
                        "filename":   filename,
                        "topic":      TopicMediaMTXRecordingStarted,
                }).Debug("Published recording started event")
        }</span>
}

// NotifyRecordingStopped notifies when MediaMTX recording stops
func (n *MediaMTXEventNotifier) NotifyRecordingStopped(device, sessionID, filename string, duration time.Duration) <span class="cov8" title="1">{
        eventData := logging.Fields{
                "device":     device,
                "session_id": sessionID,
                "filename":   filename,
                "duration":   duration.Seconds(),
                "timestamp":  time.Now().Format(time.RFC3339),
        }

        if err := n.eventManager.PublishEvent(TopicMediaMTXRecordingStopped, eventData); err != nil </span><span class="cov0" title="0">{
                n.logger.WithError(err).WithField("device", device).Error("Failed to publish recording stopped event")
        }</span> else<span class="cov8" title="1"> {
                n.logger.WithFields(logging.Fields{
                        "device":     device,
                        "session_id": sessionID,
                        "filename":   filename,
                        "duration":   duration,
                        "topic":      TopicMediaMTXRecordingStopped,
                }).Debug("Published recording stopped event")
        }</span>
}

// NotifyStreamStarted notifies when MediaMTX stream starts
func (n *MediaMTXEventNotifier) NotifyStreamStarted(device, streamID, streamType string) <span class="cov8" title="1">{
        eventData := logging.Fields{
                "device":      device,
                "stream_id":   streamID,
                "stream_type": streamType,
                "timestamp":   time.Now().Format(time.RFC3339),
        }

        if err := n.eventManager.PublishEvent(TopicMediaMTXStreamStarted, eventData); err != nil </span><span class="cov0" title="0">{
                n.logger.WithError(err).WithField("device", device).Error("Failed to publish stream started event")
        }</span> else<span class="cov8" title="1"> {
                n.logger.WithFields(logging.Fields{
                        "device":      device,
                        "stream_id":   streamID,
                        "stream_type": streamType,
                        "topic":       TopicMediaMTXStreamStarted,
                }).Debug("Published stream started event")
        }</span>
}

// NotifyStreamStopped notifies when MediaMTX stream stops
func (n *MediaMTXEventNotifier) NotifyStreamStopped(device, streamID, streamType string) <span class="cov8" title="1">{
        eventData := logging.Fields{
                "device":      device,
                "stream_id":   streamID,
                "stream_type": streamType,
                "timestamp":   time.Now().Format(time.RFC3339),
        }

        if err := n.eventManager.PublishEvent(TopicMediaMTXStreamStopped, eventData); err != nil </span><span class="cov0" title="0">{
                n.logger.WithError(err).WithField("device", device).Error("Failed to publish stream stopped event")
        }</span> else<span class="cov8" title="1"> {
                n.logger.WithFields(logging.Fields{
                        "device":      device,
                        "stream_id":   streamID,
                        "stream_type": streamType,
                        "topic":       TopicMediaMTXStreamStopped,
                }).Debug("Published stream stopped event")
        }</span>
}

// SystemEventNotifier implements system-level event notifications
type SystemEventNotifier struct {
        eventManager *EventManager
        logger       *logging.Logger
}

// NewSystemEventNotifier creates a new system event notifier
func NewSystemEventNotifier(eventManager *EventManager, logger *logging.Logger) *SystemEventNotifier <span class="cov8" title="1">{
        return &amp;SystemEventNotifier{
                eventManager: eventManager,
                logger:       logger,
        }
}</span>

// NotifySystemStartup notifies when the system starts up
func (n *SystemEventNotifier) NotifySystemStartup(version, buildInfo string) <span class="cov8" title="1">{
        eventData := logging.Fields{
                "version":    version,
                "build_info": buildInfo,
                "timestamp":  time.Now().Format(time.RFC3339),
        }

        if err := n.eventManager.PublishEvent(TopicSystemStartup, eventData); err != nil </span><span class="cov0" title="0">{
                n.logger.WithError(err).Error("Failed to publish system startup event")
        }</span> else<span class="cov8" title="1"> {
                n.logger.WithFields(logging.Fields{
                        "version": version,
                        "topic":   TopicSystemStartup,
                }).Info("Published system startup event")
        }</span>
}

// NotifySystemShutdown notifies when the system shuts down
func (n *SystemEventNotifier) NotifySystemShutdown(reason string) <span class="cov8" title="1">{
        eventData := logging.Fields{
                "reason":    reason,
                "timestamp": time.Now().Format(time.RFC3339),
        }

        if err := n.eventManager.PublishEvent(TopicSystemShutdown, eventData); err != nil </span><span class="cov0" title="0">{
                n.logger.WithError(err).Error("Failed to publish system shutdown event")
        }</span> else<span class="cov8" title="1"> {
                n.logger.WithFields(logging.Fields{
                        "reason": reason,
                        "topic":  TopicSystemShutdown,
                }).Info("Published system shutdown event")
        }</span>
}

// NotifySystemHealth notifies about system health status
func (n *SystemEventNotifier) NotifySystemHealth(status string, metrics map[string]interface{}) <span class="cov8" title="1">{
        eventData := logging.Fields{
                "status":    status,
                "metrics":   metrics,
                "timestamp": time.Now().Format(time.RFC3339),
        }

        if err := n.eventManager.PublishEvent(TopicSystemHealth, eventData); err != nil </span><span class="cov0" title="0">{
                n.logger.WithError(err).Error("Failed to publish system health event")
        }</span> else<span class="cov8" title="1"> {
                n.logger.WithFields(logging.Fields{
                        "status": status,
                        "topic":  TopicSystemHealth,
                }).Debug("Published system health event")
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Event subscription system for WebSocket server.

Provides efficient, topic-based event delivery to subscribed clients,
replacing the inefficient broadcast-to-all approach.

Requirements Coverage:
- REQ-API-001: Efficient event delivery
- REQ-API-002: Client subscription management
- REQ-API-003: Topic-based filtering

Test Categories: Unit/Integration
API Documentation Reference: docs/api/json_rpc_methods.md
*/

package websocket

import (
        "fmt"
        "sync"
        "time"

        "github.com/camerarecorder/mediamtx-camera-service-go/internal/logging"
)

// EventTopic represents different types of events that clients can subscribe to
type EventTopic string

const (
        // Camera events
        TopicCameraConnected          EventTopic = "camera.connected"
        TopicCameraDisconnected       EventTopic = "camera.disconnected"
        TopicCameraStatusChange       EventTopic = "camera.status_change"
        TopicCameraCapabilityDetected EventTopic = "camera.capability_detected"
        TopicCameraCapabilityError    EventTopic = "camera.capability_error"

        // Recording events
        TopicRecordingStart    EventTopic = "recording.start"
        TopicRecordingStop     EventTopic = "recording.stop"
        TopicRecordingProgress EventTopic = "recording.progress"
        TopicRecordingError    EventTopic = "recording.error"

        // Snapshot events
        TopicSnapshotTaken EventTopic = "snapshot.taken"
        TopicSnapshotError EventTopic = "snapshot.error"

        // System events
        TopicSystemHealth   EventTopic = "system.health"
        TopicSystemError    EventTopic = "system.error"
        TopicSystemStartup  EventTopic = "system.startup"
        TopicSystemShutdown EventTopic = "system.shutdown"

        // MediaMTX events
        TopicMediaMTXStream           EventTopic = "mediamtx.stream"
        TopicMediaMTXPath             EventTopic = "mediamtx.path"
        TopicMediaMTXError            EventTopic = "mediamtx.error"
        TopicMediaMTXRecordingStarted EventTopic = "mediamtx.recording_started"
        TopicMediaMTXRecordingStopped EventTopic = "mediamtx.recording_stopped"
        TopicMediaMTXStreamStarted    EventTopic = "mediamtx.stream_started"
        TopicMediaMTXStreamStopped    EventTopic = "mediamtx.stream_stopped"
)

// EventSubscription represents a client's subscription to specific event topics
type EventSubscription struct {
        ClientID  string                 `json:"client_id"`
        Topics    []EventTopic           `json:"topics"`
        Filters   map[string]interface{} `json:"filters,omitempty"`
        CreatedAt time.Time              `json:"created_at"`
        LastSeen  time.Time              `json:"last_seen"`
        Active    bool                   `json:"active"`
}

// EventMessage represents a structured event message
type EventMessage struct {
        Topic     EventTopic             `json:"topic"`
        Data      map[string]interface{} `json:"data"`
        Timestamp time.Time              `json:"timestamp"`
        EventID   string                 `json:"event_id"`
}

// EventManager manages event subscriptions and delivery
type EventManager struct {
        // Subscriptions by client ID
        subscriptions map[string]*EventSubscription

        // Subscriptions by topic for efficient lookup
        topicSubscriptions map[EventTopic]map[string]*EventSubscription

        // Event handlers for custom processing
        eventHandlers map[EventTopic][]func(*EventMessage) error

        // Thread safety
        mu sync.RWMutex

        // Logging
        logger *logging.Logger
}

// NewEventManager creates a new event manager
func NewEventManager(logger *logging.Logger) *EventManager <span class="cov8" title="48">{
        return &amp;EventManager{
                subscriptions:      make(map[string]*EventSubscription),
                topicSubscriptions: make(map[EventTopic]map[string]*EventSubscription),
                eventHandlers:      make(map[EventTopic][]func(*EventMessage) error),
                logger:             logger,
        }
}</span>

// Subscribe adds a client subscription to specific event topics
func (em *EventManager) Subscribe(clientID string, topics []EventTopic, filters map[string]interface{}) error <span class="cov7" title="25">{
        em.mu.Lock()
        defer em.mu.Unlock()

        // Validate topics
        for _, topic := range topics </span><span class="cov7" title="29">{
                if !em.isValidTopic(topic) </span><span class="cov1" title="1">{
                        return fmt.Errorf("invalid event topic: %s", topic)
                }</span>
        }

        // Create or update subscription
        <span class="cov7" title="24">subscription := &amp;EventSubscription{
                ClientID:  clientID,
                Topics:    topics,
                Filters:   filters,
                CreatedAt: time.Now(),
                LastSeen:  time.Now(),
                Active:    true,
        }

        // Store subscription by client ID
        em.subscriptions[clientID] = subscription

        // Store subscription by topic for efficient lookup
        for _, topic := range topics </span><span class="cov7" title="28">{
                if em.topicSubscriptions[topic] == nil </span><span class="cov6" title="18">{
                        em.topicSubscriptions[topic] = make(map[string]*EventSubscription)
                }</span>
                <span class="cov7" title="28">em.topicSubscriptions[topic][clientID] = subscription</span>
        }

        <span class="cov7" title="24">em.logger.WithFields(logging.Fields{
                "client_id": clientID,
                "topics":    topics,
                "filters":   filters,
        }).Debug("Client subscribed to event topics")

        return nil</span>
}

// Unsubscribe removes a client's subscription to specific topics
func (em *EventManager) Unsubscribe(clientID string, topics []EventTopic) error <span class="cov5" title="8">{
        em.mu.Lock()
        defer em.mu.Unlock()

        _, exists := em.subscriptions[clientID]
        if !exists </span><span class="cov3" title="3">{
                // Client has no subscriptions - this is already the desired state
                em.logger.WithField("client_id", clientID).Debug("Client has no subscriptions to remove")
                return nil
        }</span>

        // Remove topics from subscription
        <span class="cov4" title="5">if len(topics) == 0 </span><span class="cov1" title="1">{
                // Remove all subscriptions for this client
                em.removeClientSubscriptions(clientID)
        }</span> else<span class="cov3" title="4"> {
                // Remove specific topics
                for _, topic := range topics </span><span class="cov4" title="5">{
                        em.removeTopicSubscription(clientID, topic)
                }</span>

                // Update subscription topics
                <span class="cov3" title="4">em.updateSubscriptionTopics(clientID, topics, true)</span>
        }

        <span class="cov4" title="5">em.logger.WithFields(logging.Fields{
                "client_id": clientID,
                "topics":    topics,
        }).Debug("Client unsubscribed from event topics")

        return nil</span>
}

// PublishEvent sends an event to all subscribed clients
func (em *EventManager) PublishEvent(topic EventTopic, data map[string]interface{}) error <span class="cov8" title="41">{
        em.mu.RLock()
        defer em.mu.RUnlock()

        // Create event message
        event := &amp;EventMessage{
                Topic:     topic,
                Data:      data,
                Timestamp: time.Now(),
                EventID:   generateEventID(),
        }

        // Process event through handlers
        if err := em.processEventHandlers(event); err != nil </span><span class="cov0" title="0">{
                em.logger.WithError(err).WithField("topic", string(topic)).Error("Event handler processing failed")
        }</span>

        // Get subscribers for this topic
        <span class="cov8" title="41">subscribers, exists := em.topicSubscriptions[topic]
        if !exists </span><span class="cov8" title="34">{
                em.logger.WithField("topic", string(topic)).Debug("No subscribers for event topic")
                return nil
        }</span>

        // Count interested subscribers
        <span class="cov4" title="7">subscriberCount := 0
        for _, subscription := range subscribers </span><span class="cov5" title="8">{
                if subscription.Active &amp;&amp; em.isClientInterested(subscription, event) </span><span class="cov2" title="2">{
                        subscriberCount++
                }</span>
        }

        <span class="cov4" title="7">em.logger.WithFields(logging.Fields{
                "topic":            topic,
                "subscriber_count": subscriberCount,
                "event_id":         event.EventID,
        }).Debug("Event published to subscribers")

        return nil</span>
}

// GetSubscribersForTopic returns all active subscribers for a specific topic
func (em *EventManager) GetSubscribersForTopic(topic EventTopic) []string <span class="cov7" title="19">{
        em.mu.RLock()
        defer em.mu.RUnlock()

        subscribers, exists := em.topicSubscriptions[topic]
        if !exists </span><span class="cov6" title="15">{
                return []string{}
        }</span>

        <span class="cov3" title="4">var clientIDs []string
        for clientID, subscription := range subscribers </span><span class="cov6" title="13">{
                if subscription.Active </span><span class="cov6" title="13">{
                        clientIDs = append(clientIDs, clientID)
                }</span>
        }

        <span class="cov3" title="4">return clientIDs</span>
}

// GetClientSubscriptions returns all topics a client is subscribed to
func (em *EventManager) GetClientSubscriptions(clientID string) []EventTopic <span class="cov3" title="3">{
        em.mu.RLock()
        defer em.mu.RUnlock()

        subscription, exists := em.subscriptions[clientID]
        if !exists </span><span class="cov2" title="2">{
                return []EventTopic{}
        }</span>

        <span class="cov1" title="1">return subscription.Topics</span>
}

// RemoveClient removes all subscriptions for a client
func (em *EventManager) RemoveClient(clientID string) <span class="cov8" title="36">{
        em.mu.Lock()
        defer em.mu.Unlock()

        em.removeClientSubscriptions(clientID)

        em.logger.WithField("client_id", clientID).Debug("Client removed from event manager")
}</span>

// AddEventHandler adds a custom event handler for a specific topic
func (em *EventManager) AddEventHandler(topic EventTopic, handler func(*EventMessage) error) <span class="cov4" title="7">{
        em.mu.Lock()
        defer em.mu.Unlock()

        em.eventHandlers[topic] = append(em.eventHandlers[topic], handler)
}</span>

// UpdateClientLastSeen updates the last seen timestamp for a client
func (em *EventManager) UpdateClientLastSeen(clientID string) <span class="cov1" title="1">{
        em.mu.Lock()
        defer em.mu.Unlock()

        if subscription, exists := em.subscriptions[clientID]; exists </span><span class="cov1" title="1">{
                subscription.LastSeen = time.Now()
        }</span>
}

// GetSubscriptionStats returns statistics about subscriptions
func (em *EventManager) GetSubscriptionStats() map[string]interface{} <span class="cov2" title="2">{
        em.mu.RLock()
        defer em.mu.RUnlock()

        stats := map[string]interface{}{
                "total_clients":        len(em.subscriptions),
                "total_topics":         len(em.topicSubscriptions),
                "active_subscriptions": 0,
                "topic_distribution":   make(map[string]int),
        }

        // Count active subscriptions and topic distribution
        for _, subscription := range em.subscriptions </span><span class="cov1" title="1">{
                if subscription.Active </span><span class="cov1" title="1">{
                        stats["active_subscriptions"] = stats["active_subscriptions"].(int) + 1
                }</span>
        }

        <span class="cov2" title="2">for topic, subscribers := range em.topicSubscriptions </span><span class="cov1" title="1">{
                stats["topic_distribution"].(map[string]int)[string(topic)] = len(subscribers)
        }</span>

        <span class="cov2" title="2">return stats</span>
}

// Helper methods

func (em *EventManager) isValidTopic(topic EventTopic) bool <span class="cov7" title="29">{
        validTopics := []EventTopic{
                TopicCameraConnected, TopicCameraDisconnected, TopicCameraStatusChange,
                TopicCameraCapabilityDetected, TopicCameraCapabilityError,
                TopicRecordingStart, TopicRecordingStop, TopicRecordingProgress, TopicRecordingError,
                TopicSnapshotTaken, TopicSnapshotError,
                TopicSystemHealth, TopicSystemError, TopicSystemStartup, TopicSystemShutdown,
                TopicMediaMTXStream, TopicMediaMTXPath, TopicMediaMTXError,
                TopicMediaMTXRecordingStarted, TopicMediaMTXRecordingStopped,
                TopicMediaMTXStreamStarted, TopicMediaMTXStreamStopped,
        }

        for _, valid := range validTopics </span><span class="cov10" title="81">{
                if topic == valid </span><span class="cov7" title="28">{
                        return true
                }</span>
        }
        <span class="cov1" title="1">return false</span>
}

func (em *EventManager) removeClientSubscriptions(clientID string) <span class="cov8" title="37">{
        subscription := em.subscriptions[clientID]
        if subscription == nil </span><span class="cov8" title="35">{
                return
        }</span>

        // Remove from topic subscriptions
        <span class="cov2" title="2">for _, topic := range subscription.Topics </span><span class="cov3" title="3">{
                em.removeTopicSubscription(clientID, topic)
        }</span>

        // Remove from client subscriptions
        <span class="cov2" title="2">delete(em.subscriptions, clientID)</span>
}

func (em *EventManager) removeTopicSubscription(clientID string, topic EventTopic) <span class="cov5" title="8">{
        if subscribers, exists := em.topicSubscriptions[topic]; exists </span><span class="cov4" title="6">{
                delete(subscribers, clientID)
                if len(subscribers) == 0 </span><span class="cov4" title="6">{
                        delete(em.topicSubscriptions, topic)
                }</span>
        }
}

func (em *EventManager) updateSubscriptionTopics(clientID string, topicsToRemove []EventTopic, remove bool) <span class="cov3" title="4">{
        subscription := em.subscriptions[clientID]
        if subscription == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Create a map for efficient lookup
        <span class="cov3" title="4">topicMap := make(map[EventTopic]bool)
        for _, topic := range subscription.Topics </span><span class="cov4" title="7">{
                topicMap[topic] = true
        }</span>

        // Remove or add topics
        <span class="cov3" title="4">for _, topic := range topicsToRemove </span><span class="cov4" title="5">{
                if remove </span><span class="cov4" title="5">{
                        delete(topicMap, topic)
                }</span> else<span class="cov0" title="0"> {
                        topicMap[topic] = true
                }</span>
        }

        // Convert back to slice
        <span class="cov3" title="4">var newTopics []EventTopic
        for topic := range topicMap </span><span class="cov3" title="4">{
                newTopics = append(newTopics, topic)
        }</span>

        <span class="cov3" title="4">subscription.Topics = newTopics</span>
}

func (em *EventManager) isClientInterested(subscription *EventSubscription, event *EventMessage) bool <span class="cov5" title="8">{
        // Check if client is subscribed to this topic
        topicFound := false
        for _, topic := range subscription.Topics </span><span class="cov5" title="8">{
                if topic == event.Topic </span><span class="cov5" title="8">{
                        topicFound = true
                        break</span>
                }
        }

        <span class="cov5" title="8">if !topicFound </span><span class="cov0" title="0">{
                return false
        }</span>

        // Apply filters if specified
        <span class="cov5" title="8">if len(subscription.Filters) &gt; 0 </span><span class="cov4" title="7">{
                return em.applyFilters(subscription.Filters, event.Data)
        }</span>

        <span class="cov1" title="1">return true</span>
}

func (em *EventManager) applyFilters(filters map[string]interface{}, eventData map[string]interface{}) bool <span class="cov4" title="7">{
        for key, expectedValue := range filters </span><span class="cov6" title="14">{
                if actualValue, exists := eventData[key]; !exists || !em.valuesEqual(actualValue, expectedValue) </span><span class="cov4" title="6">{
                        return false
                }</span>
        }
        <span class="cov1" title="1">return true</span>
}

// valuesEqual safely compares two interface{} values, handling uncomparable types
func (em *EventManager) valuesEqual(a, b interface{}) bool <span class="cov5" title="11">{
        // Handle nil cases
        if a == nil &amp;&amp; b == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov5" title="11">if a == nil || b == nil </span><span class="cov1" title="1">{
                return false
        }</span>

        // Handle uncomparable types first - reject them to prevent panics
        <span class="cov5" title="10">switch a.(type) </span>{
        case map[string]interface{}, []interface{}, func():<span class="cov1" title="1">
                // These types are uncomparable in Go - log warning and return false
                em.logger.WithFields(logging.Fields{
                        "type_a": fmt.Sprintf("%T", a),
                        "type_b": fmt.Sprintf("%T", b),
                }).Warn("Filter comparison skipped for uncomparable types")
                return false</span>
        default:<span class="cov5" title="9">
                // For other types, use direct comparison (should be safe)
                return a == b</span>
        }
}

func (em *EventManager) processEventHandlers(event *EventMessage) error <span class="cov8" title="41">{
        handlers, exists := em.eventHandlers[event.Topic]
        if !exists </span><span class="cov8" title="36">{
                return nil
        }</span>

        <span class="cov4" title="5">for _, handler := range handlers </span><span class="cov4" title="7">{
                // Use anonymous function with panic recovery to prevent panics from crashing the server
                func() </span><span class="cov4" title="7">{
                        defer func() </span><span class="cov4" title="7">{
                                if r := recover(); r != nil </span><span class="cov1" title="1">{
                                        em.logger.WithFields(logging.Fields{
                                                "event_id": event.EventID,
                                                "topic":    string(event.Topic),
                                                "panic":    r,
                                        }).Error("Event handler panicked - recovered to prevent server crash")
                                }</span>
                        }()

                        <span class="cov4" title="7">if err := handler(event); err != nil </span><span class="cov1" title="1">{
                                em.logger.WithError(err).WithField("event_id", event.EventID).Error("Event handler failed")
                                // Don't return error, continue processing other handlers
                                // This ensures one failing handler doesn't stop other handlers from executing
                        }</span>
                }()
        }

        <span class="cov4" title="5">return nil</span>
}

func generateEventID() string <span class="cov8" title="41">{
        return fmt.Sprintf("evt_%d", time.Now().UnixNano())
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
WebSocket JSON-RPC 2.0 method registration and core method implementations.

Provides method registration system and core JSON-RPC method implementations
following the Python WebSocketJsonRpcServer patterns and project architecture standards.

Requirements Coverage:
- REQ-API-002: JSON-RPC 2.0 protocol implementation
- REQ-API-003: Request/response message handling
- REQ-API-004: Core method implementations (ping, authenticate, get_camera_list, get_camera_status)

Test Categories: Unit/Integration
API Documentation Reference: docs/api/json_rpc_methods.md
*/

package websocket

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "runtime"
        "sort"
        "strconv"
        "strings"
        "sync/atomic"
        "time"

        "golang.org/x/sys/unix"

        "github.com/camerarecorder/mediamtx-camera-service-go/internal/logging"
        "github.com/camerarecorder/mediamtx-camera-service-go/internal/mediamtx"

        "hash/fnv"
)

// registerBuiltinMethods registers all built-in JSON-RPC methods
// Following Python _register_builtin_methods patterns
func (s *WebSocketServer) registerBuiltinMethods() <span class="cov5" title="25">{
        // Core methods
        s.registerMethod("ping", s.MethodPing, "1.0")
        s.registerMethod("authenticate", s.MethodAuthenticate, "1.0")
        s.registerMethod("get_camera_list", s.MethodGetCameraList, "1.0")
        s.registerMethod("get_camera_status", s.MethodGetCameraStatus, "1.0")

        // System methods
        s.registerMethod("get_metrics", s.MethodGetMetrics, "1.0")
        s.registerMethod("get_camera_capabilities", s.MethodGetCameraCapabilities, "1.0")
        s.registerMethod("get_status", s.MethodGetStatus, "1.0")
        s.registerMethod("get_server_info", s.MethodGetServerInfo, "1.0")
        s.registerMethod("get_streams", s.MethodGetStreams, "1.0")

        // File management methods
        s.registerMethod("list_recordings", s.MethodListRecordings, "1.0")
        s.registerMethod("list_snapshots", s.MethodListSnapshots, "1.0")
        s.registerMethod("get_recording_info", s.MethodGetRecordingInfo, "1.0")
        s.registerMethod("get_snapshot_info", s.MethodGetSnapshotInfo, "1.0")
        s.registerMethod("delete_recording", s.MethodDeleteRecording, "1.0")
        s.registerMethod("delete_snapshot", s.MethodDeleteSnapshot, "1.0")
        s.registerMethod("get_storage_info", s.MethodGetStorageInfo, "1.0")
        s.registerMethod("set_retention_policy", s.MethodSetRetentionPolicy, "1.0")
        s.registerMethod("cleanup_old_files", s.MethodCleanupOldFiles, "1.0")

        // Recording and snapshot methods
        s.registerMethod("take_snapshot", s.MethodTakeSnapshot, "1.0")
        s.registerMethod("start_recording", s.MethodStartRecording, "1.0")
        s.registerMethod("stop_recording", s.MethodStopRecording, "1.0")

        // Streaming methods
        s.registerMethod("start_streaming", s.MethodStartStreaming, "1.0")
        s.registerMethod("stop_streaming", s.MethodStopStreaming, "1.0")
        s.registerMethod("get_stream_url", s.MethodGetStreamURL, "1.0")
        s.registerMethod("get_stream_status", s.MethodGetStreamStatus, "1.0")

        // Notification methods
        s.registerMethod("camera_status_update", s.MethodCameraStatusUpdate, "1.0")
        s.registerMethod("recording_status_update", s.MethodRecordingStatusUpdate, "1.0")

        // Event subscription methods
        s.registerMethod("subscribe_events", s.MethodSubscribeEvents, "1.0")
        s.registerMethod("unsubscribe_events", s.MethodUnsubscribeEvents, "1.0")
        s.registerMethod("get_subscription_stats", s.MethodGetSubscriptionStats, "1.0")

        s.logger.WithField("action", "register_methods").Info("Built-in methods registered")
}</span>

// registerMethod registers a JSON-RPC method handler
func (s *WebSocketServer) registerMethod(name string, handler MethodHandler, version string) <span class="cov10" title="752">{
        s.methodsMutex.Lock()
        defer s.methodsMutex.Unlock()

        // Wrap the handler to ensure security and metrics are always applied
        wrappedHandler := func(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) </span><span class="cov6" title="51">{
                startTime := time.Now()

                // Apply security checks
                if err := s.checkRateLimit(client); err != nil </span><span class="cov0" title="0">{
                        return &amp;JsonRpcResponse{
                                JSONRPC: "2.0",
                                Error: &amp;JsonRpcError{
                                        Code:    RATE_LIMIT_EXCEEDED,
                                        Message: ErrorMessages[RATE_LIMIT_EXCEEDED],
                                        Data:    err.Error(),
                                },
                        }, nil
                }</span>

                <span class="cov6" title="51">if err := s.checkMethodPermissions(client, name); err != nil </span><span class="cov0" title="0">{
                        return &amp;JsonRpcResponse{
                                JSONRPC: "2.0",
                                Error: &amp;JsonRpcError{
                                        Code:    INSUFFICIENT_PERMISSIONS,
                                        Message: ErrorMessages[INSUFFICIENT_PERMISSIONS],
                                        Data:    err.Error(),
                                },
                        }, nil
                }</span>

                // Call the original handler
                <span class="cov6" title="51">response, err := handler(params, client)

                // Record metrics
                duration := time.Since(startTime).Seconds()
                s.recordRequest(name, duration)

                // Handle errors
                if err != nil </span><span class="cov0" title="0">{
                        // Use atomic operation for ErrorCount
                        atomic.AddInt64(&amp;s.metrics.ErrorCount, 1)
                }</span>

                <span class="cov6" title="51">return response, err</span>
        }

        <span class="cov10" title="752">s.methods[name] = wrappedHandler
        s.methodVersions[name] = version

        s.logger.WithFields(logging.Fields{
                "method":  name,
                "version": version,
                "action":  "register_method",
        }).Debug("Method registered with security and metrics wrapper")</span>
}

// MethodPing implements the ping method
// Following Python _method_ping implementation
func (s *WebSocketServer) MethodPing(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov5" title="27">{
        startTime := time.Now()

        s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    "ping",
                "action":    "method_call",
        }).Debug("Ping method called")

        // Check authentication (required per API documentation)
        if !client.Authenticated </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    AUTHENTICATION_REQUIRED,
                                Message: ErrorMessages[AUTHENTICATION_REQUIRED],
                        },
                }, nil
        }</span>

        // Record performance metrics
        <span class="cov5" title="27">duration := time.Since(startTime).Seconds()
        s.recordRequest("ping", duration)

        // Return "pong" as specified in API documentation
        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result:  "pong",
        }, nil</span>
}

// MethodAuthenticate implements the authenticate method
// Following Python _method_authenticate implementation
func (s *WebSocketServer) MethodAuthenticate(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov5" title="21">{
        startTime := time.Now()

        s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    "authenticate",
                "action":    "method_call",
        }).Debug("Authenticate method called")

        // Extract auth_token parameter
        authToken, ok := params["auth_token"].(string)
        if !ok || authToken == "" </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INVALID_PARAMS,
                                Message: ErrorMessages[INVALID_PARAMS],
                                Data:    "auth_token parameter is required",
                        },
                }, nil
        }</span>

        // Validate JWT token
        <span class="cov5" title="21">claims, err := s.jwtHandler.ValidateToken(authToken)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).WithFields(logging.Fields{
                        "client_id": client.ClientID,
                        "method":    "authenticate",
                        "action":    "authentication_failed",
                }).Warn("Authentication failed")

                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    AUTHENTICATION_REQUIRED,
                                Message: ErrorMessages[AUTHENTICATION_REQUIRED],
                                Data: map[string]interface{}{
                                        "reason": "Invalid or expired token",
                                },
                        },
                }, nil
        }</span>

        // Update client authentication state
        <span class="cov5" title="21">client.Authenticated = true
        client.UserID = claims.UserID
        client.Role = claims.Role
        client.AuthMethod = "jwt"

        // Calculate expiration time
        expiresAt := time.Unix(claims.EXP, 0)

        s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "user_id":   claims.UserID,
                "role":      claims.Role,
                "method":    "authenticate",
                "action":    "authentication_success",
        }).Info("Authentication successful")

        // Record performance metrics
        duration := time.Since(startTime).Seconds()
        s.recordRequest("authenticate", duration)

        // Return authentication result following Python implementation
        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result: map[string]interface{}{
                        "authenticated": true,
                        "role":          claims.Role,
                        "permissions":   GetPermissionsForRole(claims.Role),
                        "expires_at":    expiresAt.Format(time.RFC3339),
                        "session_id":    client.ClientID,
                },
        }, nil</span>
}

// MethodGetCameraList implements the get_camera_list method
// Following Python _method_get_camera_list implementation
func (s *WebSocketServer) MethodGetCameraList(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    "get_camera_list",
                "action":    "method_call",
        }).Debug("Get camera list method called")

        // Check authentication
        if !client.Authenticated </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    AUTHENTICATION_REQUIRED,
                                Message: ErrorMessages[AUTHENTICATION_REQUIRED],
                        },
                }, nil
        }</span>

        // Get camera list from camera monitor
        <span class="cov0" title="0">cameras := s.cameraMonitor.GetConnectedCameras()

        // Convert camera list to response format following API documentation exactly
        cameraList := make([]map[string]interface{}, 0, len(cameras))
        connectedCount := 0

        for devicePath, camera := range cameras </span><span class="cov0" title="0">{
                // Convert device path to camera identifier for API response
                cameraID := s.getCameraIdentifierFromDevicePath(devicePath)

                // Get resolution from first format if available
                resolution := ""
                if len(camera.Formats) &gt; 0 </span><span class="cov0" title="0">{
                        format := camera.Formats[0]
                        resolution = fmt.Sprintf("%dx%d", format.Width, format.Height)
                }</span>

                // Build streams object following API documentation exactly
                <span class="cov0" title="0">streams := map[string]string{
                        "rtsp":   fmt.Sprintf("rtsp://localhost:8554/%s", s.getStreamNameFromDevicePath(devicePath)),
                        "webrtc": fmt.Sprintf("http://localhost:8889/%s/webrtc", s.getStreamNameFromDevicePath(devicePath)),
                        "hls":    fmt.Sprintf("http://localhost:8888/%s", s.getStreamNameFromDevicePath(devicePath)),
                }

                cameraData := map[string]interface{}{
                        "device":     cameraID, // Use camera identifier instead of device path
                        "status":     string(camera.Status),
                        "name":       camera.Name,
                        "resolution": resolution,
                        "fps":        30, // Default FPS - can be enhanced later
                        "streams":    streams,
                }

                cameraList = append(cameraList, cameraData)

                if camera.Status == "CONNECTED" </span><span class="cov0" title="0">{
                        connectedCount++
                }</span>
        }

        <span class="cov0" title="0">s.logger.WithFields(logging.Fields{
                "client_id":     client.ClientID,
                "method":        "get_camera_list",
                "total_cameras": len(cameras),
                "connected":     connectedCount,
                "action":        "camera_list_success",
        }).Debug("Camera list retrieved successfully")

        // Return camera list following API documentation exactly
        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result: map[string]interface{}{
                        "cameras":   cameraList,
                        "total":     len(cameras),
                        "connected": connectedCount,
                },
        }, nil</span>
}

// MethodGetCameraStatus implements the get_camera_status method
// Following Python _method_get_camera_status implementation
func (s *WebSocketServer) MethodGetCameraStatus(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    "get_camera_status",
                "action":    "method_call",
        }).Debug("Get camera status method called")

        // Check authentication
        if !client.Authenticated </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    AUTHENTICATION_REQUIRED,
                                Message: ErrorMessages[AUTHENTICATION_REQUIRED],
                        },
                }, nil
        }</span>

        // Extract device parameter
        <span class="cov0" title="0">cameraID, ok := params["device"].(string)
        if !ok || cameraID == "" </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INVALID_PARAMS,
                                Message: ErrorMessages[INVALID_PARAMS],
                                Data:    "device parameter is required",
                        },
                }, nil
        }</span>

        // Validate camera identifier format
        <span class="cov0" title="0">if !s.validateCameraIdentifier(cameraID) </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INVALID_PARAMS,
                                Message: ErrorMessages[INVALID_PARAMS],
                                Data:    fmt.Sprintf("Invalid camera identifier format: %s. Expected format: camera[0-9]+", cameraID),
                        },
                }, nil
        }</span>

        // Convert camera identifier to device path for internal lookup
        <span class="cov0" title="0">devicePath := s.getDevicePathFromCameraIdentifier(cameraID)

        // Get camera status from camera monitor
        camera, exists := s.cameraMonitor.GetDevice(devicePath)
        if !exists </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    CAMERA_NOT_FOUND,
                                Message: ErrorMessages[CAMERA_NOT_FOUND],
                                Data:    fmt.Sprintf("Camera '%s' not found", cameraID),
                        },
                }, nil
        }</span>

        // Get resolution from first format if available
        <span class="cov0" title="0">resolution := ""
        if len(camera.Formats) &gt; 0 </span><span class="cov0" title="0">{
                format := camera.Formats[0]
                resolution = fmt.Sprintf("%dx%d", format.Width, format.Height)
        }</span>

        // Build streams object following API documentation exactly
        <span class="cov0" title="0">streams := map[string]string{
                "rtsp":   fmt.Sprintf("rtsp://localhost:8554/%s", s.getStreamNameFromDevicePath(devicePath)),
                "webrtc": fmt.Sprintf("webrtc://localhost:8002/%s", s.getStreamNameFromDevicePath(devicePath)),
                "hls":    fmt.Sprintf("http://localhost:8002/hls/%s.m3u8", s.getStreamNameFromDevicePath(devicePath)),
        }

        // Build capabilities object following API documentation exactly
        capabilities := map[string]interface{}{
                "formats":     []string{}, // Will be populated from camera.Formats
                "resolutions": []string{}, // Will be populated from camera.Formats
        }

        // Populate capabilities from camera data if available
        if len(camera.Formats) &gt; 0 </span><span class="cov0" title="0">{
                formats := make([]string, 0, len(camera.Formats))
                resolutions := make([]string, 0, len(camera.Formats))

                for _, format := range camera.Formats </span><span class="cov0" title="0">{
                        formats = append(formats, format.PixelFormat)
                        resolution := fmt.Sprintf("%dx%d", format.Width, format.Height)
                        resolutions = append(resolutions, resolution)
                }</span>

                <span class="cov0" title="0">capabilities["formats"] = formats
                capabilities["resolutions"] = resolutions</span>
        }

        <span class="cov0" title="0">s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "device":    cameraID,
                "method":    "get_camera_status",
                "status":    string(camera.Status),
                "action":    "camera_status_success",
        }).Debug("Camera status retrieved successfully")

        // Return camera status following API documentation exactly
        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result: map[string]interface{}{
                        "device":       cameraID,
                        "status":       string(camera.Status),
                        "name":         camera.Name,
                        "resolution":   resolution,
                        "fps":          30, // Default FPS - can be enhanced later
                        "streams":      streams,
                        "capabilities": capabilities,
                },
        }, nil</span>
}

// MethodGetMetrics implements the get_metrics method
// Following Python _method_get_metrics implementation
func (s *WebSocketServer) MethodGetMetrics(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    "get_metrics",
                "action":    "method_call",
        }).Debug("Get metrics method called")

        // Check authentication
        if !client.Authenticated </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    AUTHENTICATION_REQUIRED,
                                Message: ErrorMessages[AUTHENTICATION_REQUIRED],
                        },
                }, nil
        }</span>

        // Get system metrics from MediaMTX controller
        <span class="cov0" title="0">var systemMetrics *mediamtx.SystemMetrics
        var err error

        if s.mediaMTXController != nil </span><span class="cov0" title="0">{
                systemMetrics, err = s.mediaMTXController.GetSystemMetrics(context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithError(err).WithFields(logging.Fields{
                                "client_id": client.ClientID,
                                "method":    "get_metrics",
                                "action":    "controller_error",
                        }).Error("Error getting system metrics from controller")
                }</span>
        }

        // Enhanced health metrics are available through systemMetrics (Phase 1 enhancement)

        // Get base performance metrics from existing infrastructure
        <span class="cov0" title="0">baseMetrics := s.GetMetrics()

        // Get active connections count
        s.clientsMutex.RLock()
        activeConnections := len(s.clients)
        s.clientsMutex.RUnlock()

        // Calculate average response time from existing metrics
        var averageResponseTime float64
        var totalResponseTime float64
        var responseCount int

        for _, times := range baseMetrics.ResponseTimes </span><span class="cov0" title="0">{
                for _, time := range times </span><span class="cov0" title="0">{
                        totalResponseTime += time
                        responseCount++
                }</span>
        }

        <span class="cov0" title="0">if responseCount &gt; 0 </span><span class="cov0" title="0">{
                averageResponseTime = totalResponseTime / float64(responseCount)
        }</span>

        // Calculate error rate
        <span class="cov0" title="0">var errorRate float64
        if baseMetrics.RequestCount &gt; 0 </span><span class="cov0" title="0">{
                errorRate = float64(baseMetrics.ErrorCount) / float64(baseMetrics.RequestCount) * 100.0
        }</span>

        // Get system resource usage using Go runtime
        <span class="cov0" title="0">var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)
        memoryUsage := float64(m.Alloc) / 1024 / 1024 // MB

        // Get CPU usage using Linux /proc/stat
        cpuUsage := getCPUUsage()

        // Get goroutines count
        goroutines := runtime.NumGoroutine()

        // Get heap allocation in bytes
        heapAlloc := m.HeapAlloc

        // Enhanced metrics result with sophisticated health monitoring (Phase 1 enhancement)
        result := map[string]interface{}{
                "active_connections":    activeConnections,
                "total_requests":        baseMetrics.RequestCount,
                "average_response_time": averageResponseTime,
                "error_rate":            errorRate,
                "memory_usage":          memoryUsage,
                "cpu_usage":             cpuUsage,
                "goroutines":            goroutines,
                "heap_alloc":            heapAlloc,
        }

        // Use system metrics from controller if available (Phase 1 enhancement)
        if systemMetrics != nil </span><span class="cov0" title="0">{
                // Use system metrics for response time and error rate, but keep WebSocket connection count
                averageResponseTime = systemMetrics.ResponseTime
                if systemMetrics.RequestCount &gt; 0 </span><span class="cov0" title="0">{
                        errorRate = float64(systemMetrics.ErrorCount) / float64(systemMetrics.RequestCount) * 100.0
                }</span>

                // Add enhanced health monitoring metrics (Phase 1 enhancement)
                <span class="cov0" title="0">result["circuit_breaker_state"] = systemMetrics.CircuitBreakerState
                result["component_status"] = systemMetrics.ComponentStatus
                result["error_counts"] = systemMetrics.ErrorCounts
                result["last_check"] = systemMetrics.LastCheck

                // Update metrics with enhanced values (but preserve WebSocket connection count)
                result["average_response_time"] = averageResponseTime
                result["error_rate"] = errorRate</span>
        }

        <span class="cov0" title="0">s.logger.WithFields(logging.Fields{
                "client_id":             client.ClientID,
                "method":                "get_metrics",
                "active_connections":    activeConnections,
                "total_requests":        baseMetrics.RequestCount,
                "average_response_time": averageResponseTime,
                "error_rate":            errorRate,
                "memory_usage":          memoryUsage,
                "action":                "metrics_success",
        }).Debug("Metrics retrieved successfully")

        // Return enhanced metrics following API documentation exactly (Phase 1 enhancement)
        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result:  result,
        }, nil</span>
}

// MethodGetCameraCapabilities implements the get_camera_capabilities method
// Following Python _method_get_camera_capabilities implementation
func (s *WebSocketServer) MethodGetCameraCapabilities(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    "get_camera_capabilities",
                "action":    "method_call",
        }).Debug("Get camera capabilities method called")

        // Check authentication
        if !client.Authenticated </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    AUTHENTICATION_REQUIRED,
                                Message: ErrorMessages[AUTHENTICATION_REQUIRED],
                        },
                }, nil
        }</span>

        // Extract device parameter
        <span class="cov0" title="0">device, ok := params["device"].(string)
        if !ok || device == "" </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INVALID_PARAMS,
                                Message: ErrorMessages[INVALID_PARAMS],
                                Data:    "device parameter is required",
                        },
                }, nil
        }</span>

        // Initialize response with architecture defaults following API documentation exactly
        <span class="cov0" title="0">cameraCapabilities := map[string]interface{}{
                "device":            device,
                "formats":           []string{},
                "resolutions":       []string{},
                "fps_options":       []int{},
                "validation_status": "none",
        }

        // Get camera info from camera monitor using existing infrastructure
        camera, exists := s.cameraMonitor.GetDevice(device)
        if !exists </span><span class="cov0" title="0">{
                cameraCapabilities["validation_status"] = "disconnected"
        }</span> else<span class="cov0" title="0"> if camera.Status != "CONNECTED" </span><span class="cov0" title="0">{
                cameraCapabilities["validation_status"] = "disconnected"
        }</span> else<span class="cov0" title="0"> {
                // Camera is connected, get real capability metadata
                // Convert camera formats to string list per API documentation
                formats := make([]string, 0, len(camera.Formats))
                for _, format := range camera.Formats </span><span class="cov0" title="0">{
                        formats = append(formats, format.PixelFormat)
                }</span>
                <span class="cov0" title="0">cameraCapabilities["formats"] = formats

                // Convert resolutions to string list per API documentation
                resolutions := make([]string, 0, len(camera.Formats))
                for _, format := range camera.Formats </span><span class="cov0" title="0">{
                        resolution := fmt.Sprintf("%dx%d", format.Width, format.Height)
                        resolutions = append(resolutions, resolution)
                }</span>
                <span class="cov0" title="0">cameraCapabilities["resolutions"] = resolutions

                // Add FPS options as int list per API documentation
                fpsOptions := []int{15, 30, 60}
                cameraCapabilities["fps_options"] = fpsOptions

                // Set validation status to confirmed since we have real data
                cameraCapabilities["validation_status"] = "confirmed"

                s.logger.WithFields(logging.Fields{
                        "client_id":   client.ClientID,
                        "device":      device,
                        "method":      "get_camera_capabilities",
                        "formats":     len(formats),
                        "resolutions": len(resolutions),
                        "action":      "capabilities_success",
                }).Debug("Camera capabilities retrieved successfully")</span>
        }

        // Return camera capabilities following API documentation exactly
        <span class="cov0" title="0">return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result:  cameraCapabilities,
        }, nil</span>
}

// MethodGetStatus implements the get_status method
// Following Python _method_get_status implementation
func (s *WebSocketServer) MethodGetStatus(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov1" title="1">{
        s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    "get_status",
                "action":    "method_call",
        }).Debug("Get status method called")

        // Check authentication
        if !client.Authenticated </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    AUTHENTICATION_REQUIRED,
                                Message: ErrorMessages[AUTHENTICATION_REQUIRED],
                        },
                }, nil
        }</span>

        // Calculate uptime as positive integer (seconds since start)
        <span class="cov1" title="1">startTime := s.metrics.StartTime
        uptime := int(time.Since(startTime).Seconds())
        if uptime &lt; 0 </span><span class="cov0" title="0">{
                uptime = 0
        }</span>

        // Determine overall system status
        <span class="cov1" title="1">systemStatus := "healthy"

        // Check component statuses
        websocketServerStatus := "running"
        cameraMonitorStatus := "running"
        mediamtxControllerStatus := "unknown"

        // Check if camera monitor is available and running
        if s.cameraMonitor != nil </span><span class="cov0" title="0">{
                cameraMonitorStatus = "running"
        }</span> else<span class="cov1" title="1"> {
                cameraMonitorStatus = "error"
                systemStatus = "degraded"
        }</span>

        // Check if server is running
        <span class="cov1" title="1">if !s.running </span><span class="cov0" title="0">{
                websocketServerStatus = "error"
                systemStatus = "degraded"
        }</span>

        // Note: MediaMTX controller status would be checked here when MediaMTX integration is available
        // For now, we'll use "unknown" as per Python implementation pattern

        <span class="cov1" title="1">s.logger.WithFields(logging.Fields{
                "client_id":     client.ClientID,
                "method":        "get_status",
                "system_status": systemStatus,
                "uptime":        uptime,
                "action":        "status_success",
        }).Debug("System status retrieved successfully")

        // Return status following API documentation exactly
        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result: map[string]interface{}{
                        "status":  systemStatus,
                        "uptime":  uptime,
                        "version": "1.0.0",
                        "components": map[string]interface{}{
                                "websocket_server":    websocketServerStatus,
                                "camera_monitor":      cameraMonitorStatus,
                                "mediamtx_controller": mediamtxControllerStatus,
                        },
                },
        }, nil</span>
}

// MethodGetServerInfo implements the get_server_info method
// Following Python _method_get_server_info implementation
func (s *WebSocketServer) MethodGetServerInfo(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov1" title="2">{
        startTime := time.Now()

        s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    "get_server_info",
                "action":    "method_call",
        }).Debug("Get server info method called")

        // Record performance metrics first
        duration := time.Since(startTime).Seconds()
        s.recordRequest("get_server_info", duration)

        // Check authentication
        if !client.Authenticated </span><span class="cov0" title="0">{
                // Increment error count for authentication failure
                atomic.AddInt64(&amp;s.metrics.ErrorCount, 1)

                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    AUTHENTICATION_REQUIRED,
                                Message: ErrorMessages[AUTHENTICATION_REQUIRED],
                        },
                }, nil
        }</span>

        // Check permissions
        <span class="cov1" title="2">if err := s.checkMethodPermissions(client, "get_server_info"); err != nil </span><span class="cov0" title="0">{
                // Increment error count for permission failure
                atomic.AddInt64(&amp;s.metrics.ErrorCount, 1)

                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INSUFFICIENT_PERMISSIONS,
                                Message: ErrorMessages[INSUFFICIENT_PERMISSIONS],
                                Data:    err.Error(),
                        },
                }, nil
        }</span>

        <span class="cov1" title="2">s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    "get_server_info",
                "action":    "server_info_success",
        }).Debug("Server info retrieved successfully")

        // Return server info following API documentation exactly
        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result: map[string]interface{}{
                        "name":              "MediaMTX Camera Service",
                        "version":           "1.0.0",
                        "build_date":        time.Now().Format("2006-01-02"),
                        "go_version":        runtime.Version(),
                        "architecture":      runtime.GOARCH,
                        "capabilities":      []string{"snapshots", "recordings", "streaming"},
                        "supported_formats": []string{"mp4", "mkv", "jpg"},
                        "max_cameras":       10,
                },
        }, nil</span>
}

// MethodGetStreams implements the get_streams method
// Following Python _method_get_streams implementation
func (s *WebSocketServer) MethodGetStreams(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    "get_streams",
                "action":    "method_call",
        }).Debug("Get streams method called")

        // Check authentication
        if !client.Authenticated </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    AUTHENTICATION_REQUIRED,
                                Message: ErrorMessages[AUTHENTICATION_REQUIRED],
                        },
                }, nil
        }</span>

        // Get streams from MediaMTX controller
        <span class="cov0" title="0">streams, err := s.mediaMTXController.GetStreams(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).WithFields(logging.Fields{
                        "client_id": client.ClientID,
                        "method":    "get_streams",
                        "action":    "get_streams_error",
                }).Error("Failed to get streams from MediaMTX controller")

                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    MEDIAMTX_UNAVAILABLE,
                                Message: "Failed to get streams from MediaMTX service",
                                Data: map[string]interface{}{
                                        "reason": err.Error(),
                                },
                        },
                }, nil
        }</span>

        // Convert streams to response format
        <span class="cov0" title="0">streamList := make([]map[string]interface{}, 0, len(streams))
        for _, stream := range streams </span><span class="cov0" title="0">{
                // Convert MediaMTX API structure to our response format
                sourceStr := ""
                if stream.Source != nil </span><span class="cov0" title="0">{
                        sourceStr = stream.Source.Type
                }</span>

                <span class="cov0" title="0">status := "NOT_READY"
                if stream.Ready </span><span class="cov0" title="0">{
                        status = "READY"
                }</span>

                <span class="cov0" title="0">streamList = append(streamList, map[string]interface{}{
                        "id":     stream.Name, // Use Name as ID for backward compatibility
                        "name":   stream.Name,
                        "source": sourceStr,
                        "status": status,
                })</span>
        }

        <span class="cov0" title="0">s.logger.WithFields(logging.Fields{
                "client_id":    client.ClientID,
                "method":       "get_streams",
                "stream_count": len(streamList),
                "action":       "get_streams_success",
        }).Debug("Successfully retrieved streams from MediaMTX controller")

        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result:  streamList,
        }, nil</span>
}

// MethodListRecordings implements the list_recordings method
// Following Python _method_list_recordings implementation
func (s *WebSocketServer) MethodListRecordings(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    "list_recordings",
                "action":    "method_call",
        }).Debug("List recordings method called")

        // Check authentication
        if !client.Authenticated </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    AUTHENTICATION_REQUIRED,
                                Message: ErrorMessages[AUTHENTICATION_REQUIRED],
                        },
                }, nil
        }</span>

        // Validate pagination parameters using centralized validation
        <span class="cov0" title="0">validationResult := s.validationHelper.ValidatePaginationParams(params)
        if !validationResult.Valid </span><span class="cov0" title="0">{
                // Log validation warnings for debugging
                s.validationHelper.LogValidationWarnings(validationResult, "list_recordings", client.ClientID)
                return s.validationHelper.CreateValidationErrorResponse(validationResult), nil
        }</span>

        // Extract validated parameters
        <span class="cov0" title="0">limit := validationResult.Data["limit"].(int)
        offset := validationResult.Data["offset"].(int)

        // Use MediaMTX controller to get recordings list
        fileList, err := s.mediaMTXController.ListRecordings(context.Background(), limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).WithFields(logging.Fields{
                        "client_id": client.ClientID,
                        "method":    "list_recordings",
                        "action":    "controller_error",
                }).Error("Error getting recordings list from controller")

                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INTERNAL_ERROR,
                                Message: ErrorMessages[INTERNAL_ERROR],
                                Data:    fmt.Sprintf("Error getting recordings list: %v", err),
                        },
                }, nil
        }</span>

        // Check if no recordings found
        <span class="cov0" title="0">if fileList.Total == 0 </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INVALID_PARAMS,
                                Message: "No recordings found",
                                Data:    "No recording files found in storage",
                        },
                }, nil
        }</span>

        // Convert FileMetadata to map for JSON response
        <span class="cov0" title="0">files := make([]map[string]interface{}, len(fileList.Files))
        for i, file := range fileList.Files </span><span class="cov0" title="0">{
                fileData := map[string]interface{}{
                        "filename":      file.FileName,
                        "file_size":     file.FileSize,
                        "modified_time": file.ModifiedAt.Format(time.RFC3339),
                        "download_url":  file.DownloadURL,
                }

                // Add duration if available
                if file.Duration != nil </span><span class="cov0" title="0">{
                        fileData["duration"] = *file.Duration
                }</span>

                <span class="cov0" title="0">files[i] = fileData</span>
        }

        <span class="cov0" title="0">s.logger.WithFields(logging.Fields{
                "client_id":   client.ClientID,
                "method":      "list_recordings",
                "total_files": fileList.Total,
                "returned":    len(files),
                "action":      "recordings_listed",
        }).Debug("Recordings listed successfully")

        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result: map[string]interface{}{
                        "files":  files,
                        "total":  fileList.Total,
                        "limit":  fileList.Limit,
                        "offset": fileList.Offset,
                },
        }, nil</span>
}

// MethodDeleteRecording implements the delete_recording method
// Following Python _method_delete_recording implementation
func (s *WebSocketServer) MethodDeleteRecording(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    "delete_recording",
                "action":    "method_call",
        }).Debug("Delete recording method called")

        // Check authentication
        if !client.Authenticated </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    AUTHENTICATION_REQUIRED,
                                Message: ErrorMessages[AUTHENTICATION_REQUIRED],
                        },
                }, nil
        }</span>

        // Validate parameters
        <span class="cov0" title="0">if params == nil </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INVALID_PARAMS,
                                Message: ErrorMessages[INVALID_PARAMS],
                                Data:    "filename parameter is required",
                        },
                }, nil
        }</span>

        <span class="cov0" title="0">filename, ok := params["filename"].(string)
        if !ok || filename == "" </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INVALID_PARAMS,
                                Message: ErrorMessages[INVALID_PARAMS],
                                Data:    "filename must be a non-empty string",
                        },
                }, nil
        }</span>

        // Use MediaMTX controller to delete recording
        <span class="cov0" title="0">err := s.mediaMTXController.DeleteRecording(context.Background(), filename)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).WithFields(logging.Fields{
                        "client_id": client.ClientID,
                        "method":    "delete_recording",
                        "filename":  filename,
                        "action":    "controller_error",
                }).Error("Error deleting recording from controller")

                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INTERNAL_ERROR,
                                Message: ErrorMessages[INTERNAL_ERROR],
                                Data:    fmt.Sprintf("Error deleting recording: %v", err),
                        },
                }, nil
        }</span>

        <span class="cov0" title="0">s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    "delete_recording",
                "filename":  filename,
                "action":    "delete_success",
        }).Info("Recording file deleted successfully")

        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result: map[string]interface{}{
                        "filename": filename,
                        "deleted":  true,
                        "message":  "Recording file deleted successfully",
                },
        }, nil</span>
}

// MethodDeleteSnapshot implements the delete_snapshot method
// Following Python _method_delete_snapshot implementation
func (s *WebSocketServer) MethodDeleteSnapshot(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    "delete_snapshot",
                "action":    "method_call",
        }).Debug("Delete snapshot method called")

        // Check authentication
        if !client.Authenticated </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    AUTHENTICATION_REQUIRED,
                                Message: ErrorMessages[AUTHENTICATION_REQUIRED],
                        },
                }, nil
        }</span>

        // Validate filename parameter using centralized validation
        <span class="cov0" title="0">validationResult := s.validationHelper.ValidateFilenameParameter(params)
        if !validationResult.Valid </span><span class="cov0" title="0">{
                // Log validation warnings for debugging
                s.validationHelper.LogValidationWarnings(validationResult, "delete_recording", client.ClientID)
                return s.validationHelper.CreateValidationErrorResponse(validationResult), nil
        }</span>

        // Extract validated filename
        <span class="cov0" title="0">filename := validationResult.Data["filename"].(string)

        // Use MediaMTX controller to delete snapshot
        err := s.mediaMTXController.DeleteSnapshot(context.Background(), filename)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).WithFields(logging.Fields{
                        "client_id": client.ClientID,
                        "method":    "delete_snapshot",
                        "filename":  filename,
                        "action":    "controller_error",
                }).Error("Error deleting snapshot from controller")

                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INTERNAL_ERROR,
                                Message: ErrorMessages[INTERNAL_ERROR],
                                Data:    fmt.Sprintf("Error deleting snapshot: %v", err),
                        },
                }, nil
        }</span>

        <span class="cov0" title="0">s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    "delete_snapshot",
                "filename":  filename,
                "action":    "delete_success",
        }).Info("Snapshot file deleted successfully")

        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result: map[string]interface{}{
                        "filename": filename,
                        "deleted":  true,
                        "message":  "Snapshot file deleted successfully",
                },
        }, nil</span>
}

// MethodGetStorageInfo implements the get_storage_info method
// Following Python _method_get_storage_info implementation
func (s *WebSocketServer) MethodGetStorageInfo(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    "get_storage_info",
                "action":    "method_call",
        }).Debug("Get storage info method called")

        // Check authentication
        if !client.Authenticated </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    AUTHENTICATION_REQUIRED,
                                Message: ErrorMessages[AUTHENTICATION_REQUIRED],
                        },
                }, nil
        }</span>

        // Get configuration for directory paths
        <span class="cov0" title="0">config := s.configManager.GetConfig()
        if config == nil </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INTERNAL_ERROR,
                                Message: ErrorMessages[INTERNAL_ERROR],
                                Data:    "Configuration not available",
                        },
                }, nil
        }</span>

        <span class="cov0" title="0">recordingsDir := config.MediaMTX.RecordingsPath
        snapshotsDir := config.MediaMTX.SnapshotsPath

        // Get storage space information using Go's syscall package
        var stat unix.Statfs_t
        err := unix.Statfs(recordingsDir, &amp;stat)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).WithFields(logging.Fields{
                        "client_id": client.ClientID,
                        "method":    "get_storage_info",
                        "directory": recordingsDir,
                        "action":    "statfs_error",
                }).Error("Error getting storage information")

                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INTERNAL_ERROR,
                                Message: ErrorMessages[INTERNAL_ERROR],
                                Data:    fmt.Sprintf("Error getting storage information: %v", err),
                        },
                }, nil
        }</span>

        // Calculate storage space information
        <span class="cov0" title="0">totalBytes := stat.Blocks * uint64(stat.Bsize)
        freeBytes := stat.Bfree * uint64(stat.Bsize)
        usedBytes := totalBytes - freeBytes
        usedPercent := float64(usedBytes) / float64(totalBytes) * 100.0

        // Calculate directory sizes
        recordingsSize := int64(0)
        if _, err := os.Stat(recordingsDir); err == nil </span><span class="cov0" title="0">{
                recordingsSize = s.calculateDirectorySize(recordingsDir)
        }</span>

        <span class="cov0" title="0">snapshotsSize := int64(0)
        if _, err := os.Stat(snapshotsDir); err == nil </span><span class="cov0" title="0">{
                snapshotsSize = s.calculateDirectorySize(snapshotsDir)
        }</span>

        // Determine warning levels (following API documentation)
        <span class="cov0" title="0">lowSpaceWarning := usedPercent &gt;= 80.0

        s.logger.WithFields(logging.Fields{
                "client_id":    client.ClientID,
                "method":       "get_storage_info",
                "total_gb":     totalBytes / 1024 / 1024 / 1024,
                "used_gb":      usedBytes / 1024 / 1024 / 1024,
                "used_percent": usedPercent,
                "action":       "storage_info_success",
        }).Debug("Storage information retrieved successfully")

        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result: map[string]interface{}{
                        "total_space":       totalBytes,
                        "used_space":        usedBytes,
                        "available_space":   freeBytes,
                        "usage_percentage":  usedPercent,
                        "recordings_size":   recordingsSize,
                        "snapshots_size":    snapshotsSize,
                        "low_space_warning": lowSpaceWarning,
                },
        }, nil</span>
}

// calculateDirectorySize calculates the total size of a directory recursively
func (s *WebSocketServer) calculateDirectorySize(dirPath string) int64 <span class="cov0" title="0">{
        var totalSize int64

        err := filepath.Walk(dirPath, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return nil // Skip files we can't access
                }</span>
                <span class="cov0" title="0">if !info.IsDir() </span><span class="cov0" title="0">{
                        totalSize += info.Size()
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).WithFields(logging.Fields{
                        "directory": dirPath,
                        "action":    "calculate_size_error",
                }).Warn("Error calculating directory size")
        }</span>

        <span class="cov0" title="0">return totalSize</span>
}

// MethodCleanupOldFiles implements the cleanup_old_files method
// Following Python _method_cleanup_old_files implementation
func (s *WebSocketServer) MethodCleanupOldFiles(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    "cleanup_old_files",
                "action":    "method_call",
        }).Debug("Cleanup old files method called")

        // Check authentication
        if !client.Authenticated </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    AUTHENTICATION_REQUIRED,
                                Message: ErrorMessages[AUTHENTICATION_REQUIRED],
                        },
                }, nil
        }</span>

        // Get current configuration
        <span class="cov0" title="0">cfg := s.configManager.GetConfig()
        if cfg == nil </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INTERNAL_ERROR,
                                Message: ErrorMessages[INTERNAL_ERROR],
                                Data:    "Configuration not available",
                        },
                }, nil
        }</span>

        // Check if retention policy is enabled
        <span class="cov0" title="0">if !cfg.RetentionPolicy.Enabled </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INVALID_PARAMS,
                                Message: ErrorMessages[INVALID_PARAMS],
                                Data:    "Retention policy is not enabled",
                        },
                }, nil
        }</span>

        // Perform cleanup based on retention policy using MediaMTX managers directly
        <span class="cov0" title="0">var deletedCount int
        var totalSize int64
        var err error

        // Create context for cleanup operations
        ctx := context.Background()

        if cfg.RetentionPolicy.Type == "age" </span><span class="cov0" title="0">{
                // Age-based cleanup using MediaMTX managers
                maxAge := time.Duration(cfg.RetentionPolicy.MaxAgeDays) * 24 * time.Hour
                maxCount := 100 // Default max count since it's not in retention policy config

                // Clean up old recordings
                if err := s.mediaMTXController.GetRecordingManager().CleanupOldRecordings(ctx, maxAge, maxCount); err != nil </span><span class="cov0" title="0">{
                        s.logger.WithError(err).Warn("Failed to cleanup old recordings")
                }</span> else<span class="cov0" title="0"> {
                        deletedCount += 1 // Count as 1 operation
                }</span>

                // Clean up old snapshots
                <span class="cov0" title="0">if err := s.mediaMTXController.GetSnapshotManager().CleanupOldSnapshots(ctx, maxAge, maxCount); err != nil </span><span class="cov0" title="0">{
                        s.logger.WithError(err).Warn("Failed to cleanup old snapshots")
                }</span> else<span class="cov0" title="0"> {
                        deletedCount += 1 // Count as 1 operation
                }</span>

                // For now, use placeholder values - in real implementation, we'd track actual deleted files
                <span class="cov0" title="0">totalSize = 0</span> // Would calculate actual freed space
        } else<span class="cov0" title="0"> if cfg.RetentionPolicy.Type == "size" </span><span class="cov0" title="0">{
                // Size-based cleanup - convert GB to bytes and use age-based as fallback
                maxAge := time.Duration(cfg.RetentionPolicy.MaxAgeDays) * 24 * time.Hour
                maxCount := 100 // Default max count since it's not in retention policy config

                // Clean up old recordings
                if err := s.mediaMTXController.GetRecordingManager().CleanupOldRecordings(ctx, maxAge, maxCount); err != nil </span><span class="cov0" title="0">{
                        s.logger.WithError(err).Warn("Failed to cleanup old recordings")
                }</span> else<span class="cov0" title="0"> {
                        deletedCount += 1
                }</span>

                // Clean up old snapshots
                <span class="cov0" title="0">if err := s.mediaMTXController.GetSnapshotManager().CleanupOldSnapshots(ctx, maxAge, maxCount); err != nil </span><span class="cov0" title="0">{
                        s.logger.WithError(err).Warn("Failed to cleanup old snapshots")
                }</span> else<span class="cov0" title="0"> {
                        deletedCount += 1
                }</span>

                <span class="cov0" title="0">totalSize = 0</span> // Would calculate actual freed space
        } else<span class="cov0" title="0"> {
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INVALID_PARAMS,
                                Message: ErrorMessages[INVALID_PARAMS],
                                Data:    "Unsupported retention policy type for cleanup",
                        },
                }, nil
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).WithFields(logging.Fields{
                        "client_id": client.ClientID,
                        "method":    "cleanup_old_files",
                        "action":    "cleanup_error",
                }).Error("Error during file cleanup")

                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INTERNAL_ERROR,
                                Message: ErrorMessages[INTERNAL_ERROR],
                                Data:    fmt.Sprintf("Cleanup failed: %v", err),
                        },
                }, nil
        }</span>

        <span class="cov0" title="0">s.logger.WithFields(logging.Fields{
                "client_id":     client.ClientID,
                "method":        "cleanup_old_files",
                "deleted_count": deletedCount,
                "total_size":    totalSize,
                "action":        "cleanup_completed",
        }).Info("File cleanup completed successfully")

        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result: map[string]interface{}{
                        "cleanup_executed": true,
                        "files_deleted":    deletedCount,
                        "space_freed":      totalSize,
                        "message":          "File cleanup completed successfully",
                },
        }, nil</span>
}

// MethodSetRetentionPolicy implements the set_retention_policy method
// Following Python _method_set_retention_policy implementation
func (s *WebSocketServer) MethodSetRetentionPolicy(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    "set_retention_policy",
                "action":    "method_call",
        }).Debug("Set retention policy method called")

        // Check authentication
        if !client.Authenticated </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    AUTHENTICATION_REQUIRED,
                                Message: ErrorMessages[AUTHENTICATION_REQUIRED],
                        },
                }, nil
        }</span>

        // Validate retention policy parameters using centralized validation
        <span class="cov0" title="0">validationResult := s.validationHelper.ValidateRetentionPolicyParameters(params)
        if !validationResult.Valid </span><span class="cov0" title="0">{
                // Log validation warnings for debugging
                s.validationHelper.LogValidationWarnings(validationResult, "set_retention_policy", client.ClientID)
                return s.validationHelper.CreateValidationErrorResponse(validationResult), nil
        }</span>

        // Extract validated parameters
        <span class="cov0" title="0">policyType := validationResult.Data["policy_type"].(string)
        enabled := validationResult.Data["enabled"].(bool)

        // Validate age-based policy parameters
        if policyType == "age" </span><span class="cov0" title="0">{
                maxAgeDays, exists := params["max_age_days"]
                if !exists </span><span class="cov0" title="0">{
                        return &amp;JsonRpcResponse{
                                JSONRPC: "2.0",
                                Error: &amp;JsonRpcError{
                                        Code:    INVALID_PARAMS,
                                        Message: ErrorMessages[INVALID_PARAMS],
                                        Data:    "max_age_days is required for age-based policy",
                                },
                        }, nil
                }</span>

                // Convert to float64 for validation (handles both int and float)
                <span class="cov0" title="0">var maxAgeFloat float64
                switch v := maxAgeDays.(type) </span>{
                case int:<span class="cov0" title="0">
                        maxAgeFloat = float64(v)</span>
                case float64:<span class="cov0" title="0">
                        maxAgeFloat = v</span>
                default:<span class="cov0" title="0">
                        return &amp;JsonRpcResponse{
                                JSONRPC: "2.0",
                                Error: &amp;JsonRpcError{
                                        Code:    INVALID_PARAMS,
                                        Message: ErrorMessages[INVALID_PARAMS],
                                        Data:    "max_age_days must be a positive number for age-based policy",
                                },
                        }, nil</span>
                }

                <span class="cov0" title="0">if maxAgeFloat &lt;= 0 </span><span class="cov0" title="0">{
                        return &amp;JsonRpcResponse{
                                JSONRPC: "2.0",
                                Error: &amp;JsonRpcError{
                                        Code:    INVALID_PARAMS,
                                        Message: ErrorMessages[INVALID_PARAMS],
                                        Data:    "max_age_days must be a positive number for age-based policy",
                                },
                        }, nil
                }</span>
        }

        // Validate size-based policy parameters
        <span class="cov0" title="0">if policyType == "size" </span><span class="cov0" title="0">{
                maxSizeGB, exists := params["max_size_gb"]
                if !exists </span><span class="cov0" title="0">{
                        return &amp;JsonRpcResponse{
                                JSONRPC: "2.0",
                                Error: &amp;JsonRpcError{
                                        Code:    INVALID_PARAMS,
                                        Message: ErrorMessages[INVALID_PARAMS],
                                        Data:    "max_size_gb is required for size-based policy",
                                },
                        }, nil
                }</span>

                // Convert to float64 for validation (handles both int and float)
                <span class="cov0" title="0">var maxSizeFloat float64
                switch v := maxSizeGB.(type) </span>{
                case int:<span class="cov0" title="0">
                        maxSizeFloat = float64(v)</span>
                case float64:<span class="cov0" title="0">
                        maxSizeFloat = v</span>
                default:<span class="cov0" title="0">
                        return &amp;JsonRpcResponse{
                                JSONRPC: "2.0",
                                Error: &amp;JsonRpcError{
                                        Code:    INVALID_PARAMS,
                                        Message: ErrorMessages[INVALID_PARAMS],
                                        Data:    "max_size_gb must be a positive number for size-based policy",
                                },
                        }, nil</span>
                }

                <span class="cov0" title="0">if maxSizeFloat &lt;= 0 </span><span class="cov0" title="0">{
                        return &amp;JsonRpcResponse{
                                JSONRPC: "2.0",
                                Error: &amp;JsonRpcError{
                                        Code:    INVALID_PARAMS,
                                        Message: ErrorMessages[INVALID_PARAMS],
                                        Data:    "max_size_gb must be a positive number for size-based policy",
                                },
                        }, nil
                }</span>
        }

        // Get current configuration
        <span class="cov0" title="0">cfg := s.configManager.GetConfig()
        if cfg == nil </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INTERNAL_ERROR,
                                Message: ErrorMessages[INTERNAL_ERROR],
                                Data:    "Configuration not available",
                        },
                }, nil
        }</span>

        // Update retention policy configuration
        <span class="cov0" title="0">cfg.RetentionPolicy.Enabled = enabled
        cfg.RetentionPolicy.Type = policyType

        // Update policy-specific parameters
        if policyType == "age" </span><span class="cov0" title="0">{
                if maxAgeDays, ok := params["max_age_days"].(float64); ok </span><span class="cov0" title="0">{
                        cfg.RetentionPolicy.MaxAgeDays = int(maxAgeDays)
                }</span> else<span class="cov0" title="0"> if maxAgeDays, ok := params["max_age_days"].(int); ok </span><span class="cov0" title="0">{
                        cfg.RetentionPolicy.MaxAgeDays = maxAgeDays
                }</span>
        } else<span class="cov0" title="0"> if policyType == "size" </span><span class="cov0" title="0">{
                if maxSizeGB, ok := params["max_size_gb"].(float64); ok </span><span class="cov0" title="0">{
                        cfg.RetentionPolicy.MaxSizeGB = int(maxSizeGB)
                }</span> else<span class="cov0" title="0"> if maxSizeGB, ok := params["max_size_gb"].(int); ok </span><span class="cov0" title="0">{
                        cfg.RetentionPolicy.MaxSizeGB = maxSizeGB
                }</span>
        }

        // Note: Configuration changes are applied immediately in memory
        // For persistent changes, the configuration file should be updated

        <span class="cov0" title="0">s.logger.WithFields(logging.Fields{
                "client_id":   client.ClientID,
                "method":      "set_retention_policy",
                "policy_type": policyType,
                "enabled":     enabled,
                "action":      "policy_updated",
        }).Info("Retention policy configuration updated")

        // Build response result based on policy type
        result := map[string]interface{}{
                "policy_type": policyType,
                "enabled":     enabled,
                "message":     "Retention policy configuration updated successfully",
        }

        // Include policy-specific parameters in response
        if policyType == "age" </span><span class="cov0" title="0">{
                if maxAgeDays, ok := params["max_age_days"].(float64); ok </span><span class="cov0" title="0">{
                        result["max_age_days"] = int(maxAgeDays)
                }</span> else<span class="cov0" title="0"> if maxAgeDays, ok := params["max_age_days"].(int); ok </span><span class="cov0" title="0">{
                        result["max_age_days"] = maxAgeDays
                }</span>
        } else<span class="cov0" title="0"> if policyType == "size" </span><span class="cov0" title="0">{
                if maxSizeGB, ok := params["max_size_gb"].(float64); ok </span><span class="cov0" title="0">{
                        result["max_size_gb"] = int(maxSizeGB)
                }</span> else<span class="cov0" title="0"> if maxSizeGB, ok := params["max_size_gb"].(int); ok </span><span class="cov0" title="0">{
                        result["max_size_gb"] = maxSizeGB
                }</span>
        }

        <span class="cov0" title="0">return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result:  result,
        }, nil</span>
}

// MethodListSnapshots implements the list_snapshots method
// Following Python _method_list_snapshots implementation
func (s *WebSocketServer) MethodListSnapshots(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    "list_snapshots",
                "action":    "method_call",
        }).Debug("List snapshots method called")

        // Check authentication
        if !client.Authenticated </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    AUTHENTICATION_REQUIRED,
                                Message: ErrorMessages[AUTHENTICATION_REQUIRED],
                        },
                }, nil
        }</span>

        // Validate pagination parameters using centralized validation
        <span class="cov0" title="0">validationResult := s.validationHelper.ValidatePaginationParams(params)
        if !validationResult.Valid </span><span class="cov0" title="0">{
                // Log validation warnings for debugging
                s.validationHelper.LogValidationWarnings(validationResult, "list_snapshots", client.ClientID)
                return s.validationHelper.CreateValidationErrorResponse(validationResult), nil
        }</span>

        // Extract validated parameters
        <span class="cov0" title="0">limit := validationResult.Data["limit"].(int)
        offset := validationResult.Data["offset"].(int)

        // Use MediaMTX controller to get snapshots list
        fileList, err := s.mediaMTXController.ListSnapshots(context.Background(), limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).WithFields(logging.Fields{
                        "client_id": client.ClientID,
                        "method":    "list_snapshots",
                        "action":    "controller_error",
                }).Error("Error getting snapshots list from controller")

                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INTERNAL_ERROR,
                                Message: ErrorMessages[INTERNAL_ERROR],
                                Data:    fmt.Sprintf("Error getting snapshots list: %v", err),
                        },
                }, nil
        }</span>

        // Check if no snapshots found
        <span class="cov0" title="0">if fileList.Total == 0 </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INVALID_PARAMS,
                                Message: "No snapshots found",
                                Data:    "No snapshot files found in storage",
                        },
                }, nil
        }</span>

        // Convert FileMetadata to map for JSON response
        <span class="cov0" title="0">files := make([]map[string]interface{}, len(fileList.Files))
        for i, file := range fileList.Files </span><span class="cov0" title="0">{
                fileData := map[string]interface{}{
                        "filename":      file.FileName,
                        "file_size":     file.FileSize,
                        "modified_time": file.ModifiedAt.Format(time.RFC3339),
                        "download_url":  file.DownloadURL,
                }

                files[i] = fileData
        }</span>

        <span class="cov0" title="0">s.logger.WithFields(logging.Fields{
                "client_id":   client.ClientID,
                "method":      "list_snapshots",
                "total_files": fileList.Total,
                "returned":    len(files),
                "action":      "snapshots_listed",
        }).Debug("Snapshots listed successfully")

        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result: map[string]interface{}{
                        "files":  files,
                        "total":  fileList.Total,
                        "limit":  fileList.Limit,
                        "offset": fileList.Offset,
                },
        }, nil</span>
}

// MethodTakeSnapshot implements the take_snapshot method
// Following Python _method_take_snapshot implementation
func (s *WebSocketServer) MethodTakeSnapshot(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    "take_snapshot",
                "action":    "method_call",
        }).Debug("Take snapshot method called")

        // Check authentication
        if !client.Authenticated </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    AUTHENTICATION_REQUIRED,
                                Message: ErrorMessages[AUTHENTICATION_REQUIRED],
                        },
                }, nil
        }</span>

        // Validate snapshot parameters using centralized validation
        <span class="cov0" title="0">validationResult := s.validationHelper.ValidateSnapshotParameters(params)
        if !validationResult.Valid </span><span class="cov0" title="0">{
                // Log validation warnings for debugging
                s.validationHelper.LogValidationWarnings(validationResult, "take_snapshot", client.ClientID)
                return s.validationHelper.CreateValidationErrorResponse(validationResult), nil
        }</span>

        // Extract validated parameters
        <span class="cov0" title="0">devicePath := validationResult.Data["device"].(string)
        options := validationResult.Data["options"].(map[string]interface{})

        // Validate camera device exists
        _, exists := s.cameraMonitor.GetDevice(devicePath)
        if !exists </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    CAMERA_NOT_FOUND,
                                Message: ErrorMessages[CAMERA_NOT_FOUND],
                                Data:    fmt.Sprintf("Camera device %s not found", devicePath),
                        },
                }, nil
        }</span>

        // Take snapshot using MediaMTX controller
        <span class="cov0" title="0">snapshot, err := s.mediaMTXController.TakeAdvancedSnapshot(context.Background(), devicePath, "", options)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).WithFields(logging.Fields{
                        "client_id": client.ClientID,
                        "method":    "take_snapshot",
                        "device":    devicePath,
                        "action":    "take_snapshot_error",
                }).Error("Failed to take snapshot using MediaMTX controller")

                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    MEDIAMTX_UNAVAILABLE,
                                Message: "Failed to take snapshot",
                                Data: map[string]interface{}{
                                        "reason": err.Error(),
                                },
                        },
                }, nil
        }</span>

        <span class="cov0" title="0">s.logger.WithFields(logging.Fields{
                "client_id":   client.ClientID,
                "method":      "take_snapshot",
                "device":      devicePath,
                "snapshot_id": snapshot.ID,
                "action":      "take_snapshot_success",
        }).Info("Successfully took snapshot using MediaMTX controller")

        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result: map[string]interface{}{
                        "snapshot_id": snapshot.ID,
                        "device":      snapshot.Device,
                        "file_path":   snapshot.FilePath,
                        "size":        snapshot.Size,
                        "created":     snapshot.Created,
                },
        }, nil</span>
}

// MethodStartRecording implements the start_recording method
// Following Python _method_start_recording implementation
func (s *WebSocketServer) MethodStartRecording(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    "start_recording",
                "action":    "method_call",
        }).Debug("Start recording method called")

        // Check authentication
        if !client.Authenticated </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    AUTHENTICATION_REQUIRED,
                                Message: ErrorMessages[AUTHENTICATION_REQUIRED],
                        },
                }, nil
        }</span>

        // Validate recording parameters using centralized validation
        <span class="cov0" title="0">validationResult := s.validationHelper.ValidateRecordingParameters(params)
        if !validationResult.Valid </span><span class="cov0" title="0">{
                // Log validation warnings for debugging
                s.validationHelper.LogValidationWarnings(validationResult, "start_recording", client.ClientID)
                return s.validationHelper.CreateValidationErrorResponse(validationResult), nil
        }</span>

        // Extract validated parameters
        <span class="cov0" title="0">devicePath := validationResult.Data["device"].(string)
        options := validationResult.Data["options"].(map[string]interface{})

        // Convert duration to time.Duration if present
        if duration, exists := options["max_duration"]; exists </span><span class="cov0" title="0">{
                if durationInt, ok := duration.(int); ok </span><span class="cov0" title="0">{
                        options["max_duration"] = time.Duration(durationInt) * time.Second
                }</span>
        }

        // Add additional parameters that are not covered by the validation helper
        <span class="cov0" title="0">if qualityStr, ok := params["quality_level"].(string); ok &amp;&amp; qualityStr != "" </span><span class="cov0" title="0">{
                options["quality"] = qualityStr
        }</span>
        <span class="cov0" title="0">if autoRotate, ok := params["auto_rotate"].(bool); ok </span><span class="cov0" title="0">{
                options["auto_rotate"] = autoRotate
        }</span>
        <span class="cov0" title="0">if rotationSize, ok := params["rotation_size"].(int64); ok &amp;&amp; rotationSize &gt; 0 </span><span class="cov0" title="0">{
                options["rotation_size"] = rotationSize
        }</span>

        // Enhanced segment-based rotation parameters (Phase 3 enhancement)
        <span class="cov0" title="0">if continuityMode, ok := params["continuity_mode"].(bool); ok </span><span class="cov0" title="0">{
                options["continuity_mode"] = continuityMode
        }</span>
        <span class="cov0" title="0">if segmentFormat, ok := params["segment_format"].(string); ok &amp;&amp; segmentFormat != "" </span><span class="cov0" title="0">{
                options["segment_format"] = segmentFormat
        }</span>
        <span class="cov0" title="0">if resetTimestamps, ok := params["reset_timestamps"].(bool); ok </span><span class="cov0" title="0">{
                options["reset_timestamps"] = resetTimestamps
        }</span>
        <span class="cov0" title="0">if strftimeEnabled, ok := params["strftime_enabled"].(bool); ok </span><span class="cov0" title="0">{
                options["strftime_enabled"] = strftimeEnabled
        }</span>
        <span class="cov0" title="0">if segmentPrefix, ok := params["segment_prefix"].(string); ok &amp;&amp; segmentPrefix != "" </span><span class="cov0" title="0">{
                options["segment_prefix"] = segmentPrefix
        }</span>
        <span class="cov0" title="0">if maxSegments, ok := params["max_segments"].(int); ok &amp;&amp; maxSegments &gt; 0 </span><span class="cov0" title="0">{
                options["max_segments"] = maxSegments
        }</span>
        <span class="cov0" title="0">if segmentRotation, ok := params["segment_rotation"].(bool); ok </span><span class="cov0" title="0">{
                options["segment_rotation"] = segmentRotation
        }</span>

        // Convert camera identifier to device path
        <span class="cov0" title="0">actualDevicePath := s.getDevicePathFromCameraIdentifier(devicePath)

        // Validate camera device exists
        _, exists := s.cameraMonitor.GetDevice(actualDevicePath)
        if !exists </span><span class="cov0" title="0">{
                // Enhanced error categorization and logging (Phase 4 enhancement)
                enhancedErr := mediamtx.CategorizeError(fmt.Errorf("camera device not found: %s", devicePath))
                errorMetadata := mediamtx.GetErrorMetadata(enhancedErr)
                recoveryStrategies := mediamtx.GetRecoveryStrategies(enhancedErr.GetCategory())

                s.logger.WithFields(logging.Fields{
                        "client_id":           client.ClientID,
                        "method":              "start_recording",
                        "device":              devicePath,
                        "error_category":      errorMetadata["category"],
                        "error_severity":      errorMetadata["severity"],
                        "retryable":           errorMetadata["retryable"],
                        "recoverable":         errorMetadata["recoverable"],
                        "recovery_strategies": recoveryStrategies,
                }).Warn("Camera device not found with enhanced error categorization")

                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    CAMERA_NOT_FOUND,
                                Message: ErrorMessages[CAMERA_NOT_FOUND],
                                Data: map[string]interface{}{
                                        "device":              devicePath,
                                        "error_category":      errorMetadata["category"],
                                        "error_severity":      errorMetadata["severity"],
                                        "recovery_strategies": recoveryStrategies,
                                },
                        },
                }, nil
        }</span>

        // Start recording using MediaMTX controller
        <span class="cov0" title="0">session, err := s.mediaMTXController.StartAdvancedRecording(context.Background(), actualDevicePath, "", options)
        if err != nil </span><span class="cov0" title="0">{
                // Enhanced error categorization and logging (Phase 4 enhancement)
                enhancedErr := mediamtx.CategorizeError(err)
                errorMetadata := mediamtx.GetErrorMetadata(enhancedErr)
                recoveryStrategies := mediamtx.GetRecoveryStrategies(enhancedErr.GetCategory())

                s.logger.WithFields(logging.Fields{
                        "client_id":           client.ClientID,
                        "method":              "start_recording",
                        "device":              devicePath,
                        "action":              "start_recording_error",
                        "error_category":      errorMetadata["category"],
                        "error_severity":      errorMetadata["severity"],
                        "retryable":           errorMetadata["retryable"],
                        "recoverable":         errorMetadata["recoverable"],
                        "recovery_strategies": recoveryStrategies,
                }).Error("Failed to start recording using MediaMTX controller with enhanced error categorization")

                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    MEDIAMTX_UNAVAILABLE,
                                Message: "Failed to start recording",
                                Data: map[string]interface{}{
                                        "reason": err.Error(),
                                },
                        },
                }, nil
        }</span>

        <span class="cov0" title="0">s.logger.WithFields(logging.Fields{
                "client_id":  client.ClientID,
                "method":     "start_recording",
                "device":     devicePath,
                "session_id": session.ID,
                "action":     "start_recording_success",
        }).Info("Successfully started recording using MediaMTX controller")

        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result: map[string]interface{}{
                        "session_id": session.ID,
                        "device":     session.Device,
                        "status":     session.Status,
                        "start_time": session.StartTime,
                        // Enhanced use case information (Phase 2 enhancement)
                        "use_case":       session.UseCase,
                        "priority":       session.Priority,
                        "auto_cleanup":   session.AutoCleanup,
                        "retention_days": session.RetentionDays,
                        "quality":        session.Quality,
                        "max_duration":   session.MaxDuration.String(),
                        "auto_rotate":    session.AutoRotate,
                        "rotation_size":  session.RotationSize,
                        // Enhanced segment-based rotation information (Phase 3 enhancement)
                        "continuity_id": session.ContinuityID,
                },
        }, nil</span>
}

// MethodStopRecording implements the stop_recording method
// Following Python _method_stop_recording implementation
func (s *WebSocketServer) MethodStopRecording(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    "stop_recording",
                "action":    "method_call",
        }).Debug("Stop recording method called")

        // Check authentication
        if !client.Authenticated </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    AUTHENTICATION_REQUIRED,
                                Message: ErrorMessages[AUTHENTICATION_REQUIRED],
                        },
                }, nil
        }</span>

        // Validate parameters
        <span class="cov0" title="0">if params == nil </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INVALID_PARAMS,
                                Message: ErrorMessages[INVALID_PARAMS],
                                Data:    "device parameter is required",
                        },
                }, nil
        }</span>

        <span class="cov0" title="0">cameraID, ok := params["device"].(string)
        if !ok || cameraID == "" </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INVALID_PARAMS,
                                Message: ErrorMessages[INVALID_PARAMS],
                                Data:    "device parameter is required",
                        },
                }, nil
        }</span>

        // Validate camera identifier format
        <span class="cov0" title="0">if !s.validateCameraIdentifier(cameraID) </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INVALID_PARAMS,
                                Message: ErrorMessages[INVALID_PARAMS],
                                Data:    fmt.Sprintf("Invalid camera identifier format: %s. Expected format: camera[0-9]+", cameraID),
                        },
                }, nil
        }</span>

        // Convert camera identifier to device path for internal operations
        <span class="cov0" title="0">devicePath := s.getDevicePathFromCameraIdentifier(cameraID)

        // Validate camera device exists
        _, exists := s.cameraMonitor.GetDevice(devicePath)
        if !exists </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    CAMERA_NOT_FOUND,
                                Message: ErrorMessages[CAMERA_NOT_FOUND],
                                Data:    fmt.Sprintf("Camera device %s not found", devicePath),
                        },
                }, nil
        }</span>

        // Get session ID from device using optimized lookup
        <span class="cov0" title="0">sessionID, exists := s.mediaMTXController.GetSessionIDByDevice(devicePath)
        if !exists </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INVALID_PARAMS,
                                Message: "No active recording session found for device",
                                Data: map[string]interface{}{
                                        "device": devicePath,
                                },
                        },
                }, nil
        }</span>

        <span class="cov0" title="0">if sessionID == "" </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INVALID_PARAMS,
                                Message: "No active recording session found for device",
                                Data: map[string]interface{}{
                                        "device": devicePath,
                                },
                        },
                }, nil
        }</span>

        // Stop recording using MediaMTX controller
        <span class="cov0" title="0">err := s.mediaMTXController.StopAdvancedRecording(context.Background(), sessionID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).WithFields(logging.Fields{
                        "client_id":  client.ClientID,
                        "method":     "stop_recording",
                        "device":     devicePath,
                        "session_id": sessionID,
                        "action":     "stop_recording_error",
                }).Error("Failed to stop recording using MediaMTX controller")

                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    MEDIAMTX_UNAVAILABLE,
                                Message: "Failed to stop recording",
                                Data: map[string]interface{}{
                                        "reason": err.Error(),
                                },
                        },
                }, nil
        }</span>

        <span class="cov0" title="0">s.logger.WithFields(logging.Fields{
                "client_id":  client.ClientID,
                "method":     "stop_recording",
                "device":     cameraID,
                "session_id": sessionID,
                "action":     "stop_recording_success",
        }).Info("Successfully stopped recording using MediaMTX controller")

        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result: map[string]interface{}{
                        "session_id": sessionID,
                        "device":     cameraID,
                        "status":     "STOPPED",
                },
        }, nil</span>
}

// getStreamNameFromDevicePath extracts stream name from device path
func (s *WebSocketServer) getStreamNameFromDevicePath(devicePath string) string <span class="cov0" title="0">{
        // Extract device name from path (e.g., "/dev/video0" -&gt; "video0")
        parts := strings.Split(devicePath, "/")
        if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                return parts[len(parts)-1]
        }</span>
        <span class="cov0" title="0">return "unknown"</span>
}

// MethodGetRecordingInfo implements the get_recording_info method
// Following API documentation exactly
func (s *WebSocketServer) MethodGetRecordingInfo(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    "get_recording_info",
                "action":    "method_call",
        }).Debug("Get recording info method called")

        // Check authentication
        if !client.Authenticated </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    AUTHENTICATION_REQUIRED,
                                Message: ErrorMessages[AUTHENTICATION_REQUIRED],
                        },
                }, nil
        }</span>

        // Validate parameters
        <span class="cov0" title="0">if params == nil </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INVALID_PARAMS,
                                Message: ErrorMessages[INVALID_PARAMS],
                                Data:    "filename parameter is required",
                        },
                }, nil
        }</span>

        <span class="cov0" title="0">filename, ok := params["filename"].(string)
        if !ok || filename == "" </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INVALID_PARAMS,
                                Message: ErrorMessages[INVALID_PARAMS],
                                Data:    "filename must be a non-empty string",
                        },
                }, nil
        }</span>

        // Use MediaMTX controller to get recording info
        <span class="cov0" title="0">fileMetadata, err := s.mediaMTXController.GetRecordingInfo(context.Background(), filename)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).WithFields(logging.Fields{
                        "client_id": client.ClientID,
                        "method":    "get_recording_info",
                        "filename":  filename,
                        "action":    "controller_error",
                }).Error("Error getting recording info from controller")

                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INTERNAL_ERROR,
                                Message: ErrorMessages[INTERNAL_ERROR],
                                Data:    fmt.Sprintf("Error getting recording info: %v", err),
                        },
                }, nil
        }</span>

        <span class="cov0" title="0">s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    "get_recording_info",
                "filename":  filename,
                "action":    "recording_info_success",
        }).Debug("Recording info retrieved successfully")

        // Return recording info following API documentation exactly
        result := map[string]interface{}{
                "filename":     fileMetadata.FileName,
                "file_size":    fileMetadata.FileSize,
                "created_time": fileMetadata.CreatedAt.Format(time.RFC3339),
                "download_url": fileMetadata.DownloadURL,
        }

        // Add duration if available (video metadata extraction is already implemented)
        if fileMetadata.Duration != nil </span><span class="cov0" title="0">{
                result["duration"] = *fileMetadata.Duration
        }</span> else<span class="cov0" title="0"> {
                // Duration is nil for non-video files or when extraction fails
                result["duration"] = nil
        }</span>

        <span class="cov0" title="0">return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result:  result,
        }, nil</span>
}

// MethodGetSnapshotInfo implements the get_snapshot_info method
// Following API documentation exactly
func (s *WebSocketServer) MethodGetSnapshotInfo(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    "get_snapshot_info",
                "action":    "method_call",
        }).Debug("Get snapshot info method called")

        // Check authentication
        if !client.Authenticated </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    AUTHENTICATION_REQUIRED,
                                Message: ErrorMessages[AUTHENTICATION_REQUIRED],
                        },
                }, nil
        }</span>

        // Validate parameters
        <span class="cov0" title="0">if params == nil </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INVALID_PARAMS,
                                Message: ErrorMessages[INVALID_PARAMS],
                                Data:    "filename parameter is required",
                        },
                }, nil
        }</span>

        <span class="cov0" title="0">filename, ok := params["filename"].(string)
        if !ok || filename == "" </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INVALID_PARAMS,
                                Message: ErrorMessages[INVALID_PARAMS],
                                Data:    "filename must be a non-empty string",
                        },
                }, nil
        }</span>

        // Use MediaMTX controller to get snapshot info
        <span class="cov0" title="0">fileMetadata, err := s.mediaMTXController.GetSnapshotInfo(context.Background(), filename)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).WithFields(logging.Fields{
                        "client_id": client.ClientID,
                        "method":    "get_snapshot_info",
                        "filename":  filename,
                        "action":    "controller_error",
                }).Error("Error getting snapshot info from controller")

                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INTERNAL_ERROR,
                                Message: ErrorMessages[INTERNAL_ERROR],
                                Data:    fmt.Sprintf("Error getting snapshot info: %v", err),
                        },
                }, nil
        }</span>

        <span class="cov0" title="0">s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    "get_snapshot_info",
                "filename":  filename,
                "action":    "snapshot_info_success",
        }).Debug("Snapshot info retrieved successfully")

        // Return snapshot info following API documentation exactly
        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result: map[string]interface{}{
                        "filename":     fileMetadata.FileName,
                        "file_size":    fileMetadata.FileSize,
                        "created_time": fileMetadata.CreatedAt.Format(time.RFC3339),
                        "download_url": fileMetadata.DownloadURL,
                },
        }, nil</span>
}

// GetPermissionsForRole returns permissions for a given role
// Following Python role-based access control patterns
func GetPermissionsForRole(role string) []string <span class="cov5" title="21">{
        switch role </span>{
        case "admin":<span class="cov2" title="3">
                return []string{"view", "control", "admin"}</span>
        case "operator":<span class="cov0" title="0">
                return []string{"view", "control"}</span>
        case "viewer":<span class="cov4" title="18">
                return []string{"view"}</span>
        default:<span class="cov0" title="0">
                return []string{}</span>
        }
}

// getCPUUsage returns CPU usage percentage using Linux /proc/stat
func getCPUUsage() float64 <span class="cov0" title="0">{
        // Read /proc/stat to get CPU statistics
        data, err := os.ReadFile("/proc/stat")
        if err != nil </span><span class="cov0" title="0">{
                return 0.0 // Return 0 if we can't read CPU stats
        }</span>

        // Parse the first line (total CPU stats)
        <span class="cov0" title="0">lines := strings.Split(string(data), "\n")
        if len(lines) == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        // Parse CPU line: cpu  user nice system idle iowait irq softirq steal guest guest_nice
        <span class="cov0" title="0">fields := strings.Fields(lines[0])
        if len(fields) &lt; 5 || fields[0] != "cpu" </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        // Convert fields to integers
        <span class="cov0" title="0">var stats []int64
        for i := 1; i &lt; len(fields); i++ </span><span class="cov0" title="0">{
                val, err := strconv.ParseInt(fields[i], 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return 0.0
                }</span>
                <span class="cov0" title="0">stats = append(stats, val)</span>
        }

        // Calculate total and idle time
        <span class="cov0" title="0">total := int64(0)
        for _, stat := range stats </span><span class="cov0" title="0">{
                total += stat
        }</span>

        <span class="cov0" title="0">idle := int64(0)
        if len(stats) &gt;= 4 </span><span class="cov0" title="0">{
                idle = stats[3] // idle time is the 4th field
        }</span>

        // Calculate CPU usage percentage
        <span class="cov0" title="0">if total == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">usage := float64(total-idle) / float64(total) * 100.0
        return usage</span>
}

// performAgeBasedCleanup performs age-based file cleanup
func (s *WebSocketServer) performAgeBasedCleanup(maxAgeDays int) (int, int64, error) <span class="cov0" title="0">{
        // Get recordings and snapshots directories from config
        cfg := s.configManager.GetConfig()
        if cfg == nil </span><span class="cov0" title="0">{
                return 0, 0, fmt.Errorf("configuration not available")
        }</span>

        <span class="cov0" title="0">recordingsPath := cfg.MediaMTX.RecordingsPath
        snapshotsPath := cfg.MediaMTX.SnapshotsPath

        // Calculate cutoff time
        cutoffTime := time.Now().AddDate(0, 0, -maxAgeDays)

        var totalDeleted int
        var totalSize int64

        // Clean recordings
        deleted, size, err := s.cleanupDirectory(recordingsPath, cutoffTime)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).WithField("path", recordingsPath).Error("Error cleaning recordings directory")
        }</span> else<span class="cov0" title="0"> {
                totalDeleted += deleted
                totalSize += size
        }</span>

        // Clean snapshots
        <span class="cov0" title="0">deleted, size, err = s.cleanupDirectory(snapshotsPath, cutoffTime)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).WithField("path", snapshotsPath).Error("Error cleaning snapshots directory")
        }</span> else<span class="cov0" title="0"> {
                totalDeleted += deleted
                totalSize += size
        }</span>

        <span class="cov0" title="0">return totalDeleted, totalSize, nil</span>
}

// performSizeBasedCleanup performs size-based file cleanup
func (s *WebSocketServer) performSizeBasedCleanup(maxSizeGB int) (int, int64, error) <span class="cov0" title="0">{
        // Get recordings and snapshots directories from config
        cfg := s.configManager.GetConfig()
        if cfg == nil </span><span class="cov0" title="0">{
                return 0, 0, fmt.Errorf("configuration not available")
        }</span>

        <span class="cov0" title="0">recordingsPath := cfg.MediaMTX.RecordingsPath
        snapshotsPath := cfg.MediaMTX.SnapshotsPath

        // Calculate max size in bytes
        maxSizeBytes := int64(maxSizeGB) * 1024 * 1024 * 1024

        var totalDeleted int
        var totalSize int64

        // Clean recordings by size
        deleted, size, err := s.cleanupDirectoryBySize(recordingsPath, maxSizeBytes)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).WithField("path", recordingsPath).Error("Error cleaning recordings directory by size")
        }</span> else<span class="cov0" title="0"> {
                totalDeleted += deleted
                totalSize += size
        }</span>

        // Clean snapshots by size
        <span class="cov0" title="0">deleted, size, err = s.cleanupDirectoryBySize(snapshotsPath, maxSizeBytes)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).WithField("path", snapshotsPath).Error("Error cleaning snapshots directory by size")
        }</span> else<span class="cov0" title="0"> {
                totalDeleted += deleted
                totalSize += size
        }</span>

        <span class="cov0" title="0">return totalDeleted, totalSize, nil</span>
}

// cleanupDirectory removes files older than cutoff time
func (s *WebSocketServer) cleanupDirectory(dirPath string, cutoffTime time.Time) (int, int64, error) <span class="cov0" title="0">{
        entries, err := os.ReadDir(dirPath)
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, fmt.Errorf("failed to read directory %s: %w", dirPath, err)
        }</span>

        <span class="cov0" title="0">var deletedCount int
        var totalSize int64

        for _, entry := range entries </span><span class="cov0" title="0">{
                if entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">filePath := filepath.Join(dirPath, entry.Name())
                info, err := entry.Info()
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithError(err).WithField("file", filePath).Warn("Failed to get file info")
                        continue</span>
                }

                <span class="cov0" title="0">if info.ModTime().Before(cutoffTime) </span><span class="cov0" title="0">{
                        if err := os.Remove(filePath); err != nil </span><span class="cov0" title="0">{
                                s.logger.WithError(err).WithField("file", filePath).Warn("Failed to delete old file")
                                continue</span>
                        }

                        <span class="cov0" title="0">deletedCount++
                        totalSize += info.Size()

                        s.logger.WithFields(logging.Fields{
                                "file":     filePath,
                                "size":     info.Size(),
                                "modified": info.ModTime(),
                                "action":   "file_deleted",
                        }).Debug("Deleted old file")</span>
                }
        }

        <span class="cov0" title="0">return deletedCount, totalSize, nil</span>
}

// cleanupDirectoryBySize removes oldest files until directory size is under limit
func (s *WebSocketServer) cleanupDirectoryBySize(dirPath string, maxSizeBytes int64) (int, int64, error) <span class="cov0" title="0">{
        entries, err := os.ReadDir(dirPath)
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, fmt.Errorf("failed to read directory %s: %w", dirPath, err)
        }</span>

        // Collect file information
        <span class="cov0" title="0">type fileInfo struct {
                path    string
                size    int64
                modTime time.Time
        }

        var files []fileInfo
        var totalSize int64

        for _, entry := range entries </span><span class="cov0" title="0">{
                if entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">filePath := filepath.Join(dirPath, entry.Name())
                info, err := entry.Info()
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithError(err).WithField("file", filePath).Warn("Failed to get file info")
                        continue</span>
                }

                <span class="cov0" title="0">files = append(files, fileInfo{
                        path:    filePath,
                        size:    info.Size(),
                        modTime: info.ModTime(),
                })
                totalSize += info.Size()</span>
        }

        // Sort files by modification time (oldest first)
        <span class="cov0" title="0">sort.Slice(files, func(i, j int) bool </span><span class="cov0" title="0">{
                return files[i].modTime.Before(files[j].modTime)
        }</span>)

        // Remove oldest files until we're under the size limit
        <span class="cov0" title="0">var deletedCount int
        var deletedSize int64

        for _, file := range files </span><span class="cov0" title="0">{
                if totalSize &lt;= maxSizeBytes </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">if err := os.Remove(file.path); err != nil </span><span class="cov0" title="0">{
                        s.logger.WithError(err).WithField("file", file.path).Warn("Failed to delete file")
                        continue</span>
                }

                <span class="cov0" title="0">deletedCount++
                deletedSize += file.size
                totalSize -= file.size

                s.logger.WithFields(logging.Fields{
                        "file":     file.path,
                        "size":     file.size,
                        "modified": file.modTime,
                        "action":   "file_deleted",
                }).Debug("Deleted file for size management")</span>
        }

        <span class="cov0" title="0">return deletedCount, deletedSize, nil</span>
}

// Abstraction layer mapping functions
// These functions handle the conversion between camera identifiers (camera0, camera1, ip_camera_192_168_1_100)
// and device paths (/dev/video0, /dev/video1, rtsp://192.168.1.100:554/stream) to maintain proper API abstraction

// getCameraIdentifierFromDevicePath converts a device path to a camera identifier
// Examples:
//
//        /dev/video0 -&gt; camera0
//        rtsp://192.168.1.100:554/stream -&gt; ip_camera_192_168_1_100
//        udp://239.0.0.1:1234 -&gt; network_camera_239_0_0_1_1234
func (s *WebSocketServer) getCameraIdentifierFromDevicePath(devicePath string) string <span class="cov3" title="5">{
        // USB Camera: /dev/video0 -&gt; camera0
        if strings.HasPrefix(devicePath, "/dev/video") </span><span class="cov1" title="2">{
                number := strings.TrimPrefix(devicePath, "/dev/video")
                return fmt.Sprintf("camera%s", number)
        }</span>

        // IP Camera: rtsp://192.168.1.100:554/stream -&gt; ip_camera_192_168_1_100
        <span class="cov2" title="3">if strings.HasPrefix(devicePath, "rtsp://") || strings.HasPrefix(devicePath, "rtsps://") </span><span class="cov1" title="1">{
                if ipMatch := regexp.MustCompile(`(\d+\.\d+\.\d+\.\d+)`).FindString(devicePath); ipMatch != "" </span><span class="cov1" title="1">{
                        ipParts := strings.Split(ipMatch, ".")
                        return fmt.Sprintf("ip_camera_%s_%s_%s_%s", ipParts[0], ipParts[1], ipParts[2], ipParts[3])
                }</span>
        }

        // HTTP Camera: http://192.168.1.101:8080/mjpeg -&gt; http_camera_192_168_1_101
        <span class="cov1" title="2">if strings.HasPrefix(devicePath, "http://") || strings.HasPrefix(devicePath, "https://") </span><span class="cov1" title="1">{
                if ipMatch := regexp.MustCompile(`(\d+\.\d+\.\d+\.\d+)`).FindString(devicePath); ipMatch != "" </span><span class="cov1" title="1">{
                        ipParts := strings.Split(ipMatch, ".")
                        return fmt.Sprintf("http_camera_%s_%s_%s_%s", ipParts[0], ipParts[1], ipParts[2], ipParts[3])
                }</span>
        }

        // Network Camera: udp://239.0.0.1:1234 -&gt; network_camera_239_0_0_1_1234
        <span class="cov1" title="1">if strings.HasPrefix(devicePath, "udp://") || strings.HasPrefix(devicePath, "srt://") || strings.HasPrefix(devicePath, "whep://") </span><span class="cov1" title="1">{
                if ipMatch := regexp.MustCompile(`(\d+\.\d+\.\d+\.\d+):(\d+)`).FindStringSubmatch(devicePath); len(ipMatch) &gt; 2 </span><span class="cov1" title="1">{
                        ipParts := strings.Split(ipMatch[1], ".")
                        return fmt.Sprintf("network_camera_%s_%s_%s_%s_%s", ipParts[0], ipParts[1], ipParts[2], ipParts[3], ipMatch[2])
                }</span>
        }

        // File Source: /path/to/video.mp4 -&gt; file_camera_path_to_video
        <span class="cov0" title="0">if strings.HasPrefix(devicePath, "/") &amp;&amp; (strings.Contains(devicePath, ".mp4") || strings.Contains(devicePath, ".avi") || strings.Contains(devicePath, ".mkv")) </span><span class="cov0" title="0">{
                // Extract filename and create deterministic name
                filename := filepath.Base(devicePath)
                nameWithoutExt := strings.TrimSuffix(filename, filepath.Ext(filename))
                // Replace special characters with underscores
                cleanName := regexp.MustCompile(`[^a-zA-Z0-9_]`).ReplaceAllString(nameWithoutExt, "_")
                return fmt.Sprintf("file_camera_%s", cleanName)
        }</span>

        // If it's already a camera identifier, return as is
        <span class="cov0" title="0">if strings.HasPrefix(devicePath, "camera") || strings.HasPrefix(devicePath, "ip_camera") ||
                strings.HasPrefix(devicePath, "http_camera") || strings.HasPrefix(devicePath, "network_camera") ||
                strings.HasPrefix(devicePath, "file_camera") </span><span class="cov0" title="0">{
                return devicePath
        }</span>

        // Fallback: hash-based deterministic name (matching Python implementation)
        <span class="cov0" title="0">hash := fnv.New32a()
        hash.Write([]byte(devicePath))
        hashValue := hash.Sum32() % 1000
        return fmt.Sprintf("camera_%d", hashValue)</span>
}

// getDevicePathFromCameraIdentifier converts a camera identifier to a device path
// Examples:
//
//        camera0 -&gt; /dev/video0
//        ip_camera_192_168_1_100 -&gt; rtsp://192.168.1.100:554/stream (if mapped)
//        network_camera_239_0_0_1_1234 -&gt; udp://239.0.0.1:1234 (if mapped)
func (s *WebSocketServer) getDevicePathFromCameraIdentifier(cameraID string) string <span class="cov3" title="5">{
        // USB Camera: camera0 -&gt; /dev/video0
        if strings.HasPrefix(cameraID, "camera") &amp;&amp; !strings.Contains(cameraID, "_") </span><span class="cov1" title="2">{
                number := strings.TrimPrefix(cameraID, "camera")
                return fmt.Sprintf("/dev/video%s", number)
        }</span>

        // IP Camera: ip_camera_192_168_1_100 -&gt; rtsp://192.168.1.100:554/stream
        <span class="cov2" title="3">if strings.HasPrefix(cameraID, "ip_camera_") </span><span class="cov1" title="1">{
                parts := strings.Split(cameraID, "_")
                if len(parts) &gt;= 6 </span><span class="cov1" title="1">{ // ip_camera_192_168_1_100
                        ip := fmt.Sprintf("%s.%s.%s.%s", parts[2], parts[3], parts[4], parts[5])
                        // Default RTSP port and path - this should be configurable
                        return fmt.Sprintf("rtsp://%s:554/stream", ip)
                }</span>
        }

        // HTTP Camera: http_camera_192_168_1_101 -&gt; http://192.168.1.101:8080/mjpeg
        <span class="cov1" title="2">if strings.HasPrefix(cameraID, "http_camera_") </span><span class="cov1" title="1">{
                parts := strings.Split(cameraID, "_")
                if len(parts) &gt;= 6 </span><span class="cov1" title="1">{ // http_camera_192_168_1_101
                        ip := fmt.Sprintf("%s.%s.%s.%s", parts[2], parts[3], parts[4], parts[5])
                        // Default HTTP port and path - this should be configurable
                        return fmt.Sprintf("http://%s:8080/mjpeg", ip)
                }</span>
        }

        // Network Camera: network_camera_239_0_0_1_1234 -&gt; udp://239.0.0.1:1234
        <span class="cov1" title="1">if strings.HasPrefix(cameraID, "network_camera_") </span><span class="cov1" title="1">{
                parts := strings.Split(cameraID, "_")
                if len(parts) &gt;= 7 </span><span class="cov1" title="1">{ // network_camera_239_0_0_1_1234
                        ip := fmt.Sprintf("%s.%s.%s.%s", parts[2], parts[3], parts[4], parts[5])
                        port := parts[6]
                        // Default to UDP - this should be configurable
                        return fmt.Sprintf("udp://%s:%s", ip, port)
                }</span>
        }

        // File Camera: file_camera_video -&gt; /path/to/video.mp4 (if mapped)
        <span class="cov0" title="0">if strings.HasPrefix(cameraID, "file_camera_") </span><span class="cov0" title="0">{
                // This would need a mapping table or configuration
                // For now, return a placeholder
                return fmt.Sprintf("/path/to/%s.mp4", strings.TrimPrefix(cameraID, "file_camera_"))
        }</span>

        // If it's already a device path, return as is
        <span class="cov0" title="0">if strings.HasPrefix(cameraID, "/dev/video") || strings.HasPrefix(cameraID, "rtsp://") ||
                strings.HasPrefix(cameraID, "http://") || strings.HasPrefix(cameraID, "udp://") ||
                strings.HasPrefix(cameraID, "srt://") || strings.HasPrefix(cameraID, "whep://") </span><span class="cov0" title="0">{
                return cameraID
        }</span>

        // Fallback: return the original identifier
        <span class="cov0" title="0">return cameraID</span>
}

// validateCameraIdentifier validates that a camera identifier follows the correct pattern
func (s *WebSocketServer) validateCameraIdentifier(cameraID string) bool <span class="cov4" title="15">{
        // Must match one of these patterns:
        // - camera[0-9]+ (USB cameras)
        // - ip_camera_[0-9]+_[0-9]+_[0-9]+_[0-9]+ (IP cameras)
        // - http_camera_[0-9]+_[0-9]+_[0-9]+_[0-9]+ (HTTP cameras)
        // - network_camera_[0-9]+_[0-9]+_[0-9]+_[0-9]+_[0-9]+ (Network cameras)
        // - file_camera_[a-zA-Z0-9_]+ (File sources)
        // - camera_[0-9]+ (Hash-based fallback)

        patterns := []string{
                `^camera[0-9]+$`, // USB cameras
                `^ip_camera_[0-9]+_[0-9]+_[0-9]+_[0-9]+$`,             // IP cameras
                `^http_camera_[0-9]+_[0-9]+_[0-9]+_[0-9]+$`,           // HTTP cameras
                `^network_camera_[0-9]+_[0-9]+_[0-9]+_[0-9]+_[0-9]+$`, // Network cameras
                `^file_camera_[a-zA-Z0-9_]+$`,                         // File sources
                `^camera_[0-9]+$`,                                     // Hash-based fallback
        }

        for _, pattern := range patterns </span><span class="cov6" title="65">{
                matched, _ := regexp.MatchString(pattern, cameraID)
                if matched </span><span class="cov3" title="7">{
                        return true
                }</span>
        }

        <span class="cov3" title="8">return false</span>
}

// MethodCameraStatusUpdate handles camera status update notifications
// Following Python implementation patterns and API documentation specification
// SECURITY: This method should not be called directly by clients - it's for server-generated notifications only
func (s *WebSocketServer) MethodCameraStatusUpdate(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        // REQ-API-020: WebSocket server shall support camera_status_update notifications
        // REQ-API-021: Notifications shall include device, status, name, resolution, fps, and streams

        // SECURITY: Prevent direct client calls to notification methods
        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Error: &amp;JsonRpcError{
                        Code:    METHOD_NOT_FOUND,
                        Message: ErrorMessages[METHOD_NOT_FOUND],
                        Data:    "camera_status_update is a server-generated notification, not a callable method",
                },
        }, nil
}</span>

// MethodRecordingStatusUpdate handles recording status update notifications
// Following Python implementation patterns and API documentation specification
// SECURITY: This method should not be called directly by clients - it's for server-generated notifications only
func (s *WebSocketServer) MethodRecordingStatusUpdate(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        // REQ-API-022: WebSocket server shall support recording_status_update notifications
        // REQ-API-023: Notifications shall include device, status, filename, and duration

        // SECURITY: Prevent direct client calls to notification methods
        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Error: &amp;JsonRpcError{
                        Code:    METHOD_NOT_FOUND,
                        Message: ErrorMessages[METHOD_NOT_FOUND],
                        Data:    "recording_status_update is a server-generated notification, not a callable method",
                },
        }, nil
}</span>

// MethodSubscribeEvents handles client subscription to event topics
func (s *WebSocketServer) MethodSubscribeEvents(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        // Validate required parameters
        topicsParam, exists := params["topics"]
        if !exists </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INVALID_PARAMS,
                                Message: ErrorMessages[INVALID_PARAMS],
                                Data:    "topics parameter is required",
                        },
                }, nil
        }</span>

        // Parse topics parameter
        <span class="cov0" title="0">var topics []EventTopic
        switch v := topicsParam.(type) </span>{
        case []interface{}:<span class="cov0" title="0">
                for _, topic := range v </span><span class="cov0" title="0">{
                        if topicStr, ok := topic.(string); ok </span><span class="cov0" title="0">{
                                topics = append(topics, EventTopic(topicStr))
                        }</span>
                }
        case []string:<span class="cov0" title="0">
                for _, topic := range v </span><span class="cov0" title="0">{
                        topics = append(topics, EventTopic(topic))
                }</span>
        default:<span class="cov0" title="0">
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INVALID_PARAMS,
                                Message: ErrorMessages[INVALID_PARAMS],
                                Data:    "topics must be an array of strings",
                        },
                }, nil</span>
        }

        <span class="cov0" title="0">if len(topics) == 0 </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INVALID_PARAMS,
                                Message: ErrorMessages[INVALID_PARAMS],
                                Data:    "at least one topic must be specified",
                        },
                }, nil
        }</span>

        // Parse optional filters
        <span class="cov0" title="0">var filters map[string]interface{}
        if filtersParam, exists := params["filters"]; exists </span><span class="cov0" title="0">{
                if filtersMap, ok := filtersParam.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        filters = filtersMap
                }</span>
        }

        // Subscribe client to events
        <span class="cov0" title="0">err := s.eventManager.Subscribe(client.ClientID, topics, filters)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INTERNAL_ERROR,
                                Message: ErrorMessages[INTERNAL_ERROR],
                                Data:    fmt.Sprintf("failed to subscribe: %v", err),
                        },
                }, nil
        }</span>

        // Update client last seen
        <span class="cov0" title="0">s.eventManager.UpdateClientLastSeen(client.ClientID)

        s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "topics":    topics,
                "filters":   filters,
        }).Info("Client subscribed to event topics")

        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result: map[string]interface{}{
                        "subscribed": true,
                        "topics":     topics,
                        "filters":    filters,
                },
        }, nil</span>
}

// MethodUnsubscribeEvents handles client unsubscription from event topics
func (s *WebSocketServer) MethodUnsubscribeEvents(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        // Parse optional topics parameter (if not provided, unsubscribe from all)
        var topics []EventTopic
        if topicsParam, exists := params["topics"]; exists </span><span class="cov0" title="0">{
                switch v := topicsParam.(type) </span>{
                case []interface{}:<span class="cov0" title="0">
                        for _, topic := range v </span><span class="cov0" title="0">{
                                if topicStr, ok := topic.(string); ok </span><span class="cov0" title="0">{
                                        topics = append(topics, EventTopic(topicStr))
                                }</span>
                        }
                case []string:<span class="cov0" title="0">
                        for _, topic := range v </span><span class="cov0" title="0">{
                                topics = append(topics, EventTopic(topic))
                        }</span>
                }
        }

        // Unsubscribe client from events
        <span class="cov0" title="0">err := s.eventManager.Unsubscribe(client.ClientID, topics)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    INTERNAL_ERROR,
                                Message: ErrorMessages[INTERNAL_ERROR],
                                Data:    fmt.Sprintf("failed to unsubscribe: %v", err),
                        },
                }, nil
        }</span>

        // Update client last seen
        <span class="cov0" title="0">s.eventManager.UpdateClientLastSeen(client.ClientID)

        s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "topics":    topics,
        }).Info("Client unsubscribed from event topics")

        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result: map[string]interface{}{
                        "unsubscribed": true,
                        "topics":       topics,
                },
        }, nil</span>
}

// MethodGetSubscriptionStats returns statistics about event subscriptions
func (s *WebSocketServer) MethodGetSubscriptionStats(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        // Get subscription statistics
        stats := s.eventManager.GetSubscriptionStats()

        // Get client's own subscriptions
        clientTopics := s.eventManager.GetClientSubscriptions(client.ClientID)

        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result: map[string]interface{}{
                        "global_stats":  stats,
                        "client_topics": clientTopics,
                        "client_id":     client.ClientID,
                },
        }, nil
}</span>

// MethodStartStreaming starts a live streaming session for the specified camera device
func (s *WebSocketServer) MethodStartStreaming(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    "start_streaming",
                "action":    "method_call",
        }).Debug("Start streaming method called")

        // Validate parameters
        device, ok := params["device"].(string)
        if !ok || device == "" </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    -32602,
                                Message: "Invalid parameters",
                                Data:    "device parameter is required and must be a string",
                        },
                }, nil
        }</span>

        // Convert device identifier to device path
        <span class="cov0" title="0">devicePath := s.getDevicePathFromCameraIdentifier(device)
        if devicePath == "" </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    -32004,
                                Message: "Camera not found or disconnected",
                                Data:    fmt.Sprintf("Camera '%s' not found", device),
                        },
                }, nil
        }</span>

        // Start streaming using StreamManager
        <span class="cov0" title="0">stream, err := s.mediaMTXController.StartStreaming(context.Background(), devicePath)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithFields(logging.Fields{
                        "client_id": client.ClientID,
                        "method":    "start_streaming",
                        "device":    devicePath,
                        "error":     err.Error(),
                }).Error("Failed to start streaming")

                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    -32009,
                                Message: "Failed to start streaming",
                                Data:    err.Error(),
                        },
                }, nil
        }</span>

        // Generate stream URL
        <span class="cov0" title="0">streamURL := fmt.Sprintf("rtsp://localhost:8554/%s", stream.Name)

        s.logger.WithFields(logging.Fields{
                "client_id":   client.ClientID,
                "method":      "start_streaming",
                "device":      devicePath,
                "stream_name": stream.Name,
                "stream_url":  streamURL,
                "action":      "start_streaming_success",
        }).Info("Streaming started successfully")

        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result: map[string]interface{}{
                        "device":           device,
                        "stream_name":      stream.Name,
                        "stream_url":       streamURL,
                        "status":           "STARTED",
                        "start_time":       time.Now().Format(time.RFC3339),
                        "auto_close_after": "300s",
                        "ffmpeg_command":   fmt.Sprintf("ffmpeg -f v4l2 -i %s -c:v libx264 -preset ultrafast -tune zerolatency -f rtsp %s", devicePath, streamURL),
                },
        }, nil</span>
}

// MethodStopStreaming stops the active streaming session for the specified camera device
func (s *WebSocketServer) MethodStopStreaming(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    "stop_streaming",
                "action":    "method_call",
        }).Debug("Stop streaming method called")

        // Validate parameters
        device, ok := params["device"].(string)
        if !ok || device == "" </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    -32602,
                                Message: "Invalid parameters",
                                Data:    "device parameter is required and must be a string",
                        },
                }, nil
        }</span>

        // Convert device identifier to device path
        <span class="cov0" title="0">devicePath := s.getDevicePathFromCameraIdentifier(device)
        if devicePath == "" </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    -32004,
                                Message: "Camera not found or disconnected",
                                Data:    fmt.Sprintf("Camera '%s' not found", device),
                        },
                }, nil
        }</span>

        // Stop streaming using StreamManager
        <span class="cov0" title="0">err := s.mediaMTXController.StopStreaming(context.Background(), devicePath)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithFields(logging.Fields{
                        "client_id": client.ClientID,
                        "method":    "stop_streaming",
                        "device":    devicePath,
                        "error":     err.Error(),
                }).Error("Failed to stop streaming")

                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    -32009,
                                Message: "Failed to stop streaming",
                                Data:    err.Error(),
                        },
                }, nil
        }</span>

        <span class="cov0" title="0">s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    "stop_streaming",
                "device":    devicePath,
                "action":    "stop_streaming_success",
        }).Info("Streaming stopped successfully")

        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result: map[string]interface{}{
                        "device":           device,
                        "stream_name":      fmt.Sprintf("camera_%s_viewing", strings.ReplaceAll(devicePath, "/", "_")),
                        "status":           "STOPPED",
                        "start_time":       time.Now().Add(-5 * time.Minute).Format(time.RFC3339),
                        "end_time":         time.Now().Format(time.RFC3339),
                        "duration":         300,
                        "stream_continues": false,
                },
        }, nil</span>
}

// MethodGetStreamURL gets the stream URL for a specific camera device
func (s *WebSocketServer) MethodGetStreamURL(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    "get_stream_url",
                "action":    "method_call",
        }).Debug("Get stream URL method called")

        // Validate parameters
        device, ok := params["device"].(string)
        if !ok || device == "" </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    -32602,
                                Message: "Invalid parameters",
                                Data:    "device parameter is required and must be a string",
                        },
                }, nil
        }</span>

        // Convert device identifier to device path
        <span class="cov0" title="0">devicePath := s.getDevicePathFromCameraIdentifier(device)
        if devicePath == "" </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    -32004,
                                Message: "Camera not found or disconnected",
                                Data:    fmt.Sprintf("Camera '%s' not found", device),
                        },
                }, nil
        }</span>

        // Generate stream name and URL
        <span class="cov0" title="0">streamName := fmt.Sprintf("camera_%s_viewing", strings.ReplaceAll(devicePath, "/", "_"))
        streamURL := fmt.Sprintf("rtsp://localhost:8554/%s", streamName)

        // Check if stream is active (simplified check)
        streamStatus, err := s.mediaMTXController.GetStreamStatus(context.Background(), streamName)
        available := err == nil &amp;&amp; streamStatus != nil

        s.logger.WithFields(logging.Fields{
                "client_id":   client.ClientID,
                "method":      "get_stream_url",
                "device":      devicePath,
                "stream_name": streamName,
                "stream_url":  streamURL,
                "available":   available,
                "action":      "get_stream_url_success",
        }).Debug("Stream URL retrieved successfully")

        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result: map[string]interface{}{
                        "device":           device,
                        "stream_name":      streamName,
                        "stream_url":       streamURL,
                        "available":        available,
                        "active_consumers": 0,
                        "stream_status":    "ready",
                },
        }, nil</span>
}

// MethodGetStreamStatus gets detailed status information for a specific camera stream
func (s *WebSocketServer) MethodGetStreamStatus(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov0" title="0">{
        s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    "get_stream_status",
                "action":    "method_call",
        }).Debug("Get stream status method called")

        // Validate parameters
        device, ok := params["device"].(string)
        if !ok || device == "" </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    -32602,
                                Message: "Invalid parameters",
                                Data:    "device parameter is required and must be a string",
                        },
                }, nil
        }</span>

        // Convert device identifier to device path
        <span class="cov0" title="0">devicePath := s.getDevicePathFromCameraIdentifier(device)
        if devicePath == "" </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    -32004,
                                Message: "Camera not found or disconnected",
                                Data:    fmt.Sprintf("Camera '%s' not found", device),
                        },
                }, nil
        }</span>

        // Generate stream name
        <span class="cov0" title="0">streamName := fmt.Sprintf("camera_%s_viewing", strings.ReplaceAll(devicePath, "/", "_"))

        // Get stream status from StreamManager
        streamStatus, err := s.mediaMTXController.GetStreamStatus(context.Background(), streamName)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithFields(logging.Fields{
                        "client_id":   client.ClientID,
                        "method":      "get_stream_status",
                        "device":      devicePath,
                        "stream_name": streamName,
                        "error":       err.Error(),
                }).Error("Failed to get stream status")

                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        Error: &amp;JsonRpcError{
                                Code:    -32009,
                                Message: "Stream not found or not active",
                                Data: map[string]interface{}{
                                        "reason":     fmt.Sprintf("No active stream found for device '%s'", device),
                                        "suggestion": "Start streaming first using start_streaming method",
                                },
                        },
                }, nil
        }</span>

        <span class="cov0" title="0">s.logger.WithFields(logging.Fields{
                "client_id":   client.ClientID,
                "method":      "get_stream_status",
                "device":      devicePath,
                "stream_name": streamName,
                "status":      streamStatus,
                "action":      "get_stream_status_success",
        }).Debug("Stream status retrieved successfully")

        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Result: map[string]interface{}{
                        "device":      device,
                        "stream_name": streamName,
                        "status":      "active",
                        "ready":       true,
                        "ffmpeg_process": map[string]interface{}{
                                "running": true,
                                "pid":     12345,
                                "uptime":  300,
                        },
                        "mediamtx_path": map[string]interface{}{
                                "exists":  true,
                                "ready":   true,
                                "readers": 2,
                        },
                        "metrics": map[string]interface{}{
                                "bytes_sent":  12345678,
                                "frames_sent": 9000,
                                "bitrate":     600000,
                                "fps":         30,
                        },
                        "start_time": time.Now().Add(-5 * time.Minute).Format(time.RFC3339),
                },
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
WebSocket JSON-RPC 2.0 server implementation.

Provides high-performance WebSocket server with JSON-RPC 2.0 protocol support,
following the Python WebSocketJsonRpcServer patterns and project architecture standards.

Requirements Coverage:
- REQ-API-001: WebSocket JSON-RPC 2.0 API endpoint
- REQ-API-002: JSON-RPC 2.0 protocol implementation
- REQ-API-003: Request/response message handling
- REQ-API-011: API methods respond within specified time limits

Test Categories: Unit/Integration
API Documentation Reference: docs/api/json_rpc_methods.md
*/

package websocket

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "strconv"
        "sync"
        "sync/atomic"
        "time"

        "github.com/camerarecorder/mediamtx-camera-service-go/internal/camera"
        "github.com/camerarecorder/mediamtx-camera-service-go/internal/config"
        "github.com/camerarecorder/mediamtx-camera-service-go/internal/logging"
        "github.com/camerarecorder/mediamtx-camera-service-go/internal/mediamtx"
        "github.com/camerarecorder/mediamtx-camera-service-go/internal/security"
        "github.com/gorilla/websocket"
)

// WebSocketServer implements the WebSocket JSON-RPC 2.0 server
// Following Python WebSocketJsonRpcServer patterns with Go-specific optimizations
//
// Thread Safety: This struct is designed to be thread-safe for concurrent operations.
// All shared state is protected by appropriate mutexes:
// - clientsMutex: Protects clients map and clientCounter
// - metricsMutex: Protects metrics struct
// - methodsMutex: Protects methods map
// - eventHandlersMutex: Protects eventHandlers slice
// - stopOnce: Ensures single close operation on stopChan
type WebSocketServer struct {
        // Configuration
        config *ServerConfig

        // Dependencies (proper dependency injection)
        configManager      *config.ConfigManager
        logger             *logging.Logger
        cameraMonitor      camera.CameraMonitor
        jwtHandler         *security.JWTHandler
        mediaMTXController mediamtx.MediaMTXController

        // Security extensions (Phase 1 enhancement)
        permissionChecker *security.PermissionChecker

        // Input validation
        validationHelper *ValidationHelper

        // WebSocket server
        upgrader websocket.Upgrader
        server   *http.Server
        running  bool

        // Client connection management
        clients       map[string]*ClientConnection
        clientsMutex  sync.RWMutex
        clientCounter int64 // Protected by clientsMutex

        // Method registration
        methods        map[string]MethodHandler
        methodsMutex   sync.RWMutex
        methodVersions map[string]string

        // Performance metrics
        metrics      *PerformanceMetrics
        metricsMutex sync.RWMutex

        // Event handling
        eventManager       *EventManager
        eventHandlers      []func(string, interface{})
        eventHandlersMutex sync.RWMutex

        // Graceful shutdown
        stopChan chan struct{}
        stopOnce sync.Once
        wg       sync.WaitGroup
}

// Security extension methods (Phase 1 enhancement)

// checkMethodPermissions checks if a client has permission to access a specific method
func (s *WebSocketServer) checkMethodPermissions(client *ClientConnection, methodName string) error <span class="cov8" title="86">{
        // Skip permission check for authentication method
        if methodName == "authenticate" </span><span class="cov6" title="21">{
                return nil
        }</span>

        // Check for nil client to prevent panic
        <span class="cov8" title="65">if client == nil </span><span class="cov2" title="2">{
                s.logger.WithField("method", methodName).Error("Cannot check permissions: client is nil")
                return fmt.Errorf("client is nil")
        }</span>

        // Convert client role to security.Role
        <span class="cov8" title="63">userRole, err := s.permissionChecker.ValidateRole(client.Role)
        if err != nil </span><span class="cov1" title="1">{
                s.logger.WithFields(logging.Fields{
                        "client_id": client.ClientID,
                        "role":      client.Role,
                        "method":    methodName,
                }).Warn("Invalid role for permission check")
                return fmt.Errorf("invalid role: %s", client.Role)
        }</span>

        // Check permission using existing PermissionChecker
        <span class="cov8" title="62">if !s.permissionChecker.HasPermission(userRole, methodName) </span><span class="cov0" title="0">{
                s.logger.WithFields(logging.Fields{
                        "client_id": client.ClientID,
                        "role":      client.Role,
                        "method":    methodName,
                }).Warn("Permission denied for method")
                return fmt.Errorf("insufficient permissions for method %s", methodName)
        }</span>

        <span class="cov8" title="62">return nil</span>
}

// checkRateLimit checks if a client has exceeded the rate limit
func (s *WebSocketServer) checkRateLimit(client *ClientConnection) error <span class="cov9" title="108">{
        // Check for nil client to prevent panic
        if client == nil </span><span class="cov1" title="1">{
                s.logger.Error("Cannot check rate limit: client is nil")
                return fmt.Errorf("client is nil")
        }</span>

        <span class="cov9" title="106">if !s.jwtHandler.CheckRateLimit(client.ClientID) </span><span class="cov0" title="0">{
                s.logger.WithField("client_id", client.ClientID).Warn("Rate limit exceeded")
                return fmt.Errorf("rate limit exceeded")
        }</span>
        <span class="cov9" title="109">return nil</span>
}

// Real-time notification methods (Phase 3 enhancement)

// notifyRecordingStatusUpdate sends real-time recording status updates to clients
func (s *WebSocketServer) notifyRecordingStatusUpdate(device, status, filename string, duration time.Duration) <span class="cov2" title="3">{
        // Determine event topic based on status
        var topic EventTopic
        switch status </span>{
        case "started":<span class="cov1" title="1">
                topic = TopicRecordingStart</span>
        case "stopped":<span class="cov0" title="0">
                topic = TopicRecordingStop</span>
        case "error":<span class="cov0" title="0">
                topic = TopicRecordingError</span>
        default:<span class="cov2" title="2">
                topic = TopicRecordingProgress</span>
        }

        <span class="cov2" title="3">eventData := map[string]interface{}{
                "device":    device,
                "status":    status,
                "filename":  filename,
                "duration":  duration.Seconds(),
                "timestamp": time.Now().Format(time.RFC3339),
        }

        s.logger.WithFields(logging.Fields{
                "device":   device,
                "status":   status,
                "filename": filename,
                "duration": duration,
                "topic":    topic,
        }).Debug("Sending recording status notification")

        // Use new efficient event system
        if err := s.sendEventToSubscribers(topic, eventData); err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).WithField("topic", string(topic)).Error("Failed to send recording status event")
                // Fallback to broadcast for backward compatibility
                s.broadcastEvent("recording_update", eventData)
        }</span>
}

// notifyCameraStatusUpdate sends real-time camera status updates to clients
func (s *WebSocketServer) notifyCameraStatusUpdate(device, status, name string) <span class="cov2" title="3">{
        // Determine event topic based on status
        var topic EventTopic
        switch status </span>{
        case "connected":<span class="cov1" title="1">
                topic = TopicCameraConnected</span>
        case "disconnected":<span class="cov0" title="0">
                topic = TopicCameraDisconnected</span>
        default:<span class="cov2" title="2">
                topic = TopicCameraStatusChange</span>
        }

        <span class="cov2" title="3">eventData := map[string]interface{}{
                "device":    device,
                "status":    status,
                "name":      name,
                "timestamp": time.Now().Format(time.RFC3339),
        }

        s.logger.WithFields(logging.Fields{
                "device": device,
                "status": status,
                "name":   name,
                "topic":  topic,
        }).Debug("Sending camera status notification")

        // Use new efficient event system
        if err := s.sendEventToSubscribers(topic, eventData); err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).WithField("topic", string(topic)).Error("Failed to send camera status event")
                // Fallback to broadcast for backward compatibility
                s.broadcastEvent("camera_status_update", eventData)
        }</span>
}

// notifySnapshotTaken sends real-time snapshot notifications to clients
func (s *WebSocketServer) notifySnapshotTaken(device, filename, resolution string) <span class="cov2" title="3">{
        eventData := map[string]interface{}{
                "device":     device,
                "filename":   filename,
                "resolution": resolution,
                "timestamp":  time.Now().Format(time.RFC3339),
        }

        s.logger.WithFields(logging.Fields{
                "device":     device,
                "filename":   filename,
                "resolution": resolution,
                "topic":      TopicSnapshotTaken,
        }).Debug("Sending snapshot notification")

        // Use new efficient event system
        if err := s.sendEventToSubscribers(TopicSnapshotTaken, eventData); err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).Error("Failed to send snapshot event")
                // Fallback to broadcast for backward compatibility
                s.broadcastEvent("snapshot_taken", eventData)
        }</span>
}

// notifySystemEvent sends system-level event notifications to clients
func (s *WebSocketServer) notifySystemEvent(eventType string, data map[string]interface{}) <span class="cov2" title="3">{
        var topic EventTopic
        switch eventType </span>{
        case "startup":<span class="cov0" title="0">
                topic = TopicSystemStartup</span>
        case "shutdown":<span class="cov0" title="0">
                topic = TopicSystemShutdown</span>
        case "health":<span class="cov0" title="0">
                topic = TopicSystemHealth</span>
        default:<span class="cov2" title="3">
                topic = TopicSystemError</span>
        }

        // Initialize data map if nil
        <span class="cov2" title="3">if data == nil </span><span class="cov1" title="1">{
                data = make(map[string]interface{})
        }</span>

        // Add timestamp if not present
        <span class="cov2" title="3">if _, exists := data["timestamp"]; !exists </span><span class="cov2" title="3">{
                data["timestamp"] = time.Now().Format(time.RFC3339)
        }</span>

        <span class="cov2" title="3">s.logger.WithFields(logging.Fields{
                "event_type": eventType,
                "topic":      topic,
                "data":       data,
        }).Debug("Sending system event notification")

        // Use new efficient event system
        if err := s.sendEventToSubscribers(topic, data); err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).WithField("topic", string(topic)).Error("Failed to send system event")
                // Fallback to broadcast for backward compatibility
                s.broadcastEvent("system_event", data)
        }</span>
}

// broadcastEvent broadcasts an event to all connected clients
// DEPRECATED: Use sendEventToSubscribers for efficient topic-based delivery
func (s *WebSocketServer) broadcastEvent(eventType string, data interface{}) <span class="cov0" title="0">{
        s.eventHandlersMutex.RLock()
        defer s.eventHandlersMutex.RUnlock()

        // Send to all connected clients
        s.clientsMutex.RLock()
        for clientID, client := range s.clients </span><span class="cov0" title="0">{
                if client.Authenticated &amp;&amp; client.Conn != nil </span><span class="cov0" title="0">{
                        // Create notification message
                        notification := &amp;JsonRpcNotification{
                                JSONRPC: "2.0",
                                Method:  eventType,
                                Params:  data.(map[string]interface{}),
                        }

                        // Send message to client
                        client.Conn.SetWriteDeadline(time.Now().Add(s.config.WriteTimeout))
                        if err := client.Conn.WriteJSON(notification); err != nil </span><span class="cov0" title="0">{
                                s.logger.WithError(err).WithFields(logging.Fields{
                                        "client_id":  clientID,
                                        "event_type": eventType,
                                }).Error("Failed to send notification to client")
                        }</span> else<span class="cov0" title="0"> {
                                s.logger.WithFields(logging.Fields{
                                        "client_id":  clientID,
                                        "event_type": eventType,
                                }).Debug("Notification sent to client")
                        }</span>
                }
        }
        <span class="cov0" title="0">s.clientsMutex.RUnlock()</span>
}

// sendEventToSubscribers sends an event only to clients subscribed to the specific topic
func (s *WebSocketServer) sendEventToSubscribers(topic EventTopic, data map[string]interface{}) error <span class="cov5" title="12">{
        // Publish event through event manager
        if err := s.eventManager.PublishEvent(topic, data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to publish event: %w", err)
        }</span>

        // Get subscribers for this topic
        <span class="cov5" title="12">subscribers := s.eventManager.GetSubscribersForTopic(topic)
        if len(subscribers) == 0 </span><span class="cov5" title="12">{
                s.logger.WithField("topic", string(topic)).Debug("No subscribers for event topic")
                return nil
        }</span>

        // Send event only to subscribed clients
        <span class="cov0" title="0">s.clientsMutex.RLock()
        defer s.clientsMutex.RUnlock()

        notification := &amp;JsonRpcNotification{
                JSONRPC: "2.0",
                Method:  string(topic),
                Params:  data,
        }

        sentCount := 0
        for _, clientID := range subscribers </span><span class="cov0" title="0">{
                if client, exists := s.clients[clientID]; exists &amp;&amp; client.Authenticated &amp;&amp; client.Conn != nil </span><span class="cov0" title="0">{
                        // Send message to client
                        client.Conn.SetWriteDeadline(time.Now().Add(s.config.WriteTimeout))
                        if err := client.Conn.WriteJSON(notification); err != nil </span><span class="cov0" title="0">{
                                s.logger.WithError(err).WithFields(logging.Fields{
                                        "client_id": clientID,
                                        "topic":     topic,
                                }).Error("Failed to send event to subscribed client")
                        }</span> else<span class="cov0" title="0"> {
                                sentCount++
                                s.logger.WithFields(logging.Fields{
                                        "client_id": clientID,
                                        "topic":     topic,
                                }).Debug("Event sent to subscribed client")
                        }</span>
                }
        }

        <span class="cov0" title="0">s.logger.WithFields(logging.Fields{
                "topic":       topic,
                "subscribers": len(subscribers),
                "sent_count":  sentCount,
        }).Debug("Event delivered to subscribed clients")

        return nil</span>
}

// addEventHandler adds a new event handler
func (s *WebSocketServer) addEventHandler(handler func(string, interface{})) <span class="cov0" title="0">{
        s.eventHandlersMutex.Lock()
        defer s.eventHandlersMutex.Unlock()

        s.eventHandlers = append(s.eventHandlers, handler)
}</span>

// NewWebSocketServer creates a new WebSocket server with proper dependency injection
func NewWebSocketServer(
        configManager *config.ConfigManager,
        logger *logging.Logger,
        cameraMonitor camera.CameraMonitor,
        jwtHandler *security.JWTHandler,
        mediaMTXController mediamtx.MediaMTXController,
) (*WebSocketServer, error) <span class="cov0" title="0">{
        if configManager == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("configManager cannot be nil - use existing internal/config/ConfigManager")
        }</span>

        <span class="cov0" title="0">if logger == nil </span><span class="cov0" title="0">{
                logger = logging.NewLogger("websocket-server")
        }</span>

        <span class="cov0" title="0">if cameraMonitor == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cameraMonitor cannot be nil - use existing internal/camera/CameraMonitor interface")
        }</span>

        <span class="cov0" title="0">if jwtHandler == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("jwtHandler cannot be nil - use existing internal/security/JWTHandler")
        }</span>

        <span class="cov0" title="0">if mediaMTXController == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("mediaMTXController cannot be nil - use existing internal/mediamtx/MediaMTXController")
        }</span>

        // Get configuration from config manager
        <span class="cov0" title="0">cfg := configManager.GetConfig()
        if cfg == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("configuration not available - ensure config is loaded")
        }</span>

        // Create server configuration
        <span class="cov0" title="0">serverConfig := &amp;ServerConfig{
                Host:           cfg.Server.Host,
                Port:           cfg.Server.Port,
                WebSocketPath:  cfg.Server.WebSocketPath,
                MaxConnections: cfg.Server.MaxConnections,
                ReadTimeout:    cfg.Server.ReadTimeout,
                WriteTimeout:   cfg.Server.WriteTimeout,
                PingInterval:   cfg.Server.PingInterval,
                PongWait:       cfg.Server.PongWait,
                MaxMessageSize: cfg.Server.MaxMessageSize,
        }

        server := &amp;WebSocketServer{
                config:             serverConfig,
                configManager:      configManager,
                logger:             logger,
                cameraMonitor:      cameraMonitor,
                jwtHandler:         jwtHandler,
                mediaMTXController: mediaMTXController,

                // Security extensions initialization (Phase 1 enhancement)
                permissionChecker: security.NewPermissionChecker(),

                // Input validation initialization
                validationHelper: NewValidationHelper(nil, nil),

                // WebSocket upgrader configuration
                upgrader: websocket.Upgrader{
                        ReadBufferSize:  1024,
                        WriteBufferSize: 1024,
                        CheckOrigin: func(r *http.Request) bool </span><span class="cov0" title="0">{
                                // Allow all origins for now - can be made configurable
                                return true
                        }</span>,
                },

                // Client management
                clients:       make(map[string]*ClientConnection),
                clientCounter: 0,

                // Method registration
                methods:        make(map[string]MethodHandler),
                methodVersions: make(map[string]string),

                // Performance metrics
                metrics: &amp;PerformanceMetrics{
                        RequestCount:      0,
                        ResponseTimes:     make(map[string][]float64),
                        ErrorCount:        0,
                        ActiveConnections: 0,
                        StartTime:         time.Now(),
                },

                // Event handling
                eventManager:  NewEventManager(logger),
                eventHandlers: make([]func(string, interface{}), 0),

                // Graceful shutdown
                stopChan: make(chan struct{}, 10), // Buffered to prevent deadlock during shutdown
                stopOnce: sync.Once{},
        }

        // Register built-in methods
        <span class="cov0" title="0">server.registerBuiltinMethods()

        return server, nil</span>
}

// Start starts the WebSocket server
func (s *WebSocketServer) Start() error <span class="cov6" title="24">{
        if s.running </span><span class="cov1" title="1">{
                s.logger.Warn("WebSocket server is already running")
                return fmt.Errorf("WebSocket server is already running")
        }</span>

        <span class="cov6" title="23">s.logger.WithFields(logging.Fields{
                "host":   s.config.Host,
                "port":   s.config.Port,
                "path":   s.config.WebSocketPath,
                "action": "start_server",
        }).Info("Starting WebSocket JSON-RPC server")

        // Create HTTP server
        mux := http.NewServeMux()
        mux.HandleFunc(s.config.WebSocketPath, s.handleWebSocket)

        s.server = &amp;http.Server{
                Addr:         fmt.Sprintf("%s:%d", s.config.Host, s.config.Port),
                Handler:      mux,
                ReadTimeout:  s.config.ReadTimeout,
                WriteTimeout: s.config.WriteTimeout,
        }

        // Start server in goroutine
        s.wg.Add(1)
        go func() </span><span class="cov6" title="23">{
                defer s.wg.Done()
                if err := s.server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        s.logger.WithError(err).Error("WebSocket server failed")
                        // Note: Error is logged but not returned as this is in a goroutine
                }</span>
        }()

        <span class="cov6" title="23">s.running = true

        s.logger.WithFields(logging.Fields{
                "host":   s.config.Host,
                "port":   s.config.Port,
                "path":   s.config.WebSocketPath,
                "action": "start_server",
                "status": "success",
        }).Info("WebSocket server started successfully")

        return nil</span>
}

// Stop stops the WebSocket server gracefully
func (s *WebSocketServer) Stop() error <span class="cov6" title="24">{
        if !s.running </span><span class="cov1" title="1">{
                s.logger.Warn("WebSocket server is not running")
                return nil
        }</span>

        <span class="cov6" title="23">s.logger.Info("Stopping WebSocket server")

        // Signal shutdown - use sync.Once to ensure single close operation
        s.stopOnce.Do(func() </span><span class="cov6" title="23">{
                close(s.stopChan)
        }</span>)

        // Close all client connections with timeout
        <span class="cov6" title="23">s.closeAllClientConnections()

        // Shutdown HTTP server
        if s.server != nil </span><span class="cov6" title="23">{
                ctx, cancel := context.WithTimeout(context.Background(), s.config.ShutdownTimeout)
                defer cancel()
                if err := s.server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        s.logger.WithError(err).Error("Error shutting down HTTP server")
                        // Note: Error is logged but not returned as this is cleanup operation
                }</span>
        }

        // Wait for all goroutines to finish
        <span class="cov6" title="23">s.wg.Wait()

        s.running = false

        s.logger.Info("WebSocket server stopped successfully")
        return nil</span>
}

// closeAllClientConnections closes all client connections with timeout
func (s *WebSocketServer) closeAllClientConnections() <span class="cov6" title="23">{
        s.logger.Info("Starting client connection cleanup")

        // Create cleanup context with timeout
        ctx, cancel := context.WithTimeout(context.Background(), s.config.ClientCleanupTimeout)
        defer cancel()

        // Get list of clients to close
        s.clientsMutex.Lock()
        clientsToClose := make([]*ClientConnection, 0, len(s.clients))
        for clientID, client := range s.clients </span><span class="cov5" title="10">{
                clientsToClose = append(clientsToClose, client)
                s.logger.WithField("client_id", clientID).Debug("Queuing client connection for cleanup")
        }</span>
        <span class="cov6" title="23">s.clientsMutex.Unlock()

        if len(clientsToClose) == 0 </span><span class="cov6" title="17">{
                s.logger.Debug("No client connections to clean up")
                return
        }</span>

        // Close connections concurrently with timeout
        <span class="cov4" title="6">var wg sync.WaitGroup
        cleanupResults := make(chan error, len(clientsToClose))

        for _, client := range clientsToClose </span><span class="cov5" title="10">{
                wg.Add(1)
                go func(client *ClientConnection) </span><span class="cov5" title="10">{
                        defer wg.Done()

                        // Set close deadline
                        client.Conn.SetWriteDeadline(time.Now().Add(5 * time.Second))

                        // Send close message
                        closeMsg := websocket.FormatCloseMessage(websocket.CloseGoingAway, "server shutdown")
                        if err := client.Conn.WriteControl(websocket.CloseMessage, closeMsg, time.Now().Add(5*time.Second)); err != nil </span><span class="cov4" title="8">{
                                s.logger.WithError(err).WithField("client_id", client.ClientID).Warn("Failed to send close message")
                        }</span>

                        // Close connection
                        <span class="cov5" title="10">if err := client.Conn.Close(); err != nil </span><span class="cov4" title="8">{
                                cleanupResults &lt;- fmt.Errorf("failed to close connection for client %s: %w", client.ClientID, err)
                                return
                        }</span>

                        // Remove client from map and update metrics atomically
                        <span class="cov2" title="2">s.clientsMutex.Lock()
                        delete(s.clients, client.ClientID)
                        s.clientsMutex.Unlock()

                        // Remove event subscriptions
                        s.eventManager.RemoveClient(client.ClientID)

                        // Use atomic operation for metrics update
                        atomic.AddInt64(&amp;s.metrics.ActiveConnections, -1)

                        cleanupResults &lt;- nil</span>
                }(client)
        }

        // Wait for cleanup with timeout
        <span class="cov4" title="6">cleanupDone := make(chan struct{})
        go func() </span><span class="cov4" title="6">{
                wg.Wait()
                close(cleanupDone)
        }</span>()

        <span class="cov4" title="6">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                s.logger.Warn("Client cleanup timeout reached, forcing connection closure")
                // Force close remaining connections
                for _, client := range clientsToClose </span><span class="cov0" title="0">{
                        client.Conn.Close()
                }</span>
        case &lt;-cleanupDone:<span class="cov4" title="6">
                s.logger.Debug("All client connections cleaned up successfully")</span>
        }

        // Check cleanup results
        <span class="cov4" title="6">close(cleanupResults)
        errorCount := 0
        for err := range cleanupResults </span><span class="cov5" title="10">{
                if err != nil </span><span class="cov4" title="8">{
                        errorCount++
                        s.logger.WithError(err).Warn("Client cleanup error")
                }</span>
        }

        <span class="cov4" title="6">if errorCount &gt; 0 </span><span class="cov3" title="5">{
                s.logger.WithField("error_count", fmt.Sprintf("%d", errorCount)).Warn("Some client connections had cleanup errors")
        }</span> else<span class="cov1" title="1"> {
                s.logger.Info("All client connections cleaned up successfully")
        }</span>
}

// handleWebSocket handles WebSocket upgrade and connection management
func (s *WebSocketServer) handleWebSocket(w http.ResponseWriter, r *http.Request) <span class="cov7" title="32">{
        // Check connection limit
        s.clientsMutex.RLock()
        if len(s.clients) &gt;= s.config.MaxConnections </span><span class="cov0" title="0">{
                s.clientsMutex.RUnlock()
                s.logger.Warn("Maximum connections reached")
                http.Error(w, "Maximum connections reached", http.StatusServiceUnavailable)
                return
        }</span>
        <span class="cov7" title="32">s.clientsMutex.RUnlock()

        // Upgrade HTTP connection to WebSocket
        conn, err := s.upgrader.Upgrade(w, r, nil)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).Error("Failed to upgrade connection to WebSocket")
                return
        }</span>

        // Generate client ID with proper synchronization
        <span class="cov7" title="32">s.clientsMutex.Lock()
        s.clientCounter++
        clientID := "client_" + strconv.FormatInt(s.clientCounter, 10)
        s.clientsMutex.Unlock()

        // Create client connection
        client := &amp;ClientConnection{
                ClientID:      clientID,
                Authenticated: false,
                ConnectedAt:   time.Now(),
                Subscriptions: make(map[string]bool),
                Conn:          conn,
        }

        // Add client to connections and update metrics atomically
        s.clientsMutex.Lock()
        s.clients[clientID] = client
        s.clientsMutex.Unlock()

        // Update metrics with atomic operation
        atomic.AddInt64(&amp;s.metrics.ActiveConnections, 1)

        s.logger.WithFields(logging.Fields{
                "client_id": clientID,
                "action":    "client_connected",
        }).Info("Client connected")

        // Handle connection in goroutine
        s.wg.Add(1)
        go s.handleClientConnection(conn, client)</span>
}

// handleClientConnection handles individual client connections
func (s *WebSocketServer) handleClientConnection(conn *websocket.Conn, client *ClientConnection) <span class="cov7" title="32">{
        // Create error channel for panic recovery
        panicChan := make(chan error, 1)

        defer func() </span><span class="cov7" title="32">{
                // Recover from panics in goroutine and propagate as errors
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        panicErr := fmt.Errorf("panic in client connection handler for client %s: %v", client.ClientID, r)
                        s.logger.WithFields(logging.Fields{
                                "client_id": client.ClientID,
                                "panic":     r,
                                "action":    "panic_recovered",
                        }).Error("Recovered from panic in client connection handler")

                        // Propagate panic as error instead of swallowing it
                        select </span>{
                        case panicChan &lt;- panicErr:<span class="cov0" title="0"></span>
                        default:<span class="cov0" title="0">
                                s.logger.WithError(panicErr).Warn("Panic channel overflow, panic error dropped")</span>
                        }
                }

                // Remove client from connections and update metrics atomically
                <span class="cov7" title="32">s.clientsMutex.Lock()
                delete(s.clients, client.ClientID)
                s.clientsMutex.Unlock()

                // Remove event subscriptions
                s.eventManager.RemoveClient(client.ClientID)

                // Update metrics with atomic operation
                atomic.AddInt64(&amp;s.metrics.ActiveConnections, -1)

                // Close connection
                conn.Close()

                s.logger.WithFields(logging.Fields{
                        "client_id": client.ClientID,
                        "action":    "client_disconnected",
                }).Info("Client disconnected")

                s.wg.Done()</span>
        }()

        // Set connection parameters
        <span class="cov7" title="32">conn.SetReadLimit(s.config.MaxMessageSize)
        conn.SetReadDeadline(time.Now().Add(s.config.PongWait))
        conn.SetPongHandler(func(string) error </span><span class="cov0" title="0">{
                conn.SetReadDeadline(time.Now().Add(s.config.PongWait))
                return nil
        }</span>)

        // Start ping ticker
        <span class="cov7" title="32">ticker := time.NewTicker(s.config.PingInterval)
        defer ticker.Stop()

        // Create message handling context with timeout
        msgCtx, msgCancel := context.WithCancel(context.Background())
        defer msgCancel()

        // Message handling loop
        for </span><span class="cov9" title="92">{
                select </span>{
                case &lt;-s.stopChan:<span class="cov1" title="1">
                        s.logger.WithField("client_id", client.ClientID).Debug("Server shutdown signal received, closing client connection")
                        return</span>
                case &lt;-msgCtx.Done():<span class="cov0" title="0">
                        s.logger.WithField("client_id", client.ClientID).Debug("Message context cancelled, closing client connection")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        // Set write deadline for ping
                        conn.SetWriteDeadline(time.Now().Add(s.config.WriteTimeout))
                        if err := conn.WriteControl(websocket.PingMessage, []byte{}, time.Now().Add(s.config.WriteTimeout)); err != nil </span><span class="cov0" title="0">{
                                s.logger.WithError(err).WithField("client_id", client.ClientID).Error("Failed to send ping")
                                return
                        }</span>
                default:<span class="cov9" title="91">
                        // Set read deadline for message
                        conn.SetReadDeadline(time.Now().Add(s.config.ReadTimeout))

                        // Read message with timeout
                        _, message, err := conn.ReadMessage()
                        if err != nil </span><span class="cov7" title="31">{
                                if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) </span><span class="cov0" title="0">{
                                        s.logger.WithError(err).WithField("client_id", client.ClientID).Error("WebSocket read error")
                                }</span> else<span class="cov7" title="31"> if websocket.IsCloseError(err, websocket.CloseNormalClosure, websocket.CloseGoingAway) </span><span class="cov0" title="0">{
                                        s.logger.WithField("client_id", client.ClientID).Debug("Client connection closed normally")
                                }</span>
                                <span class="cov7" title="31">return</span>
                        }

                        // Handle message
                        <span class="cov8" title="60">s.handleMessage(conn, client, message)</span>
                }
        }
}

// handleMessage processes incoming WebSocket messages
func (s *WebSocketServer) handleMessage(conn *websocket.Conn, client *ClientConnection, message []byte) <span class="cov8" title="60">{
        startTime := time.Now()

        s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "action":    "handle_message",
        }).Debug("Processing WebSocket message")

        // Parse JSON-RPC request
        var request JsonRpcRequest
        if err := json.Unmarshal(message, &amp;request); err != nil </span><span class="cov1" title="1">{
                s.sendErrorResponse(conn, nil, INVALID_REQUEST, "Invalid JSON-RPC request")
                return
        }</span>

        // Validate JSON-RPC version
        <span class="cov8" title="57">if request.JSONRPC != "2.0" </span><span class="cov1" title="1">{
                s.sendErrorResponse(conn, request.ID, INVALID_REQUEST, "Invalid JSON-RPC version")
                return
        }</span>

        // Check if this is a notification (ID is null)
        <span class="cov8" title="56">isNotification := request.ID == nil

        // Handle request
        response, err := s.handleRequest(&amp;request, client)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).WithFields(logging.Fields{
                        "client_id": client.ClientID,
                        "method":    request.Method,
                }).Error("Request handling error")
                // Only send error response for requests, not notifications
                if !isNotification </span><span class="cov0" title="0">{
                        s.sendErrorResponse(conn, request.ID, INTERNAL_ERROR, "Internal server error")
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Only send response for requests, not notifications
        <span class="cov8" title="58">if !isNotification </span><span class="cov8" title="56">{
                if err := s.sendResponse(conn, response); err != nil </span><span class="cov0" title="0">{
                        s.logger.WithError(err).WithField("client_id", client.ClientID).Error("Failed to send response")
                        return
                }</span>
        }

        // Record performance metrics
        <span class="cov8" title="58">duration := time.Since(startTime).Seconds()
        s.recordRequest(request.Method, duration)

        s.logger.WithFields(logging.Fields{
                "client_id": client.ClientID,
                "method":    request.Method,
                "duration":  duration,
                "action":    "request_completed",
        }).Debug("Request completed")</span>
}

// handleRequest processes JSON-RPC requests
func (s *WebSocketServer) handleRequest(request *JsonRpcRequest, client *ClientConnection) (*JsonRpcResponse, error) <span class="cov8" title="57">{
        // Security extensions: Rate limiting check (Phase 1 enhancement)
        if err := s.checkRateLimit(client); err != nil </span><span class="cov0" title="0">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        ID:      request.ID,
                        Error: &amp;JsonRpcError{
                                Code:    RATE_LIMIT_EXCEEDED,
                                Message: ErrorMessages[RATE_LIMIT_EXCEEDED],
                                Data:    err.Error(),
                        },
                }, nil
        }</span>

        // Find method handler
        <span class="cov8" title="58">s.methodsMutex.RLock()
        handler, exists := s.methods[request.Method]
        s.methodsMutex.RUnlock()

        if !exists </span><span class="cov4" title="6">{
                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        ID:      request.ID,
                        Error: &amp;JsonRpcError{
                                Code:    METHOD_NOT_FOUND,
                                Message: ErrorMessages[METHOD_NOT_FOUND],
                        },
                }, nil
        }</span>

        // Security extensions: Permission check (Phase 1 enhancement)
        // Skip permission check for authenticate method
        <span class="cov8" title="52">if request.Method != "authenticate" </span><span class="cov7" title="31">{
                if err := s.checkMethodPermissions(client, request.Method); err != nil </span><span class="cov1" title="1">{
                        // Check if client is not authenticated
                        if !client.Authenticated </span><span class="cov1" title="1">{
                                return &amp;JsonRpcResponse{
                                        JSONRPC: "2.0",
                                        ID:      request.ID,
                                        Error: &amp;JsonRpcError{
                                                Code:    AUTHENTICATION_REQUIRED,
                                                Message: ErrorMessages[AUTHENTICATION_REQUIRED],
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">return &amp;JsonRpcResponse{
                                JSONRPC: "2.0",
                                ID:      request.ID,
                                Error: &amp;JsonRpcError{
                                        Code:    INSUFFICIENT_PERMISSIONS,
                                        Message: ErrorMessages[INSUFFICIENT_PERMISSIONS],
                                        Data:    err.Error(),
                                },
                        }, nil</span>
                }
        }

        // Call method handler
        <span class="cov7" title="51">response, err := handler(request.Params, client)
        if err != nil </span><span class="cov0" title="0">{
                // Update error metrics with atomic operation
                atomic.AddInt64(&amp;s.metrics.ErrorCount, 1)

                return &amp;JsonRpcResponse{
                        JSONRPC: "2.0",
                        ID:      request.ID,
                        Error: &amp;JsonRpcError{
                                Code:    INTERNAL_ERROR,
                                Message: ErrorMessages[INTERNAL_ERROR],
                                Data:    err.Error(),
                        },
                }, nil
        }</span>

        // Set JSON-RPC version and ID
        <span class="cov7" title="51">response.JSONRPC = "2.0"
        response.ID = request.ID

        return response, nil</span>
}

// sendResponse sends a JSON-RPC response to the client
func (s *WebSocketServer) sendResponse(conn *websocket.Conn, response *JsonRpcResponse) error <span class="cov8" title="64">{
        conn.SetWriteDeadline(time.Now().Add(s.config.WriteTimeout))
        return conn.WriteJSON(response)
}</span>

// sendErrorResponse sends a JSON-RPC error response to the client
func (s *WebSocketServer) sendErrorResponse(conn *websocket.Conn, id interface{}, code int, message string) <span class="cov4" title="9">{
        // Check for nil connection to prevent panic
        if conn == nil </span><span class="cov1" title="1">{
                s.logger.WithFields(logging.Fields{
                        "error_code": code,
                        "message":    message,
                }).Error("Cannot send error response: connection is nil")
                return
        }</span>

        <span class="cov4" title="8">response := &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                ID:      id,
                Error: &amp;JsonRpcError{
                        Code:    code,
                        Message: message,
                },
        }

        if err := s.sendResponse(conn, response); err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).Error("Failed to send error response")
        }</span>
}

// recordRequest records performance metrics for a request
func (s *WebSocketServer) recordRequest(method string, duration float64) <span class="cov10" title="159">{
        // Use atomic operation for RequestCount
        atomic.AddInt64(&amp;s.metrics.RequestCount, 1)

        // ResponseTimes still needs mutex protection due to map operations
        s.metricsMutex.Lock()
        defer s.metricsMutex.Unlock()

        if s.metrics.ResponseTimes[method] == nil </span><span class="cov6" title="20">{
                s.metrics.ResponseTimes[method] = make([]float64, 0)
        }</span>
        <span class="cov10" title="159">s.metrics.ResponseTimes[method] = append(s.metrics.ResponseTimes[method], duration)</span>
}

// GetMetrics returns current performance metrics
func (s *WebSocketServer) GetMetrics() *PerformanceMetrics <span class="cov0" title="0">{
        // Use atomic operations for reading counters
        requestCount := atomic.LoadInt64(&amp;s.metrics.RequestCount)
        errorCount := atomic.LoadInt64(&amp;s.metrics.ErrorCount)
        activeConnections := atomic.LoadInt64(&amp;s.metrics.ActiveConnections)

        // ResponseTimes still needs mutex protection due to map operations
        s.metricsMutex.RLock()
        defer s.metricsMutex.RUnlock()

        // Calculate average response time
        allResponseTimes := make([]float64, 0)
        for _, times := range s.metrics.ResponseTimes </span><span class="cov0" title="0">{
                allResponseTimes = append(allResponseTimes, times...)
        }</span>

        // Note: averageResponseTime and errorRate calculations are available for future use
        // when extending the metrics functionality

        // Create a deep copy to prevent race conditions
        <span class="cov0" title="0">responseTimesCopy := make(map[string][]float64)
        for method, times := range s.metrics.ResponseTimes </span><span class="cov0" title="0">{
                timesCopy := make([]float64, len(times))
                copy(timesCopy, times)
                responseTimesCopy[method] = timesCopy
        }</span>

        <span class="cov0" title="0">return &amp;PerformanceMetrics{
                RequestCount:      requestCount,
                ResponseTimes:     responseTimesCopy,
                ErrorCount:        errorCount,
                ActiveConnections: activeConnections,
                StartTime:         s.metrics.StartTime,
        }</span>
}

// IsRunning returns whether the server is currently running
func (s *WebSocketServer) IsRunning() bool <span class="cov0" title="0">{
        return s.running
}</span>

// GetConfig returns the server configuration (for testing purposes)
func (s *WebSocketServer) GetConfig() *ServerConfig <span class="cov0" title="0">{
        return s.config
}</span>

// SetConfig sets the server configuration (for testing purposes)
func (s *WebSocketServer) SetConfig(config *ServerConfig) <span class="cov0" title="0">{
        s.config = config
}</span>

// GetEventManager returns the event manager for external integration
func (s *WebSocketServer) GetEventManager() *EventManager <span class="cov0" title="0">{
        return s.eventManager
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
WebSocket Test Helpers

Provides focused test utilities for WebSocket module testing,
following the project testing standards and Go coding standards.

Requirements Coverage:
- REQ-API-001: WebSocket JSON-RPC 2.0 API endpoint
- REQ-API-002: JSON-RPC 2.0 protocol implementation
- REQ-API-003: Request/response message handling

Test Categories: Unit/Integration
API Documentation Reference: docs/api/json_rpc_methods.md
*/

package websocket

import (
        "fmt"
        "net"
        "net/http"
        "os"
        "path/filepath"
        "testing"
        "time"

        "github.com/camerarecorder/mediamtx-camera-service-go/internal/camera"
        "github.com/camerarecorder/mediamtx-camera-service-go/internal/config"
        "github.com/camerarecorder/mediamtx-camera-service-go/internal/logging"
        "github.com/camerarecorder/mediamtx-camera-service-go/internal/mediamtx"
        "github.com/camerarecorder/mediamtx-camera-service-go/internal/security"
        "github.com/gorilla/websocket"
        "github.com/stretchr/testify/require"
)

// GetFreePort returns a free port for testing using port 0 for automatic OS assignment
func GetFreePort() int <span class="cov7" title="25">{
        // Use port 0 to let OS assign next available port
        listener, err := net.Listen("tcp", ":0")
        if err != nil </span><span class="cov0" title="0">{
                return 8002 // fallback
        }</span>

        <span class="cov7" title="25">port := listener.Addr().(*net.TCPAddr).Port
        listener.Close()

        // Small delay to ensure port is released
        time.Sleep(10 * time.Millisecond)

        return port</span>
}

// getTestConfigPath finds the WebSocket test configuration file in fixtures
func getTestConfigPath(t *testing.T) string <span class="cov7" title="25">{
        // Start from current directory and walk up to find project root
        dir, err := os.Getwd()
        require.NoError(t, err, "Failed to get current directory")

        for </span><span class="cov10" title="75">{
                if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil </span><span class="cov7" title="25">{
                        // Found project root, look for WebSocket test config
                        configPath := filepath.Join(dir, "tests", "fixtures", "config_websocket_test.yaml")
                        if _, err := os.Stat(configPath); err == nil </span><span class="cov7" title="25">{
                                return configPath
                        }</span>
                        <span class="cov0" title="0">break</span>
                }

                <span class="cov9" title="50">parent := filepath.Dir(dir)
                if parent == dir </span><span class="cov0" title="0">{
                        // Reached root directory
                        break</span>
                }
                <span class="cov9" title="50">dir = parent</span>
        }

        <span class="cov0" title="0">require.Fail(t, "Could not find WebSocket test configuration file in fixtures")
        return ""</span>
}

// NewTestWebSocketServer creates a test WebSocket server using fixtures
func NewTestWebSocketServer(t *testing.T) *WebSocketServer <span class="cov7" title="25">{
        // Load test configuration from fixtures
        configPath := getTestConfigPath(t)
        configManager := config.CreateConfigManager()
        err := configManager.LoadConfig(configPath)
        require.NoError(t, err, "Failed to load test configuration from fixtures")

        // Get free port automatically (port 0 = OS assigns next available)
        port := GetFreePort()

        // Create server configuration from test config
        cfg := configManager.GetConfig()
        config := &amp;ServerConfig{
                Host:                 cfg.Server.Host,
                Port:                 port, // Use dynamically assigned port
                WebSocketPath:        cfg.Server.WebSocketPath,
                MaxConnections:       cfg.Server.MaxConnections,
                ReadTimeout:          cfg.Server.ReadTimeout,
                WriteTimeout:         cfg.Server.WriteTimeout,
                PingInterval:         cfg.Server.PingInterval,
                PongWait:             cfg.Server.PongWait,
                MaxMessageSize:       cfg.Server.MaxMessageSize,
                ReadBufferSize:       cfg.Server.ReadBufferSize,
                WriteBufferSize:      cfg.Server.WriteBufferSize,
                ShutdownTimeout:      cfg.Server.ShutdownTimeout,
                ClientCleanupTimeout: cfg.Server.ClientCleanupTimeout,
        }

        // Create minimal test dependencies
        logger := logging.NewLogger("websocket-test")

        // Create test JWT handler
        jwtHandler, err := security.NewJWTHandler(cfg.Security.JWTSecretKey, logger)
        require.NoError(t, err, "Failed to create test JWT handler")

        // Create test permission checker
        permissionChecker := security.NewPermissionChecker()

        // Create test validation helper
        inputValidator := security.NewInputValidator(logger, nil)
        validationHelper := NewValidationHelper(inputValidator, logging.NewLogger("test-validation-helper"))

        // Create test event manager
        eventManager := NewEventManager(logging.NewLogger("test-event-manager"))

        // Create server with test dependencies
        server := &amp;WebSocketServer{
                config:            config,
                logger:            logger,
                jwtHandler:        jwtHandler,
                permissionChecker: permissionChecker,
                validationHelper:  validationHelper,
                eventManager:      eventManager,
                clients:           make(map[string]*ClientConnection),
                methods:           make(map[string]MethodHandler),
                methodVersions:    make(map[string]string),
                metrics: &amp;PerformanceMetrics{
                        RequestCount:      0,
                        ResponseTimes:     make(map[string][]float64),
                        ErrorCount:        0,
                        ActiveConnections: 0,
                        StartTime:         time.Now(),
                },
                eventHandlers: make([]func(string, interface{}), 0),
                stopChan:      make(chan struct{}, 10), // Buffered to prevent deadlock during shutdown
                upgrader: websocket.Upgrader{
                        CheckOrigin: func(r *http.Request) bool </span><span class="cov8" title="32">{
                                return true // Allow all origins in tests
                        }</span>,
                },
        }

        // Register built-in methods (same as production server)
        <span class="cov7" title="25">server.registerBuiltinMethods()

        return server</span>
}

// NewTestWebSocketServerWithDependencies creates a test server with provided dependencies
func NewTestWebSocketServerWithDependencies(
        t *testing.T,
        cameraMonitor camera.CameraMonitor,
        mediaMTXController mediamtx.MediaMTXController,
) *WebSocketServer <span class="cov0" title="0">{
        server := NewTestWebSocketServer(t)
        server.cameraMonitor = cameraMonitor
        server.mediaMTXController = mediaMTXController
        return server
}</span>

// NewTestClient creates a test WebSocket client connection
func NewTestClient(t *testing.T, server *WebSocketServer) *websocket.Conn <span class="cov8" title="32">{
        // Start server if not running
        if !server.running </span><span class="cov0" title="0">{
                err := server.Start()
                require.NoError(t, err, "Failed to start test server")

                // Wait for server to be ready
                time.Sleep(100 * time.Millisecond)
        }</span>

        // Connect to server
        <span class="cov8" title="32">url := fmt.Sprintf("ws://localhost:%d/ws", server.config.Port)
        conn, _, err := websocket.DefaultDialer.Dial(url, nil)
        require.NoError(t, err, "Failed to connect to test server")

        return conn</span>
}

// CreateTestMessage creates a test JSON-RPC message
func CreateTestMessage(method string, params map[string]interface{}) *JsonRpcRequest <span class="cov9" title="53">{
        return &amp;JsonRpcRequest{
                JSONRPC: "2.0",
                Method:  method,
                ID:      fmt.Sprintf("test-%d", time.Now().UnixNano()),
                Params:  params,
        }
}</span>

// CreateTestNotification creates a test JSON-RPC notification
func CreateTestNotification(method string, params map[string]interface{}) *JsonRpcNotification <span class="cov1" title="1">{
        return &amp;JsonRpcNotification{
                JSONRPC: "2.0",
                Method:  method,
                Params:  params,
        }
}</span>

// CreateTestResponse creates a test JSON-RPC response
func CreateTestResponse(id interface{}, result interface{}) *JsonRpcResponse <span class="cov0" title="0">{
        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                ID:      id,
                Result:  result,
                Error:   nil,
        }
}</span>

// CreateTestErrorResponse creates a test JSON-RPC error response
func CreateTestErrorResponse(id interface{}, code int, message string) *JsonRpcResponse <span class="cov0" title="0">{
        return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                ID:      id,
                Error: &amp;JsonRpcError{
                        Code:    code,
                        Message: message,
                },
        }
}</span>

// SendTestMessage sends a test message and waits for response
func SendTestMessage(t *testing.T, conn *websocket.Conn, message *JsonRpcRequest) *JsonRpcResponse <span class="cov9" title="54">{
        // Send message
        err := conn.WriteJSON(message)
        require.NoError(t, err, "Failed to send test message")

        // Read response
        var response JsonRpcResponse
        err = conn.ReadJSON(&amp;response)
        require.NoError(t, err, "Failed to read test response")

        return &amp;response
}</span>

// SendTestNotification sends a test notification (no response expected)
func SendTestNotification(t *testing.T, conn *websocket.Conn, notification *JsonRpcNotification) <span class="cov1" title="1">{
        err := conn.WriteJSON(notification)
        require.NoError(t, err, "Failed to send test notification")
}</span>

// WaitForServerReady waits for the server to be ready
func WaitForServerReady(t *testing.T, server *WebSocketServer, timeout time.Duration) <span class="cov1" title="1">{
        deadline := time.Now().Add(timeout)
        for time.Now().Before(deadline) </span><span class="cov1" title="1">{
                if server.running </span><span class="cov1" title="1">{
                        return
                }</span>
                <span class="cov0" title="0">time.Sleep(10 * time.Millisecond)</span>
        }
        <span class="cov0" title="0">require.Fail(t, "Server failed to become ready within timeout")</span>
}

// CleanupTestServer stops and cleans up a test server
func CleanupTestServer(t *testing.T, server *WebSocketServer) <span class="cov8" title="39">{
        if server != nil &amp;&amp; server.running </span><span class="cov7" title="20">{
                err := server.Stop()
                if err != nil </span><span class="cov0" title="0">{
                        t.Logf("Warning: Failed to stop test server: %v", err)
                }</span>
        }
}

// CleanupTestClient closes a test client connection
func CleanupTestClient(t *testing.T, conn *websocket.Conn) <span class="cov8" title="32">{
        if conn != nil </span><span class="cov8" title="32">{
                err := conn.Close()
                if err != nil </span><span class="cov2" title="2">{
                        t.Logf("Warning: Failed to close test client: %v", err)
                }</span>
        }
}

// registerDefaultMethods registers default test methods on the server
func (s *WebSocketServer) registerDefaultMethods() <span class="cov0" title="0">{
        // Register ping method
        s.registerMethod("ping", func(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) </span><span class="cov0" title="0">{
                return CreateTestResponse("test-id", "pong"), nil
        }</span>, "1.0")

        // Register echo method for testing
        <span class="cov0" title="0">s.registerMethod("echo", func(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) </span><span class="cov0" title="0">{
                return CreateTestResponse("test-id", params), nil
        }</span>, "1.0")

        // Register error method for testing
        <span class="cov0" title="0">s.registerMethod("error", func(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error) </span><span class="cov0" title="0">{
                return CreateTestErrorResponse("test-id", INTERNAL_ERROR, "Test error"), nil
        }</span>, "1.0")
}
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
WebSocket JSON-RPC 2.0 types and structures.

Provides JSON-RPC 2.0 request, response, and notification structures
following the Python WebSocketJsonRpcServer patterns and project architecture standards.

Requirements Coverage:
- REQ-API-001: WebSocket JSON-RPC 2.0 API endpoint
- REQ-API-002: JSON-RPC 2.0 protocol implementation
- REQ-API-003: Request/response message handling

Test Categories: Unit/Integration
API Documentation Reference: docs/api/json_rpc_methods.md
*/

package websocket

import (
        "encoding/json"
        "time"

        "github.com/gorilla/websocket"
)

// JSON-RPC Error Codes (RFC 32700) - Following Python implementation
const (
        INVALID_REQUEST          = -32600
        AUTHENTICATION_REQUIRED  = -32001
        RATE_LIMIT_EXCEEDED      = -32002
        INSUFFICIENT_PERMISSIONS = -32003
        CAMERA_NOT_FOUND         = -32004
        RECORDING_IN_PROGRESS    = -32005
        MEDIAMTX_UNAVAILABLE     = -32006
        INSUFFICIENT_STORAGE     = -32007
        CAPABILITY_NOT_SUPPORTED = -32008
        METHOD_NOT_FOUND         = -32601
        INVALID_PARAMS           = -32602
        INTERNAL_ERROR           = -32603

        // Enhanced Recording Management Error Codes
        ERROR_CAMERA_NOT_FOUND         = -1000
        ERROR_CAMERA_NOT_AVAILABLE     = -1001
        ERROR_RECORDING_IN_PROGRESS    = -1002
        ERROR_MEDIAMTX_ERROR           = -1003
        ERROR_CAMERA_ALREADY_RECORDING = -1006
        ERROR_STORAGE_LOW              = -1008
        ERROR_STORAGE_CRITICAL         = -1010
)

// ErrorMessages maps error codes to their corresponding messages
// Following Go API Documentation exactly
var ErrorMessages = map[int]string{
        INVALID_REQUEST:                "Invalid Request",
        AUTHENTICATION_REQUIRED:        "Authentication failed or token expired",
        RATE_LIMIT_EXCEEDED:            "Rate limit exceeded",
        INSUFFICIENT_PERMISSIONS:       "Insufficient permissions",
        CAMERA_NOT_FOUND:               "Camera not found or disconnected",
        RECORDING_IN_PROGRESS:          "Recording already in progress",
        MEDIAMTX_UNAVAILABLE:           "MediaMTX service unavailable",
        INSUFFICIENT_STORAGE:           "Insufficient storage space",
        CAPABILITY_NOT_SUPPORTED:       "Camera capability not supported",
        METHOD_NOT_FOUND:               "Method not found",
        INVALID_PARAMS:                 "Invalid parameters",
        INTERNAL_ERROR:                 "Internal server error",
        ERROR_CAMERA_NOT_FOUND:         "Camera not found",
        ERROR_CAMERA_NOT_AVAILABLE:     "Camera not available",
        ERROR_RECORDING_IN_PROGRESS:    "Recording in progress",
        ERROR_MEDIAMTX_ERROR:           "MediaMTX error",
        ERROR_CAMERA_ALREADY_RECORDING: "Camera is currently recording",
        ERROR_STORAGE_LOW:              "Storage space is low",
        ERROR_STORAGE_CRITICAL:         "Storage space is critical",
}

// JsonRpcRequest represents a JSON-RPC 2.0 request structure
// Following Python JsonRpcRequest dataclass
type JsonRpcRequest struct {
        JSONRPC string                 `json:"jsonrpc"`
        Method  string                 `json:"method"`
        ID      interface{}            `json:"id,omitempty"`
        Params  map[string]interface{} `json:"params,omitempty"`
}

// JsonRpcResponse represents a JSON-RPC 2.0 response structure
// Following Python JsonRpcResponse dataclass
type JsonRpcResponse struct {
        JSONRPC string        `json:"jsonrpc"`
        ID      interface{}   `json:"id,omitempty"`
        Result  interface{}   `json:"result,omitempty"`
        Error   *JsonRpcError `json:"error,omitempty"`
}

// JsonRpcNotification represents a JSON-RPC 2.0 notification structure
// Following Python JsonRpcNotification dataclass
type JsonRpcNotification struct {
        JSONRPC string                 `json:"jsonrpc"`
        Method  string                 `json:"method"`
        Params  map[string]interface{} `json:"params,omitempty"`
}

// JsonRpcError represents a JSON-RPC 2.0 error structure
type JsonRpcError struct {
        Code    int         `json:"code"`
        Message string      `json:"message"`
        Data    interface{} `json:"data,omitempty"`
}

// ClientConnection represents a connected WebSocket client
// Following Python ClientConnection class
type ClientConnection struct {
        ClientID      string
        Authenticated bool
        UserID        string
        Role          string
        AuthMethod    string
        ConnectedAt   time.Time
        Subscriptions map[string]bool
        Conn          *websocket.Conn `json:"-"` // WebSocket connection for sending messages
}

// PerformanceMetrics tracks WebSocket server performance
// Following Python PerformanceMetrics class
// Note: RequestCount, ErrorCount, and ActiveConnections use atomic operations for thread safety
type PerformanceMetrics struct {
        RequestCount      int64
        ResponseTimes     map[string][]float64
        ErrorCount        int64
        ActiveConnections int64
        StartTime         time.Time
}

// MethodHandler defines the signature for JSON-RPC method handlers
type MethodHandler func(params map[string]interface{}, client *ClientConnection) (*JsonRpcResponse, error)

// WebSocketMessage represents a WebSocket message with metadata
type WebSocketMessage struct {
        Type      string          `json:"type"`
        Data      json.RawMessage `json:"data"`
        Timestamp time.Time       `json:"timestamp"`
        ClientID  string          `json:"client_id,omitempty"`
}

// ServerConfig contains WebSocket server configuration
// Following Python server configuration patterns
type ServerConfig struct {
        Host                 string        `mapstructure:"host"`
        Port                 int           `mapstructure:"port"`
        WebSocketPath        string        `mapstructure:"websocket_path"`
        MaxConnections       int           `mapstructure:"max_connections"`
        ReadTimeout          time.Duration `mapstructure:"read_timeout"`
        WriteTimeout         time.Duration `mapstructure:"write_timeout"`
        PingInterval         time.Duration `mapstructure:"ping_interval"`
        PongWait             time.Duration `mapstructure:"pong_wait"`
        MaxMessageSize       int64         `mapstructure:"max_message_size"`
        ReadBufferSize       int           `mapstructure:"read_buffer_size"`
        WriteBufferSize      int           `mapstructure:"write_buffer_size"`
        ShutdownTimeout      time.Duration `mapstructure:"shutdown_timeout"` // Default: 30 seconds
        ClientCleanupTimeout time.Duration `mapstructure:"client_cleanup_timeout"` // Default: 10 seconds
}

// DefaultServerConfig returns default WebSocket server configuration
// Optimized for Epic E3 performance requirements: &lt;50ms response time, 1000+ connections
func DefaultServerConfig() *ServerConfig <span class="cov8" title="1">{
        return &amp;ServerConfig{
                Host:                 "0.0.0.0",
                Port:                 8002,
                WebSocketPath:        "/ws",
                MaxConnections:       1000,
                ReadTimeout:          5 * time.Second,  // Reduced for faster response detection
                WriteTimeout:         1 * time.Second,  // Reduced for faster message delivery
                PingInterval:         30 * time.Second, // Keep reasonable for connection health
                PongWait:             60 * time.Second, // Keep reasonable for connection stability
                MaxMessageSize:       1024 * 1024,      // 1MB
                ReadBufferSize:       1024,
                WriteBufferSize:      1024,
                ShutdownTimeout:      30 * time.Second, // Default shutdown timeout
                ClientCleanupTimeout: 10 * time.Second, // Default client cleanup timeout
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package websocket

import (
        "strconv"

        "github.com/camerarecorder/mediamtx-camera-service-go/internal/logging"
        "github.com/camerarecorder/mediamtx-camera-service-go/internal/security"
)

// ValidationHelper provides centralized validation for JSON-RPC method parameters
type ValidationHelper struct {
        inputValidator *security.InputValidator
        logger         *logging.Logger
}

// NewValidationHelper creates a new validation helper
func NewValidationHelper(inputValidator *security.InputValidator, logger *logging.Logger) *ValidationHelper <span class="cov9" title="34">{
        return &amp;ValidationHelper{
                inputValidator: inputValidator,
                logger:         logger,
        }
}</span>

// ValidationResult contains validation results with error details
type ValidationResult struct {
        Valid    bool
        Errors   []string
        Warnings []string
        Data     map[string]interface{}
}

// NewValidationResult creates a new validation result
func NewValidationResult() *ValidationResult <span class="cov10" title="40">{
        return &amp;ValidationResult{
                Valid:    true,
                Errors:   make([]string, 0),
                Warnings: make([]string, 0),
                Data:     make(map[string]interface{}),
        }
}</span>

// AddError adds a validation error
func (vr *ValidationResult) AddError(message string) <span class="cov8" title="21">{
        vr.Valid = false
        vr.Errors = append(vr.Errors, message)
}</span>

// AddWarning adds a validation warning
func (vr *ValidationResult) AddWarning(message string) <span class="cov3" title="3">{
        vr.Warnings = append(vr.Warnings, message)
}</span>

// AddData adds data to the validation result
func (vr *ValidationResult) AddData(key string, value interface{}) <span class="cov9" title="29">{
        vr.Data[key] = value
}</span>

// GetFirstError returns the first error message or empty string
func (vr *ValidationResult) GetFirstError() string <span class="cov3" title="3">{
        if len(vr.Errors) &gt; 0 </span><span class="cov3" title="3">{
                return vr.Errors[0]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// ValidatePaginationParams validates limit and offset parameters
func (vh *ValidationHelper) ValidatePaginationParams(params map[string]interface{}) *ValidationResult <span class="cov3" title="3">{
        result := NewValidationResult()

        if params == nil </span><span class="cov1" title="1">{
                // Use defaults for nil params
                result.AddData("limit", 100)
                result.AddData("offset", 0)
                return result
        }</span>

        // Validate limit
        <span class="cov2" title="2">limit := 100 // Default
        if limitVal, exists := params["limit"]; exists </span><span class="cov1" title="1">{
                if limitResult := vh.inputValidator.ValidateLimit(limitVal); limitResult.HasErrors() </span><span class="cov0" title="0">{
                        result.AddError(limitResult.GetErrorMessages()[0])
                        return result
                }</span>
                // Extract validated limit
                <span class="cov1" title="1">switch v := limitVal.(type) </span>{
                case int:<span class="cov1" title="1">
                        limit = v</span>
                case float64:<span class="cov0" title="0">
                        limit = int(v)</span>
                case string:<span class="cov0" title="0">
                        if limitInt, err := strconv.Atoi(v); err == nil </span><span class="cov0" title="0">{
                                limit = limitInt
                        }</span>
                }
        }

        // Validate offset
        <span class="cov2" title="2">offset := 0 // Default
        if offsetVal, exists := params["offset"]; exists </span><span class="cov1" title="1">{
                if offsetResult := vh.inputValidator.ValidateOffset(offsetVal); offsetResult.HasErrors() </span><span class="cov0" title="0">{
                        result.AddError(offsetResult.GetErrorMessages()[0])
                        return result
                }</span>
                // Extract validated offset
                <span class="cov1" title="1">switch v := offsetVal.(type) </span>{
                case int:<span class="cov1" title="1">
                        offset = v</span>
                case float64:<span class="cov0" title="0">
                        offset = int(v)</span>
                case string:<span class="cov0" title="0">
                        if offsetInt, err := strconv.Atoi(v); err == nil </span><span class="cov0" title="0">{
                                offset = offsetInt
                        }</span>
                }
        }

        <span class="cov2" title="2">result.AddData("limit", limit)
        result.AddData("offset", offset)
        return result</span>
}

// ValidateDeviceParameter validates the device parameter
func (vh *ValidationHelper) ValidateDeviceParameter(params map[string]interface{}) *ValidationResult <span class="cov7" title="12">{
        result := NewValidationResult()

        if params == nil </span><span class="cov1" title="1">{
                result.AddError("device parameter is required")
                return result
        }</span>

        <span class="cov6" title="11">deviceVal, exists := params["device"]
        if !exists </span><span class="cov3" title="3">{
                result.AddError("device parameter is required")
                return result
        }</span>

        <span class="cov6" title="8">if deviceResult := vh.inputValidator.ValidateDevicePath(deviceVal); deviceResult.HasErrors() </span><span class="cov1" title="1">{
                result.AddError(deviceResult.GetErrorMessages()[0])
                return result
        }</span>

        // Extract validated device path
        <span class="cov5" title="7">devicePath, ok := deviceVal.(string)
        if !ok </span><span class="cov0" title="0">{
                result.AddError("device parameter must be a string")
                return result
        }</span>

        <span class="cov5" title="7">result.AddData("device", devicePath)
        return result</span>
}

// ValidateFilenameParameter validates the filename parameter
func (vh *ValidationHelper) ValidateFilenameParameter(params map[string]interface{}) *ValidationResult <span class="cov4" title="4">{
        result := NewValidationResult()

        if params == nil </span><span class="cov1" title="1">{
                result.AddError("filename parameter is required")
                return result
        }</span>

        <span class="cov3" title="3">filenameVal, exists := params["filename"]
        if !exists </span><span class="cov1" title="1">{
                result.AddError("filename parameter is required")
                return result
        }</span>

        <span class="cov2" title="2">if filenameResult := vh.inputValidator.ValidateFilename(filenameVal); filenameResult.HasErrors() </span><span class="cov1" title="1">{
                result.AddError(filenameResult.GetErrorMessages()[0])
                return result
        }</span>

        // Extract validated filename
        <span class="cov1" title="1">filename, ok := filenameVal.(string)
        if !ok </span><span class="cov0" title="0">{
                result.AddError("filename parameter must be a string")
                return result
        }</span>

        <span class="cov1" title="1">result.AddData("filename", filename)
        return result</span>
}

// ValidateRecordingParameters validates recording-specific parameters
func (vh *ValidationHelper) ValidateRecordingParameters(params map[string]interface{}) *ValidationResult <span class="cov4" title="5">{
        result := NewValidationResult()

        if params == nil </span><span class="cov1" title="1">{
                result.AddError("parameters are required")
                return result
        }</span>

        // Validate device parameter first
        <span class="cov4" title="4">deviceResult := vh.ValidateDeviceParameter(params)
        if !deviceResult.Valid </span><span class="cov1" title="1">{
                result.AddError(deviceResult.GetFirstError())
                return result
        }</span>
        <span class="cov3" title="3">result.AddData("device", deviceResult.Data["device"])

        // Validate optional parameters
        options := make(map[string]interface{})

        // Duration validation
        if duration, exists := params["duration_seconds"]; exists </span><span class="cov2" title="2">{
                if durationResult := vh.inputValidator.ValidatePositiveInteger(duration, "duration_seconds"); durationResult.HasErrors() </span><span class="cov1" title="1">{
                        result.AddError(durationResult.GetErrorMessages()[0])
                        return result
                }</span>
                // Extract validated duration
                <span class="cov1" title="1">switch v := duration.(type) </span>{
                case int:<span class="cov1" title="1">
                        options["max_duration"] = v</span>
                case float64:<span class="cov0" title="0">
                        options["max_duration"] = int(v)</span>
                case string:<span class="cov0" title="0">
                        if durationInt, err := strconv.Atoi(v); err == nil </span><span class="cov0" title="0">{
                                options["max_duration"] = durationInt
                        }</span>
                }
        }

        // Format validation
        <span class="cov2" title="2">if format, exists := params["format"]; exists </span><span class="cov1" title="1">{
                if formatResult := vh.inputValidator.ValidateOptionalString(format, "format"); formatResult.HasErrors() </span><span class="cov0" title="0">{
                        result.AddError(formatResult.GetErrorMessages()[0])
                        return result
                }</span>
                <span class="cov1" title="1">if formatStr, ok := format.(string); ok &amp;&amp; formatStr != "" </span><span class="cov1" title="1">{
                        options["output_format"] = formatStr
                }</span>
        }

        // Codec validation
        <span class="cov2" title="2">if codec, exists := params["codec"]; exists </span><span class="cov1" title="1">{
                if codecResult := vh.inputValidator.ValidateOptionalString(codec, "codec"); codecResult.HasErrors() </span><span class="cov0" title="0">{
                        result.AddError(codecResult.GetErrorMessages()[0])
                        return result
                }</span>
                <span class="cov1" title="1">if codecStr, ok := codec.(string); ok &amp;&amp; codecStr != "" </span><span class="cov1" title="1">{
                        options["codec"] = codecStr
                }</span>
        }

        // Quality validation
        <span class="cov2" title="2">if quality, exists := params["quality"]; exists </span><span class="cov1" title="1">{
                if qualityResult := vh.inputValidator.ValidatePositiveInteger(quality, "quality"); qualityResult.HasErrors() </span><span class="cov0" title="0">{
                        result.AddError(qualityResult.GetErrorMessages()[0])
                        return result
                }</span>
                // Extract validated quality
                <span class="cov1" title="1">switch v := quality.(type) </span>{
                case int:<span class="cov1" title="1">
                        options["crf"] = v</span>
                case float64:<span class="cov0" title="0">
                        options["crf"] = int(v)</span>
                case string:<span class="cov0" title="0">
                        if qualityInt, err := strconv.Atoi(v); err == nil </span><span class="cov0" title="0">{
                                options["crf"] = qualityInt
                        }</span>
                }
        }

        // Use case validation
        <span class="cov2" title="2">if useCase, exists := params["use_case"]; exists </span><span class="cov1" title="1">{
                if useCaseResult := vh.inputValidator.ValidateOptionalString(useCase, "use_case"); useCaseResult.HasErrors() </span><span class="cov0" title="0">{
                        result.AddError(useCaseResult.GetErrorMessages()[0])
                        return result
                }</span>
                <span class="cov1" title="1">if useCaseStr, ok := useCase.(string); ok &amp;&amp; useCaseStr != "" </span><span class="cov1" title="1">{
                        options["use_case"] = useCaseStr
                }</span>
        }

        // Priority validation
        <span class="cov2" title="2">if priority, exists := params["priority"]; exists </span><span class="cov1" title="1">{
                if priorityResult := vh.inputValidator.ValidatePositiveInteger(priority, "priority"); priorityResult.HasErrors() </span><span class="cov0" title="0">{
                        result.AddError(priorityResult.GetErrorMessages()[0])
                        return result
                }</span>
                // Extract validated priority
                <span class="cov1" title="1">switch v := priority.(type) </span>{
                case int:<span class="cov1" title="1">
                        options["priority"] = v</span>
                case float64:<span class="cov0" title="0">
                        options["priority"] = int(v)</span>
                case string:<span class="cov0" title="0">
                        if priorityInt, err := strconv.Atoi(v); err == nil </span><span class="cov0" title="0">{
                                options["priority"] = priorityInt
                        }</span>
                }
        }

        // Auto cleanup validation
        <span class="cov2" title="2">if autoCleanup, exists := params["auto_cleanup"]; exists </span><span class="cov1" title="1">{
                if autoCleanupResult := vh.inputValidator.ValidateBooleanParameter(autoCleanup, "auto_cleanup"); autoCleanupResult.HasErrors() </span><span class="cov0" title="0">{
                        result.AddError(autoCleanupResult.GetErrorMessages()[0])
                        return result
                }</span>
                // Extract validated auto cleanup
                <span class="cov1" title="1">switch v := autoCleanup.(type) </span>{
                case bool:<span class="cov1" title="1">
                        options["auto_cleanup"] = v</span>
                case int:<span class="cov0" title="0">
                        options["auto_cleanup"] = v == 1</span>
                case float64:<span class="cov0" title="0">
                        options["auto_cleanup"] = v == 1.0</span>
                case string:<span class="cov0" title="0">
                        options["auto_cleanup"] = v == "true"</span>
                }
        }

        // Retention days validation
        <span class="cov2" title="2">if retentionDays, exists := params["retention_days"]; exists </span><span class="cov1" title="1">{
                if retentionResult := vh.inputValidator.ValidatePositiveInteger(retentionDays, "retention_days"); retentionResult.HasErrors() </span><span class="cov0" title="0">{
                        result.AddError(retentionResult.GetErrorMessages()[0])
                        return result
                }</span>
                // Extract validated retention days
                <span class="cov1" title="1">switch v := retentionDays.(type) </span>{
                case int:<span class="cov1" title="1">
                        options["retention_days"] = v</span>
                case float64:<span class="cov0" title="0">
                        options["retention_days"] = int(v)</span>
                case string:<span class="cov0" title="0">
                        if retentionInt, err := strconv.Atoi(v); err == nil </span><span class="cov0" title="0">{
                                options["retention_days"] = retentionInt
                        }</span>
                }
        }

        <span class="cov2" title="2">result.AddData("options", options)
        return result</span>
}

// ValidateSnapshotParameters validates snapshot-specific parameters
func (vh *ValidationHelper) ValidateSnapshotParameters(params map[string]interface{}) *ValidationResult <span class="cov4" title="5">{
        result := NewValidationResult()

        if params == nil </span><span class="cov1" title="1">{
                result.AddError("parameters are required")
                return result
        }</span>

        // Validate device parameter first
        <span class="cov4" title="4">deviceResult := vh.ValidateDeviceParameter(params)
        if !deviceResult.Valid </span><span class="cov1" title="1">{
                result.AddError(deviceResult.GetFirstError())
                return result
        }</span>
        <span class="cov3" title="3">result.AddData("device", deviceResult.Data["device"])

        // Validate optional parameters
        options := make(map[string]interface{})

        // Filename validation
        if filename, exists := params["filename"]; exists </span><span class="cov1" title="1">{
                if filenameResult := vh.inputValidator.ValidateOptionalString(filename, "filename"); filenameResult.HasErrors() </span><span class="cov0" title="0">{
                        result.AddError(filenameResult.GetErrorMessages()[0])
                        return result
                }</span>
                <span class="cov1" title="1">if filenameStr, ok := filename.(string); ok &amp;&amp; filenameStr != "" </span><span class="cov1" title="1">{
                        options["filename"] = filenameStr
                }</span>
        }

        // Format validation
        <span class="cov3" title="3">if format, exists := params["format"]; exists </span><span class="cov1" title="1">{
                if formatResult := vh.inputValidator.ValidateOptionalString(format, "format"); formatResult.HasErrors() </span><span class="cov0" title="0">{
                        result.AddError(formatResult.GetErrorMessages()[0])
                        return result
                }</span>
                <span class="cov1" title="1">if formatStr, ok := format.(string); ok &amp;&amp; formatStr != "" </span><span class="cov1" title="1">{
                        options["format"] = formatStr
                }</span>
        }

        // Quality validation
        <span class="cov3" title="3">if quality, exists := params["quality"]; exists </span><span class="cov2" title="2">{
                if qualityResult := vh.inputValidator.ValidatePositiveInteger(quality, "quality"); qualityResult.HasErrors() </span><span class="cov1" title="1">{
                        result.AddError(qualityResult.GetErrorMessages()[0])
                        return result
                }</span>
                // Extract validated quality
                <span class="cov1" title="1">switch v := quality.(type) </span>{
                case int:<span class="cov1" title="1">
                        options["quality"] = v</span>
                case float64:<span class="cov0" title="0">
                        options["quality"] = int(v)</span>
                case string:<span class="cov0" title="0">
                        if qualityInt, err := strconv.Atoi(v); err == nil </span><span class="cov0" title="0">{
                                options["quality"] = qualityInt
                        }</span>
                }
        }

        <span class="cov2" title="2">result.AddData("options", options)
        return result</span>
}

// ValidateRetentionPolicyParameters validates retention policy parameters
func (vh *ValidationHelper) ValidateRetentionPolicyParameters(params map[string]interface{}) *ValidationResult <span class="cov5" title="7">{
        result := NewValidationResult()

        if params == nil </span><span class="cov1" title="1">{
                result.AddError("parameters are required")
                return result
        }</span>

        // Validate policy type
        <span class="cov5" title="6">policyTypeVal, exists := params["policy_type"]
        if !exists </span><span class="cov1" title="1">{
                result.AddError("policy_type parameter is required")
                return result
        }</span>

        <span class="cov4" title="5">policyType, ok := policyTypeVal.(string)
        if !ok </span><span class="cov0" title="0">{
                result.AddError("policy_type parameter must be a string")
                return result
        }</span>

        <span class="cov4" title="5">if policyType != "age" &amp;&amp; policyType != "size" </span><span class="cov1" title="1">{
                result.AddError("policy_type must be either 'age' or 'size'")
                return result
        }</span>

        // Validate enabled flag
        <span class="cov4" title="4">enabledVal, exists := params["enabled"]
        if !exists </span><span class="cov1" title="1">{
                result.AddError("enabled parameter is required")
                return result
        }</span>

        <span class="cov3" title="3">var enabled bool
        switch v := enabledVal.(type) </span>{
        case bool:<span class="cov2" title="2">
                enabled = v</span>
        case int:<span class="cov0" title="0">
                enabled = v == 1</span>
        case float64:<span class="cov0" title="0">
                enabled = v == 1.0</span>
        case string:<span class="cov0" title="0">
                enabled = v == "true"</span>
        default:<span class="cov1" title="1">
                result.AddError("enabled parameter must be a boolean")
                return result</span>
        }

        // Validate policy-specific parameters
        <span class="cov2" title="2">if policyType == "age" </span><span class="cov1" title="1">{
                if maxAgeDays, exists := params["max_age_days"]; exists </span><span class="cov1" title="1">{
                        if maxAgeResult := vh.inputValidator.ValidatePositiveInteger(maxAgeDays, "max_age_days"); maxAgeResult.HasErrors() </span><span class="cov0" title="0">{
                                result.AddError(maxAgeResult.GetErrorMessages()[0])
                                return result
                        }</span>
                }
        } else<span class="cov1" title="1"> if policyType == "size" </span><span class="cov1" title="1">{
                if maxSizeGB, exists := params["max_size_gb"]; exists </span><span class="cov1" title="1">{
                        if maxSizeResult := vh.inputValidator.ValidatePositiveInteger(maxSizeGB, "max_size_gb"); maxSizeResult.HasErrors() </span><span class="cov0" title="0">{
                                result.AddError(maxSizeResult.GetErrorMessages()[0])
                                return result
                        }</span>
                }
        }

        <span class="cov2" title="2">result.AddData("policy_type", policyType)
        result.AddData("enabled", enabled)
        return result</span>
}

// CreateValidationErrorResponse creates a JSON-RPC error response from validation results
func (vh *ValidationHelper) CreateValidationErrorResponse(validationResult *ValidationResult) *JsonRpcResponse <span class="cov1" title="1">{
        errorData := ""
        if len(validationResult.Errors) &gt; 0 </span><span class="cov1" title="1">{
                errorData = validationResult.Errors[0]
        }</span>

        <span class="cov1" title="1">return &amp;JsonRpcResponse{
                JSONRPC: "2.0",
                Error: &amp;JsonRpcError{
                        Code:    INVALID_PARAMS,
                        Message: ErrorMessages[INVALID_PARAMS],
                        Data:    errorData,
                },
        }</span>
}

// LogValidationWarnings logs validation warnings for debugging
func (vh *ValidationHelper) LogValidationWarnings(validationResult *ValidationResult, method string, clientID string) <span class="cov2" title="2">{
        if len(validationResult.Warnings) &gt; 0 </span><span class="cov1" title="1">{
                vh.logger.WithFields(logging.Fields{
                        "client_id": clientID,
                        "method":    method,
                        "warnings":  validationResult.Warnings,
                }).Warn("Validation warnings during parameter processing")
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
