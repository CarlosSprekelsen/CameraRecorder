
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/camerarecorder/mediamtx-camera-service-go/internal/config/config_manager.go (83.3%)</option>
				
				<option value="file1">github.com/camerarecorder/mediamtx-camera-service-go/internal/config/config_validation.go (55.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "github.com/fsnotify/fsnotify"
        "github.com/sirupsen/logrus"
        "github.com/spf13/viper"
)

// ConfigManager manages configuration loading, validation, and hot reload functionality.
type ConfigManager struct {
        config          *Config
        configPath      string
        updateCallbacks []func(*Config)
        watcher         *fsnotify.Watcher
        watcherLock     sync.RWMutex
        lock            sync.RWMutex
        defaultConfig   *Config
        logger          *logrus.Logger
        stopChan        chan struct{}
        wg              sync.WaitGroup
}

// CreateConfigManager creates a new configuration manager instance.
func CreateConfigManager() *ConfigManager <span class="cov8" title="1">{
        return &amp;ConfigManager{
                updateCallbacks: make([]func(*Config), 0),
                defaultConfig:   getDefaultConfig(),
                logger:          logrus.New(),
                stopChan:        make(chan struct{}),
        }
}</span>

// LoadConfig loads configuration from YAML file with environment variable overrides and validation.
func (cm *ConfigManager) LoadConfig(configPath string) error <span class="cov8" title="1">{
        cm.lock.Lock()
        defer cm.lock.Unlock()

        cm.logger.WithFields(logrus.Fields{
                "config_path": configPath,
                "action":      "load_config",
        }).Info("Loading configuration")

        // REQ-CONFIG-001: Validate configuration files before loading
        // REQ-CONFIG-002: Fail fast on configuration errors
        // REQ-CONFIG-003: Early detection and clear error reporting
        if err := cm.validateConfigFile(configPath); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("configuration validation failed: invalid configuration - %w", err)
        }</span>

        // Set up Viper
        <span class="cov8" title="1">v := viper.New()
        v.SetConfigFile(configPath)
        v.SetConfigType("yaml")

        // Set default values
        cm.setDefaults(v)

        // Read environment variables
        v.AutomaticEnv()
        v.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
        v.SetEnvPrefix("CAMERA_SERVICE")

        // Read configuration file
        if err := v.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("configuration validation failed: invalid configuration - cannot read configuration file '%s': %w", configPath, err)
        }</span>

        // Unmarshal configuration
        <span class="cov8" title="1">var config Config
        if err := v.Unmarshal(&amp;config); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to unmarshal config: %w", err)
        }</span>

        // REQ-CONFIG-001: Validate final configuration values after environment variable overrides
        // REQ-CONFIG-002: Fail fast on configuration errors
        // REQ-CONFIG-003: Early detection and clear error reporting
        <span class="cov8" title="1">if err := cm.validateFinalConfiguration(&amp;config); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("configuration validation failed: invalid configuration - %w", err)
        }</span>

        // Validate configuration
        <span class="cov8" title="1">if err := ValidateConfig(&amp;config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("configuration validation failed: %w", err)
        }</span>

        // Store configuration
        <span class="cov8" title="1">oldConfig := cm.config
        cm.config = &amp;config
        cm.configPath = configPath

        // Start file watching for hot reload (only if explicitly enabled)
        // Hot reload is disabled by default for tests and can be enabled via environment variable
        if os.Getenv("CAMERA_SERVICE_ENABLE_HOT_RELOAD") == "true" </span><span class="cov8" title="1">{
                if err := cm.startFileWatching(); err != nil </span><span class="cov0" title="0">{
                        cm.logger.WithError(err).Warn("Failed to start file watching, hot reload disabled")
                }</span>
        }

        // Notify callbacks
        <span class="cov8" title="1">cm.notifyConfigUpdated(oldConfig, &amp;config)

        cm.logger.WithFields(logrus.Fields{
                "config_path": configPath,
                "action":      "load_config",
                "status":      "success",
        }).Info("Configuration loaded successfully")

        return nil</span>
}

// validateConfigFile validates the configuration file before loading
// REQ-CONFIG-001: The system SHALL validate configuration files before loading
// REQ-CONFIG-002: The system SHALL fail fast on configuration errors
// REQ-CONFIG-003: Edge case handling SHALL mean early detection and clear error reporting
func (cm *ConfigManager) validateConfigFile(configPath string) error <span class="cov8" title="1">{
        // Check if file exists
        if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return fmt.Errorf("configuration file does not exist: '%s'", configPath)
        }</span>

        // Read file content for validation
        <span class="cov8" title="1">content, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot read configuration file '%s': %w", configPath, err)
        }</span>

        // Check for empty file
        <span class="cov8" title="1">if len(content) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("configuration file is empty: '%s' - file must contain valid YAML configuration", configPath)
        }</span>

        // Check for comments-only file
        <span class="cov8" title="1">lines := strings.Split(string(content), "\n")
        hasNonCommentContent := false

        for _, line := range lines </span><span class="cov8" title="1">{
                trimmedLine := strings.TrimSpace(line)
                if trimmedLine == "" </span><span class="cov0" title="0">{
                        continue</span> // Skip empty lines
                }
                <span class="cov8" title="1">if strings.HasPrefix(trimmedLine, "#") </span><span class="cov8" title="1">{
                        continue</span> // Skip comment lines
                }
                <span class="cov8" title="1">hasNonCommentContent = true
                break</span>
        }

        <span class="cov8" title="1">if !hasNonCommentContent </span><span class="cov0" title="0">{
                return fmt.Errorf("configuration file contains only comments or is empty: '%s' - file must contain valid YAML configuration data", configPath)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateFinalConfiguration validates the final configuration values after environment variable overrides
// REQ-CONFIG-001: The system SHALL validate configuration files before loading
// REQ-CONFIG-002: The system SHALL fail fast on configuration errors
// REQ-CONFIG-003: Edge case handling SHALL mean early detection and clear error reporting
func (cm *ConfigManager) validateFinalConfiguration(config *Config) error <span class="cov8" title="1">{
        // Validate server configuration
        if strings.TrimSpace(config.Server.Host) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("server host cannot be empty or whitespace-only")
        }</span>
        <span class="cov8" title="1">if config.Server.Port &lt;= 0 || config.Server.Port &gt; 65535 </span><span class="cov8" title="1">{
                return fmt.Errorf("server port must be between 1 and 65535, got %d", config.Server.Port)
        }</span>

        // Validate MediaMTX configuration
        <span class="cov8" title="1">if strings.TrimSpace(config.MediaMTX.Host) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("MediaMTX host cannot be empty or whitespace-only")
        }</span>
        <span class="cov8" title="1">if config.MediaMTX.APIPort &lt;= 0 || config.MediaMTX.APIPort &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("MediaMTX API port must be between 1 and 65535, got %d", config.MediaMTX.APIPort)
        }</span>
        <span class="cov8" title="1">if config.MediaMTX.RTSPPort &lt;= 0 || config.MediaMTX.RTSPPort &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("MediaMTX RTSP port must be between 1 and 65535, got %d", config.MediaMTX.RTSPPort)
        }</span>
        <span class="cov8" title="1">if config.MediaMTX.WebRTCPort &lt;= 0 || config.MediaMTX.WebRTCPort &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("MediaMTX WebRTC port must be between 1 and 65535, got %d", config.MediaMTX.WebRTCPort)
        }</span>
        <span class="cov8" title="1">if config.MediaMTX.HLSPort &lt;= 0 || config.MediaMTX.HLSPort &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("MediaMTX HLS port must be between 1 and 65535, got %d", config.MediaMTX.HLSPort)
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(config.MediaMTX.ConfigPath) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("MediaMTX config path cannot be empty or whitespace-only")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(config.MediaMTX.RecordingsPath) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("MediaMTX recordings path cannot be empty or whitespace-only")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(config.MediaMTX.SnapshotsPath) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("MediaMTX snapshots path cannot be empty or whitespace-only")
        }</span>

        // Validate camera configuration
        <span class="cov8" title="1">if config.Camera.PollInterval &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("camera poll interval must be positive, got %f", config.Camera.PollInterval)
        }</span>
        <span class="cov8" title="1">if config.Camera.DetectionTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("camera detection timeout must be positive, got %f", config.Camera.DetectionTimeout)
        }</span>
        <span class="cov8" title="1">if config.Camera.CapabilityTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("camera capability timeout must be positive, got %f", config.Camera.CapabilityTimeout)
        }</span>
        <span class="cov8" title="1">if config.Camera.CapabilityRetryInterval &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("camera capability retry interval must be positive, got %f", config.Camera.CapabilityRetryInterval)
        }</span>
        <span class="cov8" title="1">if config.Camera.CapabilityMaxRetries &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("camera capability max retries cannot be negative, got %d", config.Camera.CapabilityMaxRetries)
        }</span>

        // Validate logging configuration
        <span class="cov8" title="1">validLogLevels := []string{"debug", "info", "warn", "warning", "error", "fatal", "panic"}
        levelFound := false
        for _, valid := range validLogLevels </span><span class="cov8" title="1">{
                if strings.ToLower(config.Logging.Level) == valid </span><span class="cov8" title="1">{
                        levelFound = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !levelFound </span><span class="cov0" title="0">{
                return fmt.Errorf("logging level must be one of: %v, got %s", validLogLevels, config.Logging.Level)
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(config.Logging.Format) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("logging format cannot be empty or whitespace-only")
        }</span>
        <span class="cov8" title="1">if config.Logging.FileEnabled &amp;&amp; strings.TrimSpace(config.Logging.FilePath) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("logging file path cannot be empty when file logging is enabled")
        }</span>

        // Validate recording configuration
        <span class="cov8" title="1">if strings.TrimSpace(config.Recording.Format) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("recording format cannot be empty or whitespace-only")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(config.Recording.Quality) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("recording quality cannot be empty or whitespace-only")
        }</span>
        <span class="cov8" title="1">if config.Recording.SegmentDuration &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("recording segment duration cannot be negative, got %d", config.Recording.SegmentDuration)
        }</span>
        <span class="cov8" title="1">if config.Recording.MaxSegmentSize &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("recording max segment size cannot be negative, got %d", config.Recording.MaxSegmentSize)
        }</span>
        <span class="cov8" title="1">if config.Recording.CleanupInterval &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("recording cleanup interval cannot be negative, got %d", config.Recording.CleanupInterval)
        }</span>
        <span class="cov8" title="1">if config.Recording.MaxAge &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("recording max age cannot be negative, got %d", config.Recording.MaxAge)
        }</span>
        <span class="cov8" title="1">if config.Recording.MaxSize &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("recording max size must be positive, got %d", config.Recording.MaxSize)
        }</span>
        <span class="cov8" title="1">if config.Recording.DefaultRotationSize &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("recording default rotation size cannot be negative, got %d", config.Recording.DefaultRotationSize)
        }</span>
        <span class="cov8" title="1">if config.Recording.DefaultMaxDuration &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("recording default max duration cannot be negative, got %v", config.Recording.DefaultMaxDuration)
        }</span>
        <span class="cov8" title="1">if config.Recording.DefaultRetentionDays &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("recording default retention days cannot be negative, got %d", config.Recording.DefaultRetentionDays)
        }</span>

        // Validate snapshots configuration
        <span class="cov8" title="1">if strings.TrimSpace(config.Snapshots.Format) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("snapshots format cannot be empty or whitespace-only")
        }</span>
        <span class="cov8" title="1">if config.Snapshots.Quality &lt; 0 || config.Snapshots.Quality &gt; 100 </span><span class="cov0" title="0">{
                return fmt.Errorf("snapshots quality must be between 0 and 100, got %d", config.Snapshots.Quality)
        }</span>
        <span class="cov8" title="1">if config.Snapshots.MaxWidth &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("snapshots max width must be positive, got %d", config.Snapshots.MaxWidth)
        }</span>
        <span class="cov8" title="1">if config.Snapshots.MaxHeight &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("snapshots max height must be positive, got %d", config.Snapshots.MaxHeight)
        }</span>
        <span class="cov8" title="1">if config.Snapshots.CleanupInterval &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("snapshots cleanup interval cannot be negative, got %d", config.Snapshots.CleanupInterval)
        }</span>
        <span class="cov8" title="1">if config.Snapshots.MaxAge &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("snapshots max age cannot be negative, got %d", config.Snapshots.MaxAge)
        }</span>
        <span class="cov8" title="1">if config.Snapshots.MaxCount &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("snapshots max count must be positive, got %d", config.Snapshots.MaxCount)
        }</span>

        // Validate storage configuration
        <span class="cov8" title="1">if config.Storage.WarnPercent &lt; 0 || config.Storage.WarnPercent &gt; 100 </span><span class="cov0" title="0">{
                return fmt.Errorf("storage warn percent must be between 0 and 100, got %d", config.Storage.WarnPercent)
        }</span>
        <span class="cov8" title="1">if config.Storage.BlockPercent &lt; 0 || config.Storage.BlockPercent &gt; 100 </span><span class="cov0" title="0">{
                return fmt.Errorf("storage block percent must be between 0 and 100, got %d", config.Storage.BlockPercent)
        }</span>
        <span class="cov8" title="1">if config.Storage.WarnPercent &gt;= config.Storage.BlockPercent </span><span class="cov8" title="1">{
                return fmt.Errorf("storage warn percent (%d) must be less than block percent (%d)", config.Storage.WarnPercent, config.Storage.BlockPercent)
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(config.Storage.DefaultPath) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("storage default path cannot be empty or whitespace-only")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(config.Storage.FallbackPath) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("storage fallback path cannot be empty or whitespace-only")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// startFileWatching starts watching the configuration file for changes.
func (cm *ConfigManager) startFileWatching() error <span class="cov8" title="1">{
        // Stop existing watcher if any
        cm.stopFileWatching()

        // Create new watcher
        watcher, err := fsnotify.NewWatcher()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create file watcher: %w", err)
        }</span>

        <span class="cov8" title="1">cm.watcherLock.Lock()
        cm.watcher = watcher
        cm.watcherLock.Unlock()

        // Watch the directory containing the config file
        configDir := filepath.Dir(cm.configPath)
        if err := cm.watcher.Add(configDir); err != nil </span><span class="cov0" title="0">{
                cm.watcher.Close()
                cm.watcherLock.Lock()
                cm.watcher = nil
                cm.watcherLock.Unlock()
                return fmt.Errorf("failed to watch config directory %s: %w", configDir, err)
        }</span>

        // Start watching goroutine
        <span class="cov8" title="1">cm.wg.Add(1)
        go cm.watchFileChanges()

        cm.logger.WithFields(logrus.Fields{
                "config_path": cm.configPath,
                "watch_dir":   configDir,
        }).Info("File watching started for hot reload")

        return nil</span>
}

// stopFileWatching stops the file watcher.
func (cm *ConfigManager) stopFileWatching() <span class="cov8" title="1">{
        cm.watcherLock.Lock()
        defer cm.watcherLock.Unlock()

        if cm.watcher != nil </span><span class="cov8" title="1">{
                // Close watcher safely
                if err := cm.watcher.Close(); err != nil </span><span class="cov0" title="0">{
                        cm.logger.WithError(err).Warn("Error closing file watcher")
                }</span>
                <span class="cov8" title="1">cm.watcher = nil
                cm.logger.Debug("File watcher stopped and cleaned up")</span>
        }
}

// watchFileChanges watches for file changes and triggers configuration reload.
func (cm *ConfigManager) watchFileChanges() <span class="cov8" title="1">{
        defer cm.wg.Done()

        // Debounce timer to avoid multiple reloads
        var reloadTimer *time.Timer

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-cm.stopChan:<span class="cov0" title="0">
                        return</span>
                default:<span class="cov8" title="1">
                        // Check if watcher is still valid before accessing its channels
                        cm.watcherLock.RLock()
                        if cm.watcher == nil </span><span class="cov0" title="0">{
                                cm.watcherLock.RUnlock()
                                return
                        }</span>
                        <span class="cov8" title="1">events := cm.watcher.Events
                        errors := cm.watcher.Errors
                        cm.watcherLock.RUnlock()

                        // Use a select with timeout to avoid blocking indefinitely
                        select </span>{
                        case &lt;-cm.stopChan:<span class="cov8" title="1">
                                return</span>
                        case event, ok := &lt;-events:<span class="cov8" title="1">
                                if !ok </span><span class="cov0" title="0">{
                                        return
                                }</span>

                                // Check if the changed file is our config file
                                <span class="cov8" title="1">if event.Name == cm.configPath </span><span class="cov8" title="1">{
                                        cm.logger.WithFields(logrus.Fields{
                                                "file":  event.Name,
                                                "event": event.Op.String(),
                                        }).Debug("Configuration file change detected")

                                        // Handle different event types
                                        switch event.Op </span>{
                                        case fsnotify.Write, fsnotify.Create:<span class="cov8" title="1">
                                                // Debounce reload to avoid multiple rapid reloads
                                                if reloadTimer != nil </span><span class="cov8" title="1">{
                                                        reloadTimer.Stop()
                                                }</span>
                                                <span class="cov8" title="1">reloadTimer = time.AfterFunc(100*time.Millisecond, func() </span><span class="cov8" title="1">{
                                                        cm.reloadConfiguration()
                                                }</span>)
                                        case fsnotify.Remove:<span class="cov0" title="0">
                                                cm.logger.Warn("Configuration file was removed, hot reload disabled")
                                                cm.stopFileWatching()
                                                return</span> // Exit the goroutine when file is removed
                                        }
                                }

                        case err, ok := &lt;-errors:<span class="cov8" title="1">
                                if !ok </span><span class="cov8" title="1">{
                                        return
                                }</span>
                                <span class="cov0" title="0">cm.logger.WithError(err).Error("File watcher error")</span>
                        case &lt;-time.After(100 * time.Millisecond):<span class="cov8" title="1">
                                // Continue loop to check stopChan and watcher validity
                                continue</span>
                        }
                }
        }
}

// reloadConfiguration reloads the configuration file.
func (cm *ConfigManager) reloadConfiguration() <span class="cov8" title="1">{
        cm.logger.Info("Reloading configuration due to file change")

        // Check if file still exists
        if _, err := os.Stat(cm.configPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                cm.logger.Warn("Configuration file no longer exists, stopping hot reload")
                cm.stopFileWatching()
                return
        }</span>

        // Reload configuration
        <span class="cov8" title="1">if err := cm.LoadConfig(cm.configPath); err != nil </span><span class="cov0" title="0">{
                cm.logger.WithError(err).Error("Failed to reload configuration")
                return
        }</span>

        <span class="cov8" title="1">cm.logger.Info("Configuration reloaded successfully")</span>
}

// Stop stops the configuration manager and cleans up resources.
func (cm *ConfigManager) Stop() <span class="cov8" title="1">{
        cm.logger.Info("Stopping configuration manager")

        // Signal stop
        close(cm.stopChan)

        // Stop file watching
        cm.stopFileWatching()

        // Wait for goroutines to finish
        cm.wg.Wait()

        cm.logger.Info("Configuration manager stopped")
}</span>

// GetConfig returns the current configuration.
func (cm *ConfigManager) GetConfig() *Config <span class="cov8" title="1">{
        cm.lock.RLock()
        defer cm.lock.RUnlock()

        if cm.config == nil </span><span class="cov0" title="0">{
                return cm.defaultConfig
        }</span>
        <span class="cov8" title="1">return cm.config</span>
}

// SaveConfig saves the current configuration to the configuration file.
func (cm *ConfigManager) SaveConfig() error <span class="cov8" title="1">{
        cm.lock.Lock()
        defer cm.lock.Unlock()

        if cm.config == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("no configuration to save")
        }</span>

        <span class="cov8" title="1">if cm.configPath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("no configuration file path set")
        }</span>

        <span class="cov8" title="1">cm.logger.WithFields(logrus.Fields{
                "config_path": cm.configPath,
                "action":      "save_config",
        }).Info("Saving configuration to file")

        // Create a new Viper instance for saving
        v := viper.New()
        v.SetConfigFile(cm.configPath)
        v.SetConfigType("yaml")

        // Set all configuration values
        cm.setConfigValues(v, cm.config)

        // Ensure the directory exists
        configDir := filepath.Dir(cm.configPath)
        if err := os.MkdirAll(configDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create config directory: %w", err)
        }</span>

        // Write the configuration to file
        <span class="cov8" title="1">if err := v.WriteConfig(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>

        <span class="cov8" title="1">cm.logger.WithFields(logrus.Fields{
                "config_path": cm.configPath,
                "action":      "save_config",
                "status":      "success",
        }).Info("Configuration saved successfully")

        return nil</span>
}

// setConfigValues recursively sets configuration values in Viper
func (cm *ConfigManager) setConfigValues(v *viper.Viper, config *Config) <span class="cov8" title="1">{
        // Server configuration
        v.Set("server.host", config.Server.Host)
        v.Set("server.port", config.Server.Port)
        v.Set("server.websocket_path", config.Server.WebSocketPath)
        v.Set("server.max_connections", config.Server.MaxConnections)
        v.Set("server.read_timeout", config.Server.ReadTimeout)
        v.Set("server.write_timeout", config.Server.WriteTimeout)
        v.Set("server.ping_interval", config.Server.PingInterval)
        v.Set("server.pong_wait", config.Server.PongWait)
        v.Set("server.max_message_size", config.Server.MaxMessageSize)

        // MediaMTX configuration
        v.Set("mediamtx.host", config.MediaMTX.Host)
        v.Set("mediamtx.api_port", config.MediaMTX.APIPort)
        v.Set("mediamtx.rtsp_port", config.MediaMTX.RTSPPort)
        v.Set("mediamtx.webrtc_port", config.MediaMTX.WebRTCPort)
        v.Set("mediamtx.hls_port", config.MediaMTX.HLSPort)
        v.Set("mediamtx.config_path", config.MediaMTX.ConfigPath)
        v.Set("mediamtx.recordings_path", config.MediaMTX.RecordingsPath)
        v.Set("mediamtx.snapshots_path", config.MediaMTX.SnapshotsPath)
        v.Set("mediamtx.health_check_interval", config.MediaMTX.HealthCheckInterval)
        v.Set("mediamtx.health_failure_threshold", config.MediaMTX.HealthFailureThreshold)
        v.Set("mediamtx.health_circuit_breaker_timeout", config.MediaMTX.HealthCircuitBreakerTimeout)
        v.Set("mediamtx.health_max_backoff_interval", config.MediaMTX.HealthMaxBackoffInterval)
        v.Set("mediamtx.health_recovery_confirmation_threshold", config.MediaMTX.HealthRecoveryConfirmationThreshold)
        v.Set("mediamtx.backoff_base_multiplier", config.MediaMTX.BackoffBaseMultiplier)
        v.Set("mediamtx.backoff_jitter_range", config.MediaMTX.BackoffJitterRange)
        v.Set("mediamtx.process_termination_timeout", config.MediaMTX.ProcessTerminationTimeout)
        v.Set("mediamtx.process_kill_timeout", config.MediaMTX.ProcessKillTimeout)
        v.Set("mediamtx.health_check_timeout", config.MediaMTX.HealthCheckTimeout)

        // Camera configuration
        v.Set("camera.poll_interval", config.Camera.PollInterval)
        v.Set("camera.detection_timeout", config.Camera.DetectionTimeout)
        v.Set("camera.device_range", config.Camera.DeviceRange)
        v.Set("camera.enable_capability_detection", config.Camera.EnableCapabilityDetection)
        v.Set("camera.auto_start_streams", config.Camera.AutoStartStreams)
        v.Set("camera.capability_timeout", config.Camera.CapabilityTimeout)
        v.Set("camera.capability_retry_interval", config.Camera.CapabilityRetryInterval)
        v.Set("camera.capability_max_retries", config.Camera.CapabilityMaxRetries)

        // Logging configuration
        v.Set("logging.level", config.Logging.Level)
        v.Set("logging.format", config.Logging.Format)
        v.Set("logging.file_enabled", config.Logging.FileEnabled)
        v.Set("logging.file_path", config.Logging.FilePath)
        v.Set("logging.max_file_size", config.Logging.MaxFileSize)
        v.Set("logging.backup_count", config.Logging.BackupCount)
        v.Set("logging.console_enabled", config.Logging.ConsoleEnabled)

        // Recording configuration
        v.Set("recording.enabled", config.Recording.Enabled)
        v.Set("recording.format", config.Recording.Format)
        v.Set("recording.quality", config.Recording.Quality)
        v.Set("recording.segment_duration", config.Recording.SegmentDuration)
        v.Set("recording.max_segment_size", config.Recording.MaxSegmentSize)
        v.Set("recording.auto_cleanup", config.Recording.AutoCleanup)
        v.Set("recording.cleanup_interval", config.Recording.CleanupInterval)
        v.Set("recording.max_age", config.Recording.MaxAge)
        v.Set("recording.max_size", config.Recording.MaxSize)

        // Snapshots configuration
        v.Set("snapshots.enabled", config.Snapshots.Enabled)
        v.Set("snapshots.format", config.Snapshots.Format)
        v.Set("snapshots.quality", config.Snapshots.Quality)
        v.Set("snapshots.max_width", config.Snapshots.MaxWidth)
        v.Set("snapshots.max_height", config.Snapshots.MaxHeight)
        v.Set("snapshots.auto_cleanup", config.Snapshots.AutoCleanup)
        v.Set("snapshots.cleanup_interval", config.Snapshots.CleanupInterval)
        v.Set("snapshots.max_age", config.Snapshots.MaxAge)
        v.Set("snapshots.max_count", config.Snapshots.MaxCount)

        // Retention policy configuration
        v.Set("retention_policy.enabled", config.RetentionPolicy.Enabled)
        v.Set("retention_policy.type", config.RetentionPolicy.Type)
        v.Set("retention_policy.max_age_days", config.RetentionPolicy.MaxAgeDays)
        v.Set("retention_policy.max_size_gb", config.RetentionPolicy.MaxSizeGB)
        v.Set("retention_policy.auto_cleanup", config.RetentionPolicy.AutoCleanup)
}</span>

// AddUpdateCallback adds a callback function to be called when configuration is updated.
func (cm *ConfigManager) AddUpdateCallback(callback func(*Config)) <span class="cov8" title="1">{
        cm.lock.Lock()
        defer cm.lock.Unlock()
        cm.updateCallbacks = append(cm.updateCallbacks, callback)
}</span>

// setDefaults sets default configuration values in Viper.
func (cm *ConfigManager) setDefaults(v *viper.Viper) <span class="cov8" title="1">{
        // Server defaults
        v.SetDefault("server.host", "0.0.0.0")
        v.SetDefault("server.port", 8002)
        v.SetDefault("server.websocket_path", "/ws")
        v.SetDefault("server.max_connections", 100)

        // MediaMTX defaults
        v.SetDefault("mediamtx.host", "127.0.0.1")
        v.SetDefault("mediamtx.api_port", 9997)
        v.SetDefault("mediamtx.rtsp_port", 8554)
        v.SetDefault("mediamtx.webrtc_port", 8889)
        v.SetDefault("mediamtx.hls_port", 8888)
        v.SetDefault("mediamtx.config_path", "/opt/camera-service/config/mediamtx.yml")
        v.SetDefault("mediamtx.recordings_path", "/opt/camera-service/recordings")
        v.SetDefault("mediamtx.snapshots_path", "/opt/camera-service/snapshots")

        // MediaMTX codec defaults
        v.SetDefault("mediamtx.codec.video_profile", "baseline")
        v.SetDefault("mediamtx.codec.video_level", "3.0")
        v.SetDefault("mediamtx.codec.pixel_format", "yuv420p")
        v.SetDefault("mediamtx.codec.bitrate", "600k")
        v.SetDefault("mediamtx.codec.preset", "ultrafast")

        // MediaMTX health monitoring defaults
        v.SetDefault("mediamtx.health_check_interval", 30)
        v.SetDefault("mediamtx.health_failure_threshold", 10)
        v.SetDefault("mediamtx.health_circuit_breaker_timeout", 60)
        v.SetDefault("mediamtx.health_max_backoff_interval", 120)
        v.SetDefault("mediamtx.health_recovery_confirmation_threshold", 3)
        v.SetDefault("mediamtx.health_check_timeout", "5s")
        v.SetDefault("mediamtx.backoff_base_multiplier", 2.0)
        v.SetDefault("mediamtx.backoff_jitter_range", []float64{0.8, 1.2})
        v.SetDefault("mediamtx.process_termination_timeout", 3.0)
        v.SetDefault("mediamtx.process_kill_timeout", 2.0)

        // MediaMTX stream readiness defaults
        v.SetDefault("mediamtx.stream_readiness.timeout", 15.0)
        v.SetDefault("mediamtx.stream_readiness.retry_attempts", 3)
        v.SetDefault("mediamtx.stream_readiness.retry_delay", 2.0)
        v.SetDefault("mediamtx.stream_readiness.check_interval", 0.5)
        v.SetDefault("mediamtx.stream_readiness.enable_progress_notifications", true)
        v.SetDefault("mediamtx.stream_readiness.graceful_fallback", true)

        // FFmpeg defaults
        v.SetDefault("ffmpeg.snapshot.process_creation_timeout", 5.0)
        v.SetDefault("ffmpeg.snapshot.execution_timeout", 8.0)
        v.SetDefault("ffmpeg.snapshot.internal_timeout", 5000000)
        v.SetDefault("ffmpeg.snapshot.retry_attempts", 2)
        v.SetDefault("ffmpeg.snapshot.retry_delay", 1.0)

        v.SetDefault("ffmpeg.recording.process_creation_timeout", 10.0)
        v.SetDefault("ffmpeg.recording.execution_timeout", 15.0)
        v.SetDefault("ffmpeg.recording.internal_timeout", 10000000)
        v.SetDefault("ffmpeg.recording.retry_attempts", 3)
        v.SetDefault("ffmpeg.recording.retry_delay", 2.0)

        // Notifications defaults
        v.SetDefault("notifications.websocket.delivery_timeout", 5.0)
        v.SetDefault("notifications.websocket.retry_attempts", 3)
        v.SetDefault("notifications.websocket.retry_delay", 1.0)
        v.SetDefault("notifications.websocket.max_queue_size", 1000)
        v.SetDefault("notifications.websocket.cleanup_interval", 30)

        v.SetDefault("notifications.real_time.camera_status_interval", 1.0)
        v.SetDefault("notifications.real_time.recording_progress_interval", 0.5)
        v.SetDefault("notifications.real_time.connection_health_check", 10.0)

        // Performance defaults
        v.SetDefault("performance.response_time_targets.snapshot_capture", 2.0)
        v.SetDefault("performance.response_time_targets.recording_start", 2.0)
        v.SetDefault("performance.response_time_targets.recording_stop", 2.0)
        v.SetDefault("performance.response_time_targets.file_listing", 1.0)

        v.SetDefault("performance.snapshot_tiers.tier1_usb_direct_timeout", 0.5)
        v.SetDefault("performance.snapshot_tiers.tier2_rtsp_ready_check_timeout", 1.0)
        v.SetDefault("performance.snapshot_tiers.tier3_activation_timeout", 3.0)
        v.SetDefault("performance.snapshot_tiers.tier3_activation_trigger_timeout", 1.0)
        v.SetDefault("performance.snapshot_tiers.total_operation_timeout", 10.0)
        v.SetDefault("performance.snapshot_tiers.immediate_response_threshold", 0.5)
        v.SetDefault("performance.snapshot_tiers.acceptable_response_threshold", 2.0)
        v.SetDefault("performance.snapshot_tiers.slow_response_threshold", 5.0)

        v.SetDefault("performance.optimization.enable_caching", true)
        v.SetDefault("performance.optimization.cache_ttl", 300)
        v.SetDefault("performance.optimization.max_concurrent_operations", 5)
        v.SetDefault("performance.optimization.connection_pool_size", 10)

        // Camera defaults
        v.SetDefault("camera.poll_interval", 0.1)
        v.SetDefault("camera.detection_timeout", 2.0)
        v.SetDefault("camera.device_range", []int{0, 9})
        v.SetDefault("camera.enable_capability_detection", true)
        v.SetDefault("camera.auto_start_streams", true)
        v.SetDefault("camera.capability_timeout", 5.0)
        v.SetDefault("camera.capability_retry_interval", 1.0)
        v.SetDefault("camera.capability_max_retries", 3)

        // Retention policy defaults
        v.SetDefault("retention_policy.enabled", true)
        v.SetDefault("retention_policy.type", "age")
        v.SetDefault("retention_policy.max_age_days", 7)
        v.SetDefault("retention_policy.max_size_gb", 1)
        v.SetDefault("retention_policy.auto_cleanup", true)

        // Logging defaults
        v.SetDefault("logging.level", "INFO")
        v.SetDefault("logging.format", "%(asctime)s - %(name)s - %(levelname)s - %(message)s")
        v.SetDefault("logging.file_enabled", true)
        v.SetDefault("logging.file_path", "/opt/camera-service/logs/camera-service.log")
        v.SetDefault("logging.max_file_size", 10485760)
        v.SetDefault("logging.backup_count", 5)
        v.SetDefault("logging.console_enabled", true)

        // Recording defaults
        v.SetDefault("recording.enabled", false)
        v.SetDefault("recording.format", "fmp4")
        v.SetDefault("recording.quality", "high")
        v.SetDefault("recording.segment_duration", 3600)
        v.SetDefault("recording.max_segment_size", 524288000)
        v.SetDefault("recording.auto_cleanup", true)
        v.SetDefault("recording.cleanup_interval", 86400)
        v.SetDefault("recording.max_age", 604800)
        v.SetDefault("recording.max_size", 10737418240)

        // Snapshots defaults
        v.SetDefault("snapshots.enabled", true)
        v.SetDefault("snapshots.format", "jpeg")
        v.SetDefault("snapshots.quality", 90)
        v.SetDefault("snapshots.max_width", 1920)
        v.SetDefault("snapshots.max_height", 1080)
        v.SetDefault("snapshots.auto_cleanup", true)
        v.SetDefault("snapshots.cleanup_interval", 3600)
        v.SetDefault("snapshots.max_age", 86400)
        v.SetDefault("snapshots.max_count", 1000)

        // Storage defaults
        v.SetDefault("storage.warn_percent", 80)
        v.SetDefault("storage.block_percent", 90)
        v.SetDefault("storage.default_path", "/opt/camera-service/recordings")
        v.SetDefault("storage.fallback_path", "/tmp/recordings")
}</span>

// notifyConfigUpdated notifies all registered callbacks of configuration updates.
func (cm *ConfigManager) notifyConfigUpdated(oldConfig, newConfig *Config) <span class="cov8" title="1">{
        for _, callback := range cm.updateCallbacks </span><span class="cov8" title="1">{
                go func(cb func(*Config), config *Config) </span><span class="cov8" title="1">{
                        defer func() </span><span class="cov8" title="1">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        cm.logger.WithError(fmt.Errorf("panic in config callback: %v", r)).Error("Config callback panic")
                                }</span>
                        }()
                        <span class="cov8" title="1">cb(config)</span>
                }(callback, newConfig)
        }
}

// getDefaultConfig returns a default configuration instance.
func getDefaultConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                Server: ServerConfig{
                        Host:           "0.0.0.0",
                        Port:           8002,
                        WebSocketPath:  "/ws",
                        MaxConnections: 100,
                },
                MediaMTX: MediaMTXConfig{
                        Host:                                "127.0.0.1",
                        APIPort:                             9997,
                        RTSPPort:                            8554,
                        WebRTCPort:                          8889,
                        HLSPort:                             8888,
                        ConfigPath:                          "/opt/camera-service/config/mediamtx.yml",
                        RecordingsPath:                      "/opt/camera-service/recordings",
                        SnapshotsPath:                       "/opt/camera-service/snapshots",
                        HealthCheckInterval:                 30,
                        HealthFailureThreshold:              10,
                        HealthCircuitBreakerTimeout:         60,
                        HealthMaxBackoffInterval:            120,
                        HealthRecoveryConfirmationThreshold: 3,
                        BackoffBaseMultiplier:               2.0,
                        BackoffJitterRange:                  []float64{0.8, 1.2},
                        ProcessTerminationTimeout:           3.0,
                        ProcessKillTimeout:                  2.0,
                },
                Camera: CameraConfig{
                        PollInterval:              0.1,
                        DetectionTimeout:          2.0,
                        DeviceRange:               []int{0, 9},
                        EnableCapabilityDetection: true,
                        AutoStartStreams:          true,
                        CapabilityTimeout:         5.0,
                        CapabilityRetryInterval:   1.0,
                        CapabilityMaxRetries:      3,
                },
                Logging: LoggingConfig{
                        Level:          "INFO",
                        Format:         "%(asctime)s - %(name)s - %(levelname)s - %(message)s",
                        FileEnabled:    true,
                        FilePath:       "/opt/camera-service/logs/camera-service.log",
                        MaxFileSize:    10485760,
                        BackupCount:    5,
                        ConsoleEnabled: true,
                },
                Recording: RecordingConfig{
                        Enabled:         false,
                        Format:          "fmp4",
                        Quality:         "high",
                        SegmentDuration: 3600,
                        MaxSegmentSize:  524288000,
                        AutoCleanup:     true,
                        CleanupInterval: 86400,
                        MaxAge:          604800,
                        MaxSize:         10737418240,
                },
                Snapshots: SnapshotConfig{
                        Enabled:         true,
                        Format:          "jpeg",
                        Quality:         90,
                        MaxWidth:        1920,
                        MaxHeight:       1080,
                        AutoCleanup:     true,
                        CleanupInterval: 3600,
                        MaxAge:          86400,
                        MaxCount:        1000,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "fmt"
        "strings"
)

// ValidationError represents a configuration validation error.
type ValidationError struct {
        Field   string
        Message string
}

func (e *ValidationError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("validation error for field '%s': %s", e.Field, e.Message)
}</span>

// ValidateConfig performs comprehensive validation of the configuration.
func ValidateConfig(config *Config) error <span class="cov8" title="1">{
        var errors []error

        // Validate each configuration section
        if err := validateServerConfig(&amp;config.Server); err != nil </span><span class="cov0" title="0">{
                errors = append(errors, err)
        }</span>

        <span class="cov8" title="1">if err := validateMediaMTXConfig(&amp;config.MediaMTX); err != nil </span><span class="cov0" title="0">{
                errors = append(errors, err)
        }</span>

        <span class="cov8" title="1">if err := validateCameraConfig(&amp;config.Camera); err != nil </span><span class="cov0" title="0">{
                errors = append(errors, err)
        }</span>

        <span class="cov8" title="1">if err := validateLoggingConfig(&amp;config.Logging); err != nil </span><span class="cov0" title="0">{
                errors = append(errors, err)
        }</span>

        <span class="cov8" title="1">if err := validateRecordingConfig(&amp;config.Recording); err != nil </span><span class="cov0" title="0">{
                errors = append(errors, err)
        }</span>

        <span class="cov8" title="1">if err := validateSnapshotConfig(&amp;config.Snapshots); err != nil </span><span class="cov0" title="0">{
                errors = append(errors, err)
        }</span>

        <span class="cov8" title="1">if err := validateFFmpegConfig(&amp;config.FFmpeg); err != nil </span><span class="cov0" title="0">{
                errors = append(errors, err)
        }</span>

        <span class="cov8" title="1">if err := validateNotificationsConfig(&amp;config.Notifications); err != nil </span><span class="cov0" title="0">{
                errors = append(errors, err)
        }</span>

        <span class="cov8" title="1">if err := validatePerformanceConfig(&amp;config.Performance); err != nil </span><span class="cov0" title="0">{
                errors = append(errors, err)
        }</span>

        <span class="cov8" title="1">if err := validateRetentionPolicyConfig(&amp;config.RetentionPolicy); err != nil </span><span class="cov0" title="0">{
                errors = append(errors, err)
        }</span>

        // Return combined errors if any
        <span class="cov8" title="1">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{
                        Field:   "config",
                        Message: fmt.Sprintf("configuration validation failed: %v", errors),
                }
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateServerConfig validates server configuration.
func validateServerConfig(config *ServerConfig) error <span class="cov8" title="1">{
        if config.Host == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "server.host", Message: "host cannot be empty"}
        }</span>

        <span class="cov8" title="1">if config.Port &lt;= 0 || config.Port &gt; 65535 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "server.port", Message: fmt.Sprintf("port must be between 1 and 65535, got %d", config.Port)}
        }</span>

        <span class="cov8" title="1">if config.WebSocketPath == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "server.websocket_path", Message: "websocket path cannot be empty"}
        }</span>

        <span class="cov8" title="1">if !strings.HasPrefix(config.WebSocketPath, "/") </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "server.websocket_path", Message: "websocket path must start with '/'"}
        }</span>

        <span class="cov8" title="1">if config.MaxConnections &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "server.max_connections", Message: fmt.Sprintf("max connections must be positive, got %d", config.MaxConnections)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateMediaMTXConfig validates MediaMTX configuration.
func validateMediaMTXConfig(config *MediaMTXConfig) error <span class="cov8" title="1">{
        if config.Host == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.host", Message: "host cannot be empty"}
        }</span>

        <span class="cov8" title="1">if config.APIPort &lt;= 0 || config.APIPort &gt; 65535 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.api_port", Message: fmt.Sprintf("API port must be between 1 and 65535, got %d", config.APIPort)}
        }</span>

        <span class="cov8" title="1">if config.RTSPPort &lt;= 0 || config.RTSPPort &gt; 65535 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.rtsp_port", Message: fmt.Sprintf("RTSP port must be between 1 and 65535, got %d", config.RTSPPort)}
        }</span>

        <span class="cov8" title="1">if config.WebRTCPort &lt;= 0 || config.WebRTCPort &gt; 65535 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.webrtc_port", Message: fmt.Sprintf("WebRTC port must be between 1 and 65535, got %d", config.WebRTCPort)}
        }</span>

        <span class="cov8" title="1">if config.HLSPort &lt;= 0 || config.HLSPort &gt; 65535 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.hls_port", Message: fmt.Sprintf("HLS port must be between 1 and 65535, got %d", config.HLSPort)}
        }</span>

        <span class="cov8" title="1">if config.ConfigPath == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.config_path", Message: "config path cannot be empty"}
        }</span>

        <span class="cov8" title="1">if config.RecordingsPath == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.recordings_path", Message: "recordings path cannot be empty"}
        }</span>

        <span class="cov8" title="1">if config.SnapshotsPath == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.snapshots_path", Message: "snapshots path cannot be empty"}
        }</span>

        // Validate codec configuration
        <span class="cov8" title="1">if err := validateCodecConfig(&amp;config.Codec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate health monitoring configuration
        <span class="cov8" title="1">if config.HealthCheckInterval &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.health_check_interval", Message: fmt.Sprintf("health check interval must be positive, got %d", config.HealthCheckInterval)}
        }</span>

        <span class="cov8" title="1">if config.HealthFailureThreshold &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.health_failure_threshold", Message: fmt.Sprintf("health failure threshold must be positive, got %d", config.HealthFailureThreshold)}
        }</span>

        <span class="cov8" title="1">if config.HealthCircuitBreakerTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.health_circuit_breaker_timeout", Message: fmt.Sprintf("circuit breaker timeout must be positive, got %d", config.HealthCircuitBreakerTimeout)}
        }</span>

        <span class="cov8" title="1">if config.HealthMaxBackoffInterval &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.health_max_backoff_interval", Message: fmt.Sprintf("max backoff interval must be positive, got %d", config.HealthMaxBackoffInterval)}
        }</span>

        <span class="cov8" title="1">if config.HealthRecoveryConfirmationThreshold &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.health_recovery_confirmation_threshold", Message: fmt.Sprintf("recovery confirmation threshold must be positive, got %d", config.HealthRecoveryConfirmationThreshold)}
        }</span>

        <span class="cov8" title="1">if config.BackoffBaseMultiplier &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.backoff_base_multiplier", Message: fmt.Sprintf("backoff base multiplier must be positive, got %f", config.BackoffBaseMultiplier)}
        }</span>

        <span class="cov8" title="1">if len(config.BackoffJitterRange) != 2 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.backoff_jitter_range", Message: "backoff jitter range must have exactly 2 elements"}
        }</span>

        <span class="cov8" title="1">if config.BackoffJitterRange[0] &gt;= config.BackoffJitterRange[1] </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.backoff_jitter_range", Message: "backoff jitter range min must be less than max"}
        }</span>

        <span class="cov8" title="1">if config.ProcessTerminationTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.process_termination_timeout", Message: fmt.Sprintf("process termination timeout must be positive, got %f", config.ProcessTerminationTimeout)}
        }</span>

        <span class="cov8" title="1">if config.ProcessKillTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.process_kill_timeout", Message: fmt.Sprintf("process kill timeout must be positive, got %f", config.ProcessKillTimeout)}
        }</span>

        // Validate stream readiness configuration
        <span class="cov8" title="1">if err := validateStreamReadinessConfig(&amp;config.StreamReadiness); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateCodecConfig validates codec configuration.
func validateCodecConfig(config *CodecConfig) error <span class="cov8" title="1">{
        validProfiles := []string{"baseline", "main", "high"}
        if !contains(validProfiles, config.VideoProfile) </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.codec.video_profile", Message: fmt.Sprintf("video profile must be one of %v, got %s", validProfiles, config.VideoProfile)}
        }</span>

        <span class="cov8" title="1">validLevels := []string{"1.0", "1.1", "1.2", "1.3", "2.0", "2.1", "2.2", "3.0", "3.1", "3.2", "4.0", "4.1", "4.2", "5.0", "5.1", "5.2"}
        if !contains(validLevels, config.VideoLevel) </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.codec.video_level", Message: fmt.Sprintf("video level must be one of %v, got %s", validLevels, config.VideoLevel)}
        }</span>

        <span class="cov8" title="1">validFormats := []string{"yuv420p", "yuv422p", "yuv444p"}
        if !contains(validFormats, config.PixelFormat) </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.codec.pixel_format", Message: fmt.Sprintf("pixel format must be one of %v, got %s", validFormats, config.PixelFormat)}
        }</span>

        <span class="cov8" title="1">if config.Bitrate == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.codec.bitrate", Message: "bitrate cannot be empty"}
        }</span>

        <span class="cov8" title="1">validPresets := []string{"ultrafast", "superfast", "veryfast", "faster", "fast", "medium", "slow", "slower", "veryslow"}
        if !contains(validPresets, config.Preset) </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.codec.preset", Message: fmt.Sprintf("preset must be one of %v, got %s", validPresets, config.Preset)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateStreamReadinessConfig validates stream readiness configuration.
func validateStreamReadinessConfig(config *StreamReadinessConfig) error <span class="cov8" title="1">{
        if config.Timeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.stream_readiness.timeout", Message: fmt.Sprintf("timeout must be positive, got %f", config.Timeout)}
        }</span>

        <span class="cov8" title="1">if config.RetryAttempts &lt; 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.stream_readiness.retry_attempts", Message: fmt.Sprintf("retry attempts must be non-negative, got %d", config.RetryAttempts)}
        }</span>

        <span class="cov8" title="1">if config.RetryDelay &lt; 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.stream_readiness.retry_delay", Message: fmt.Sprintf("retry delay must be non-negative, got %f", config.RetryDelay)}
        }</span>

        <span class="cov8" title="1">if config.CheckInterval &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.stream_readiness.check_interval", Message: fmt.Sprintf("check interval must be positive, got %f", config.CheckInterval)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateCameraConfig validates camera configuration.
func validateCameraConfig(config *CameraConfig) error <span class="cov8" title="1">{
        if config.PollInterval &lt; 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "camera.poll_interval", Message: fmt.Sprintf("poll interval must be non-negative, got %f", config.PollInterval)}
        }</span>

        <span class="cov8" title="1">if config.DetectionTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "camera.detection_timeout", Message: fmt.Sprintf("detection timeout must be positive, got %f", config.DetectionTimeout)}
        }</span>

        <span class="cov8" title="1">if len(config.DeviceRange) != 2 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "camera.device_range", Message: "device range must have exactly 2 elements"}
        }</span>

        <span class="cov8" title="1">if config.DeviceRange[0] &lt; 0 || config.DeviceRange[1] &lt; 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "camera.device_range", Message: "device range values must be non-negative"}
        }</span>

        <span class="cov8" title="1">if config.DeviceRange[0] &gt; config.DeviceRange[1] </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "camera.device_range", Message: "device range min must be less than or equal to max"}
        }</span>

        <span class="cov8" title="1">if config.CapabilityTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "camera.capability_timeout", Message: fmt.Sprintf("capability timeout must be positive, got %f", config.CapabilityTimeout)}
        }</span>

        <span class="cov8" title="1">if config.CapabilityRetryInterval &lt; 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "camera.capability_retry_interval", Message: fmt.Sprintf("capability retry interval must be non-negative, got %f", config.CapabilityRetryInterval)}
        }</span>

        <span class="cov8" title="1">if config.CapabilityMaxRetries &lt; 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "camera.capability_max_retries", Message: fmt.Sprintf("capability max retries must be non-negative, got %d", config.CapabilityMaxRetries)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateLoggingConfig validates logging configuration.
func validateLoggingConfig(config *LoggingConfig) error <span class="cov8" title="1">{
        validLevels := []string{"DEBUG", "INFO", "WARN", "WARNING", "ERROR", "FATAL"}
        if !contains(validLevels, strings.ToUpper(config.Level)) </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "logging.level", Message: fmt.Sprintf("log level must be one of %v, got %s", validLevels, config.Level)}
        }</span>

        <span class="cov8" title="1">if config.Format == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "logging.format", Message: "log format cannot be empty"}
        }</span>

        <span class="cov8" title="1">if config.FileEnabled &amp;&amp; config.FilePath == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "logging.file_path", Message: "file path cannot be empty when file logging is enabled"}
        }</span>

        <span class="cov8" title="1">if config.MaxFileSize &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "logging.max_file_size", Message: fmt.Sprintf("max file size must be positive, got %d", config.MaxFileSize)}
        }</span>

        <span class="cov8" title="1">if config.BackupCount &lt; 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "logging.backup_count", Message: fmt.Sprintf("backup count must be non-negative, got %d", config.BackupCount)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateRecordingConfig validates recording configuration.
func validateRecordingConfig(config *RecordingConfig) error <span class="cov8" title="1">{
        validFormats := []string{"fmp4", "mp4", "mkv", "avi"}
        if !contains(validFormats, config.Format) </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "recording.format", Message: fmt.Sprintf("recording format must be one of %v, got %s", validFormats, config.Format)}
        }</span>

        <span class="cov8" title="1">validQualities := []string{"low", "medium", "high"}
        if !contains(validQualities, config.Quality) </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "recording.quality", Message: fmt.Sprintf("recording quality must be one of %v, got %s", validQualities, config.Quality)}
        }</span>

        <span class="cov8" title="1">if config.SegmentDuration &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "recording.segment_duration", Message: fmt.Sprintf("segment duration must be positive, got %d", config.SegmentDuration)}
        }</span>

        <span class="cov8" title="1">if config.MaxSegmentSize &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "recording.max_segment_size", Message: fmt.Sprintf("max segment size must be positive, got %d", config.MaxSegmentSize)}
        }</span>

        <span class="cov8" title="1">if config.CleanupInterval &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "recording.cleanup_interval", Message: fmt.Sprintf("cleanup interval must be positive, got %d", config.CleanupInterval)}
        }</span>

        <span class="cov8" title="1">if config.MaxAge &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "recording.max_age", Message: fmt.Sprintf("max age must be positive, got %d", config.MaxAge)}
        }</span>

        <span class="cov8" title="1">if config.MaxSize &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "recording.max_size", Message: fmt.Sprintf("max size must be positive, got %d", config.MaxSize)}
        }</span>

        <span class="cov8" title="1">if config.DefaultRotationSize &lt; 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "recording.default_rotation_size", Message: fmt.Sprintf("recording default rotation size cannot be negative, got %d", config.DefaultRotationSize)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateSnapshotConfig validates snapshot configuration.
func validateSnapshotConfig(config *SnapshotConfig) error <span class="cov8" title="1">{
        validFormats := []string{"jpeg", "png", "bmp"}
        if !contains(validFormats, config.Format) </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "snapshots.format", Message: fmt.Sprintf("snapshot format must be one of %v, got %s", validFormats, config.Format)}
        }</span>

        <span class="cov8" title="1">if config.Quality &lt; 1 || config.Quality &gt; 100 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "snapshots.quality", Message: fmt.Sprintf("quality must be between 1 and 100, got %d", config.Quality)}
        }</span>

        <span class="cov8" title="1">if config.MaxWidth &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "snapshots.max_width", Message: fmt.Sprintf("max width must be positive, got %d", config.MaxWidth)}
        }</span>

        <span class="cov8" title="1">if config.MaxHeight &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "snapshots.max_height", Message: fmt.Sprintf("max height must be positive, got %d", config.MaxHeight)}
        }</span>

        <span class="cov8" title="1">if config.CleanupInterval &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "snapshots.cleanup_interval", Message: fmt.Sprintf("cleanup interval must be positive, got %d", config.CleanupInterval)}
        }</span>

        <span class="cov8" title="1">if config.MaxAge &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "snapshots.max_age", Message: fmt.Sprintf("max age must be positive, got %d", config.MaxAge)}
        }</span>

        <span class="cov8" title="1">if config.MaxCount &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "snapshots.max_count", Message: fmt.Sprintf("max count must be positive, got %d", config.MaxCount)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateFFmpegConfig validates FFmpeg configuration.
func validateFFmpegConfig(config *FFmpegConfig) error <span class="cov8" title="1">{
        if err := validateFFmpegSnapshotConfig(&amp;config.Snapshot); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := validateFFmpegRecordingConfig(&amp;config.Recording); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateFFmpegSnapshotConfig validates FFmpeg snapshot configuration.
func validateFFmpegSnapshotConfig(config *FFmpegSnapshotConfig) error <span class="cov8" title="1">{
        if config.ProcessCreationTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "ffmpeg.snapshot.process_creation_timeout", Message: fmt.Sprintf("process creation timeout must be positive, got %f", config.ProcessCreationTimeout)}
        }</span>

        <span class="cov8" title="1">if config.ExecutionTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "ffmpeg.snapshot.execution_timeout", Message: fmt.Sprintf("execution timeout must be positive, got %f", config.ExecutionTimeout)}
        }</span>

        <span class="cov8" title="1">if config.InternalTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "ffmpeg.snapshot.internal_timeout", Message: fmt.Sprintf("internal timeout must be positive, got %d", config.InternalTimeout)}
        }</span>

        <span class="cov8" title="1">if config.RetryAttempts &lt; 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "ffmpeg.snapshot.retry_attempts", Message: fmt.Sprintf("retry attempts must be non-negative, got %d", config.RetryAttempts)}
        }</span>

        <span class="cov8" title="1">if config.RetryDelay &lt; 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "ffmpeg.snapshot.retry_delay", Message: fmt.Sprintf("retry delay must be non-negative, got %f", config.RetryDelay)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateFFmpegRecordingConfig validates FFmpeg recording configuration.
func validateFFmpegRecordingConfig(config *FFmpegRecordingConfig) error <span class="cov8" title="1">{
        if config.ProcessCreationTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "ffmpeg.recording.process_creation_timeout", Message: fmt.Sprintf("process creation timeout must be positive, got %f", config.ProcessCreationTimeout)}
        }</span>

        <span class="cov8" title="1">if config.ExecutionTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "ffmpeg.recording.execution_timeout", Message: fmt.Sprintf("execution timeout must be positive, got %f", config.ExecutionTimeout)}
        }</span>

        <span class="cov8" title="1">if config.InternalTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "ffmpeg.recording.internal_timeout", Message: fmt.Sprintf("internal timeout must be positive, got %d", config.InternalTimeout)}
        }</span>

        <span class="cov8" title="1">if config.RetryAttempts &lt; 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "ffmpeg.recording.retry_attempts", Message: fmt.Sprintf("retry attempts must be non-negative, got %d", config.RetryAttempts)}
        }</span>

        <span class="cov8" title="1">if config.RetryDelay &lt; 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "ffmpeg.recording.retry_delay", Message: fmt.Sprintf("retry delay must be non-negative, got %f", config.RetryDelay)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateNotificationsConfig validates notifications configuration.
func validateNotificationsConfig(config *NotificationsConfig) error <span class="cov8" title="1">{
        if err := validateWebSocketNotificationConfig(&amp;config.WebSocket); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := validateRealTimeNotificationConfig(&amp;config.RealTime); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateWebSocketNotificationConfig validates WebSocket notification configuration.
func validateWebSocketNotificationConfig(config *WebSocketNotificationConfig) error <span class="cov8" title="1">{
        if config.DeliveryTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "notifications.websocket.delivery_timeout", Message: fmt.Sprintf("delivery timeout must be positive, got %f", config.DeliveryTimeout)}
        }</span>

        <span class="cov8" title="1">if config.RetryAttempts &lt; 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "notifications.websocket.retry_attempts", Message: fmt.Sprintf("retry attempts must be non-negative, got %d", config.RetryAttempts)}
        }</span>

        <span class="cov8" title="1">if config.RetryDelay &lt; 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "notifications.websocket.retry_delay", Message: fmt.Sprintf("retry delay must be non-negative, got %f", config.RetryDelay)}
        }</span>

        <span class="cov8" title="1">if config.MaxQueueSize &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "notifications.websocket.max_queue_size", Message: fmt.Sprintf("max queue size must be positive, got %d", config.MaxQueueSize)}
        }</span>

        <span class="cov8" title="1">if config.CleanupInterval &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "notifications.websocket.cleanup_interval", Message: fmt.Sprintf("cleanup interval must be positive, got %d", config.CleanupInterval)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateRealTimeNotificationConfig validates real-time notification configuration.
func validateRealTimeNotificationConfig(config *RealTimeNotificationConfig) error <span class="cov8" title="1">{
        if config.CameraStatusInterval &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "notifications.real_time.camera_status_interval", Message: fmt.Sprintf("camera status interval must be positive, got %f", config.CameraStatusInterval)}
        }</span>

        <span class="cov8" title="1">if config.RecordingProgressInterval &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "notifications.real_time.recording_progress_interval", Message: fmt.Sprintf("recording progress interval must be positive, got %f", config.RecordingProgressInterval)}
        }</span>

        <span class="cov8" title="1">if config.ConnectionHealthCheck &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "notifications.real_time.connection_health_check", Message: fmt.Sprintf("connection health check must be positive, got %f", config.ConnectionHealthCheck)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validatePerformanceConfig validates performance configuration.
func validatePerformanceConfig(config *PerformanceConfig) error <span class="cov8" title="1">{
        if err := validateResponseTimeTargetsConfig(&amp;config.ResponseTimeTargets); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := validateSnapshotTiersConfig(&amp;config.SnapshotTiers); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := validateOptimizationConfig(&amp;config.Optimization); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateResponseTimeTargetsConfig validates response time targets configuration.
func validateResponseTimeTargetsConfig(config *ResponseTimeTargetsConfig) error <span class="cov8" title="1">{
        if config.SnapshotCapture &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.response_time_targets.snapshot_capture", Message: fmt.Sprintf("snapshot capture target must be positive, got %f", config.SnapshotCapture)}
        }</span>

        <span class="cov8" title="1">if config.RecordingStart &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.response_time_targets.recording_start", Message: fmt.Sprintf("recording start target must be positive, got %f", config.RecordingStart)}
        }</span>

        <span class="cov8" title="1">if config.RecordingStop &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.response_time_targets.recording_stop", Message: fmt.Sprintf("recording stop target must be positive, got %f", config.RecordingStop)}
        }</span>

        <span class="cov8" title="1">if config.FileListing &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.response_time_targets.file_listing", Message: fmt.Sprintf("file listing target must be positive, got %f", config.FileListing)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateSnapshotTiersConfig validates snapshot tiers configuration.
func validateSnapshotTiersConfig(config *SnapshotTiersConfig) error <span class="cov8" title="1">{
        if config.Tier1USBDirectTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.snapshot_tiers.tier1_usb_direct_timeout", Message: fmt.Sprintf("tier1 USB direct timeout must be positive, got %f", config.Tier1USBDirectTimeout)}
        }</span>

        <span class="cov8" title="1">if config.Tier2RTSPReadyCheckTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.snapshot_tiers.tier2_rtsp_ready_check_timeout", Message: fmt.Sprintf("tier2 RTSP ready check timeout must be positive, got %f", config.Tier2RTSPReadyCheckTimeout)}
        }</span>

        <span class="cov8" title="1">if config.Tier3ActivationTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.snapshot_tiers.tier3_activation_timeout", Message: fmt.Sprintf("tier3 activation timeout must be positive, got %f", config.Tier3ActivationTimeout)}
        }</span>

        <span class="cov8" title="1">if config.Tier3ActivationTriggerTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.snapshot_tiers.tier3_activation_trigger_timeout", Message: fmt.Sprintf("tier3 activation trigger timeout must be positive, got %f", config.Tier3ActivationTriggerTimeout)}
        }</span>

        <span class="cov8" title="1">if config.TotalOperationTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.snapshot_tiers.total_operation_timeout", Message: fmt.Sprintf("total operation timeout must be positive, got %f", config.TotalOperationTimeout)}
        }</span>

        <span class="cov8" title="1">if config.ImmediateResponseThreshold &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.snapshot_tiers.immediate_response_threshold", Message: fmt.Sprintf("immediate response threshold must be positive, got %f", config.ImmediateResponseThreshold)}
        }</span>

        <span class="cov8" title="1">if config.AcceptableResponseThreshold &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.snapshot_tiers.acceptable_response_threshold", Message: fmt.Sprintf("acceptable response threshold must be positive, got %f", config.AcceptableResponseThreshold)}
        }</span>

        <span class="cov8" title="1">if config.SlowResponseThreshold &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.snapshot_tiers.slow_response_threshold", Message: fmt.Sprintf("slow response threshold must be positive, got %f", config.SlowResponseThreshold)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateOptimizationConfig validates optimization configuration.
func validateOptimizationConfig(config *OptimizationConfig) error <span class="cov8" title="1">{
        if config.CacheTTL &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.optimization.cache_ttl", Message: fmt.Sprintf("cache TTL must be positive, got %d", config.CacheTTL)}
        }</span>

        <span class="cov8" title="1">if config.MaxConcurrentOperations &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.optimization.max_concurrent_operations", Message: fmt.Sprintf("max concurrent operations must be positive, got %d", config.MaxConcurrentOperations)}
        }</span>

        <span class="cov8" title="1">if config.ConnectionPoolSize &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.optimization.connection_pool_size", Message: fmt.Sprintf("connection pool size must be positive, got %d", config.ConnectionPoolSize)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateRetentionPolicyConfig validates retention policy configuration.
func validateRetentionPolicyConfig(config *RetentionPolicyConfig) error <span class="cov8" title="1">{
        // Validate policy type
        validTypes := []string{"age", "size", "manual"}
        if !contains(validTypes, config.Type) </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "retention_policy.type", Message: fmt.Sprintf("policy type must be one of %v, got %s", validTypes, config.Type)}
        }</span>

        // Validate age-based policy parameters
        <span class="cov8" title="1">if config.Type == "age" </span><span class="cov8" title="1">{
                if config.MaxAgeDays &lt; 0 </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Field: "retention_policy.max_age_days", Message: fmt.Sprintf("max age days cannot be negative for age-based policy, got %d", config.MaxAgeDays)}
                }</span>
                <span class="cov8" title="1">if config.MaxAgeDays &gt; 0 &amp;&amp; config.MaxAgeDays &gt; 365 </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Field: "retention_policy.max_age_days", Message: fmt.Sprintf("max age days cannot exceed 365 days, got %d", config.MaxAgeDays)}
                }</span>
        }

        // Validate size-based policy parameters
        <span class="cov8" title="1">if config.Type == "size" </span><span class="cov0" title="0">{
                if config.MaxSizeGB &lt;= 0 </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Field: "retention_policy.max_size_gb", Message: fmt.Sprintf("max size GB must be positive for size-based policy, got %d", config.MaxSizeGB)}
                }</span>
                <span class="cov0" title="0">if config.MaxSizeGB &gt; 1000 </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Field: "retention_policy.max_size_gb", Message: fmt.Sprintf("max size GB cannot exceed 1000 GB, got %d", config.MaxSizeGB)}
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// contains checks if a slice contains a specific value.
func contains(slice []string, value string) bool <span class="cov8" title="1">{
        for _, item := range slice </span><span class="cov8" title="1">{
                if item == value </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
