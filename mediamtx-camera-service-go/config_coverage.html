
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/camerarecorder/mediamtx-camera-service-go/internal/config/config_manager.go (82.9%)</option>
				
				<option value="file1">github.com/camerarecorder/mediamtx-camera-service-go/internal/config/config_validation.go (62.9%)</option>
				
				<option value="file2">github.com/camerarecorder/mediamtx-camera-service-go/internal/config/test_helpers.go (94.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/camerarecorder/mediamtx-camera-service-go/internal/logging"
        "github.com/fsnotify/fsnotify"
        "github.com/spf13/viper"
)

// ConfigManager manages configuration loading, validation, and hot reload functionality.
type ConfigManager struct {
        config          *Config
        configPath      string
        updateCallbacks []func(*Config)
        watcher         *fsnotify.Watcher
        watcherActive   int32 // Atomic: 0 = inactive, 1 = active
        watcherLock     sync.RWMutex
        lock            sync.RWMutex
        defaultConfig   *Config
        logger          *logging.Logger
        stopChan        chan struct{}
        wg              sync.WaitGroup
}

// CreateConfigManager creates a new configuration manager instance.
func CreateConfigManager() *ConfigManager <span class="cov8" title="1">{
        return &amp;ConfigManager{
                updateCallbacks: make([]func(*Config), 0),
                defaultConfig:   getDefaultConfig(),
                logger:          logging.GetLogger("config-manager"),
                stopChan:        make(chan struct{}, 5), // Buffered to prevent deadlock during shutdown
        }
}</span>

// LoadConfig loads configuration from YAML file with environment variable overrides and validation.
func (cm *ConfigManager) LoadConfig(configPath string) error <span class="cov8" title="1">{
        cm.lock.Lock()
        defer cm.lock.Unlock()

        cm.logger.WithFields(logging.Fields{
                "config_path": configPath,
                "action":      "load_config",
        }).Info("Loading configuration")

        // REQ-CONFIG-001: Validate configuration files before loading
        // REQ-CONFIG-002: Fail fast on configuration errors
        // REQ-CONFIG-003: Early detection and clear error reporting
        if err := cm.validateConfigFile(configPath); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("configuration validation failed: invalid configuration - %w", err)
        }</span>

        // Set up Viper
        <span class="cov8" title="1">v := viper.New()
        v.SetConfigFile(configPath)
        v.SetConfigType("yaml")

        // Set default values
        cm.setDefaults(v)

        // Read environment variables
        v.AutomaticEnv()
        v.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
        v.SetEnvPrefix("CAMERA_SERVICE")

        // Read configuration file
        if err := v.ReadInConfig(); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("configuration validation failed: invalid configuration - cannot read configuration file '%s': %w", configPath, err)
        }</span>

        // Unmarshal configuration
        <span class="cov8" title="1">var config Config
        if err := v.Unmarshal(&amp;config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal config: %w", err)
        }</span>

        // REQ-CONFIG-001: Validate final configuration values after environment variable overrides
        // REQ-CONFIG-002: Fail fast on configuration errors
        // REQ-CONFIG-003: Early detection and clear error reporting
        <span class="cov8" title="1">if err := cm.validateFinalConfiguration(&amp;config); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("configuration validation failed: invalid configuration - %w", err)
        }</span>

        // Validate configuration
        <span class="cov8" title="1">if err := ValidateConfig(&amp;config); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("configuration validation failed: %w", err)
        }</span>

        // Store configuration
        <span class="cov8" title="1">oldConfig := cm.config
        cm.config = &amp;config
        cm.configPath = configPath

        // Start file watching for hot reload (only if explicitly enabled)
        // Hot reload is disabled by default for tests and can be enabled via environment variable
        if os.Getenv("CAMERA_SERVICE_ENABLE_HOT_RELOAD") == "true" </span><span class="cov8" title="1">{
                if err := cm.startFileWatching(); err != nil </span><span class="cov0" title="0">{
                        cm.logger.WithError(err).Warn("Failed to start file watching, hot reload disabled")
                }</span>
        }

        // Notify callbacks
        <span class="cov8" title="1">cm.notifyConfigUpdated(oldConfig, &amp;config)

        cm.logger.WithFields(logging.Fields{
                "config_path": configPath,
                "action":      "load_config",
                "status":      "success",
        }).Info("Configuration loaded successfully")

        return nil</span>
}

// validateConfigFile validates the configuration file before loading
// REQ-CONFIG-001: The system SHALL validate configuration files before loading
// REQ-CONFIG-002: The system SHALL fail fast on configuration errors
// REQ-CONFIG-003: Edge case handling SHALL mean early detection and clear error reporting
func (cm *ConfigManager) validateConfigFile(configPath string) error <span class="cov8" title="1">{
        // Check if file exists
        if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return fmt.Errorf("configuration file does not exist: '%s'", configPath)
        }</span>

        // Read file content for validation
        <span class="cov8" title="1">content, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot read configuration file '%s': %w", configPath, err)
        }</span>

        // Check for empty file
        <span class="cov8" title="1">if len(content) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("configuration file is empty: '%s' - file must contain valid YAML configuration", configPath)
        }</span>

        // Check for comments-only file
        <span class="cov8" title="1">lines := strings.Split(string(content), "\n")
        hasNonCommentContent := false

        for _, line := range lines </span><span class="cov8" title="1">{
                trimmedLine := strings.TrimSpace(line)
                if trimmedLine == "" </span><span class="cov8" title="1">{
                        continue</span> // Skip empty lines
                }
                <span class="cov8" title="1">if strings.HasPrefix(trimmedLine, "#") </span><span class="cov8" title="1">{
                        continue</span> // Skip comment lines
                }
                <span class="cov8" title="1">hasNonCommentContent = true
                break</span>
        }

        <span class="cov8" title="1">if !hasNonCommentContent </span><span class="cov8" title="1">{
                return fmt.Errorf("configuration file contains only comments or is empty: '%s' - file must contain valid YAML configuration data", configPath)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateFinalConfiguration validates the final configuration values after environment variable overrides
// REQ-CONFIG-001: The system SHALL validate configuration files before loading
// REQ-CONFIG-002: The system SHALL fail fast on configuration errors
// REQ-CONFIG-003: Edge case handling SHALL mean early detection and clear error reporting
func (cm *ConfigManager) validateFinalConfiguration(config *Config) error <span class="cov8" title="1">{
        // Validate server configuration
        if strings.TrimSpace(config.Server.Host) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("server host cannot be empty or whitespace-only")
        }</span>
        <span class="cov8" title="1">if config.Server.Port &lt;= 0 || config.Server.Port &gt; 65535 </span><span class="cov8" title="1">{
                return fmt.Errorf("server port must be between 1 and 65535, got %d", config.Server.Port)
        }</span>

        // Validate MediaMTX configuration
        <span class="cov8" title="1">if strings.TrimSpace(config.MediaMTX.Host) == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("MediaMTX host cannot be empty or whitespace-only")
        }</span>
        <span class="cov8" title="1">if config.MediaMTX.APIPort &lt;= 0 || config.MediaMTX.APIPort &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("MediaMTX API port must be between 1 and 65535, got %d", config.MediaMTX.APIPort)
        }</span>
        <span class="cov8" title="1">if config.MediaMTX.RTSPPort &lt;= 0 || config.MediaMTX.RTSPPort &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("MediaMTX RTSP port must be between 1 and 65535, got %d", config.MediaMTX.RTSPPort)
        }</span>
        <span class="cov8" title="1">if config.MediaMTX.WebRTCPort &lt;= 0 || config.MediaMTX.WebRTCPort &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("MediaMTX WebRTC port must be between 1 and 65535, got %d", config.MediaMTX.WebRTCPort)
        }</span>
        <span class="cov8" title="1">if config.MediaMTX.HLSPort &lt;= 0 || config.MediaMTX.HLSPort &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("MediaMTX HLS port must be between 1 and 65535, got %d", config.MediaMTX.HLSPort)
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(config.MediaMTX.ConfigPath) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("MediaMTX config path cannot be empty or whitespace-only")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(config.MediaMTX.RecordingsPath) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("MediaMTX recordings path cannot be empty or whitespace-only")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(config.MediaMTX.SnapshotsPath) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("MediaMTX snapshots path cannot be empty or whitespace-only")
        }</span>

        // Validate camera configuration
        <span class="cov8" title="1">if config.Camera.PollInterval &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("camera poll interval must be positive, got %f", config.Camera.PollInterval)
        }</span>
        <span class="cov8" title="1">if config.Camera.DetectionTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("camera detection timeout must be positive, got %f", config.Camera.DetectionTimeout)
        }</span>
        <span class="cov8" title="1">if config.Camera.CapabilityTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("camera capability timeout must be positive, got %f", config.Camera.CapabilityTimeout)
        }</span>
        <span class="cov8" title="1">if config.Camera.CapabilityRetryInterval &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("camera capability retry interval must be positive, got %f", config.Camera.CapabilityRetryInterval)
        }</span>
        <span class="cov8" title="1">if config.Camera.CapabilityMaxRetries &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("camera capability max retries cannot be negative, got %d", config.Camera.CapabilityMaxRetries)
        }</span>

        // Validate logging configuration
        <span class="cov8" title="1">validLogLevels := []string{"debug", "info", "warn", "warning", "error", "fatal", "panic"}
        levelFound := false
        for _, valid := range validLogLevels </span><span class="cov8" title="1">{
                if strings.ToLower(config.Logging.Level) == valid </span><span class="cov8" title="1">{
                        levelFound = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !levelFound </span><span class="cov0" title="0">{
                return fmt.Errorf("logging level must be one of: %v, got %s", validLogLevels, config.Logging.Level)
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(config.Logging.Format) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("logging format cannot be empty or whitespace-only")
        }</span>
        <span class="cov8" title="1">if config.Logging.FileEnabled &amp;&amp; strings.TrimSpace(config.Logging.FilePath) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("logging file path cannot be empty when file logging is enabled")
        }</span>

        // Validate recording configuration
        <span class="cov8" title="1">if strings.TrimSpace(config.Recording.Format) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("recording format cannot be empty or whitespace-only")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(config.Recording.Quality) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("recording quality cannot be empty or whitespace-only")
        }</span>
        <span class="cov8" title="1">if config.Recording.SegmentDuration &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("recording segment duration cannot be negative, got %d", config.Recording.SegmentDuration)
        }</span>
        <span class="cov8" title="1">if config.Recording.MaxSegmentSize &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("recording max segment size cannot be negative, got %d", config.Recording.MaxSegmentSize)
        }</span>
        <span class="cov8" title="1">if config.Recording.CleanupInterval &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("recording cleanup interval cannot be negative, got %d", config.Recording.CleanupInterval)
        }</span>
        <span class="cov8" title="1">if config.Recording.MaxAge &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("recording max age cannot be negative, got %d", config.Recording.MaxAge)
        }</span>
        <span class="cov8" title="1">if config.Recording.MaxSize &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("recording max size must be positive, got %d", config.Recording.MaxSize)
        }</span>
        <span class="cov8" title="1">if config.Recording.DefaultRotationSize &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("recording default rotation size cannot be negative, got %d", config.Recording.DefaultRotationSize)
        }</span>
        <span class="cov8" title="1">if config.Recording.DefaultMaxDuration &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("recording default max duration cannot be negative, got %v", config.Recording.DefaultMaxDuration)
        }</span>
        <span class="cov8" title="1">if config.Recording.DefaultRetentionDays &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("recording default retention days cannot be negative, got %d", config.Recording.DefaultRetentionDays)
        }</span>

        // Validate snapshots configuration
        <span class="cov8" title="1">if strings.TrimSpace(config.Snapshots.Format) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("snapshots format cannot be empty or whitespace-only")
        }</span>
        <span class="cov8" title="1">if config.Snapshots.Quality &lt; 0 || config.Snapshots.Quality &gt; 100 </span><span class="cov0" title="0">{
                return fmt.Errorf("snapshots quality must be between 0 and 100, got %d", config.Snapshots.Quality)
        }</span>
        <span class="cov8" title="1">if config.Snapshots.MaxWidth &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("snapshots max width must be positive, got %d", config.Snapshots.MaxWidth)
        }</span>
        <span class="cov8" title="1">if config.Snapshots.MaxHeight &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("snapshots max height must be positive, got %d", config.Snapshots.MaxHeight)
        }</span>
        <span class="cov8" title="1">if config.Snapshots.CleanupInterval &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("snapshots cleanup interval cannot be negative, got %d", config.Snapshots.CleanupInterval)
        }</span>
        <span class="cov8" title="1">if config.Snapshots.MaxAge &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("snapshots max age cannot be negative, got %d", config.Snapshots.MaxAge)
        }</span>
        <span class="cov8" title="1">if config.Snapshots.MaxCount &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("snapshots max count must be positive, got %d", config.Snapshots.MaxCount)
        }</span>

        // Validate storage configuration
        <span class="cov8" title="1">if config.Storage.WarnPercent &lt; 0 || config.Storage.WarnPercent &gt; 100 </span><span class="cov0" title="0">{
                return fmt.Errorf("storage warn percent must be between 0 and 100, got %d", config.Storage.WarnPercent)
        }</span>
        <span class="cov8" title="1">if config.Storage.BlockPercent &lt; 0 || config.Storage.BlockPercent &gt; 100 </span><span class="cov0" title="0">{
                return fmt.Errorf("storage block percent must be between 0 and 100, got %d", config.Storage.BlockPercent)
        }</span>
        <span class="cov8" title="1">if config.Storage.WarnPercent &gt;= config.Storage.BlockPercent </span><span class="cov0" title="0">{
                return fmt.Errorf("storage warn percent (%d) must be less than block percent (%d)", config.Storage.WarnPercent, config.Storage.BlockPercent)
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(config.Storage.DefaultPath) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("storage default path cannot be empty or whitespace-only")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(config.Storage.FallbackPath) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("storage fallback path cannot be empty or whitespace-only")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// startFileWatching starts watching the configuration file for changes.
func (cm *ConfigManager) startFileWatching() error <span class="cov8" title="1">{
        // Stop existing watcher if any
        cm.stopFileWatching()

        // Create new watcher
        watcher, err := fsnotify.NewWatcher()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create file watcher: %w", err)
        }</span>

        <span class="cov8" title="1">cm.watcherLock.Lock()
        cm.watcher = watcher
        cm.watcherLock.Unlock()

        // Watch the directory containing the config file
        configDir := filepath.Dir(cm.configPath)
        if err := cm.watcher.Add(configDir); err != nil </span><span class="cov0" title="0">{
                cm.watcher.Close()
                cm.watcherLock.Lock()
                cm.watcher = nil
                cm.watcherLock.Unlock()
                return fmt.Errorf("failed to watch config directory %s: %w", configDir, err)
        }</span>

        // Mark watcher as active atomically
        <span class="cov8" title="1">atomic.StoreInt32(&amp;cm.watcherActive, 1)

        // Start watching goroutine
        cm.wg.Add(1)
        go cm.watchFileChanges()

        cm.logger.WithFields(logging.Fields{
                "config_path": cm.configPath,
                "watch_dir":   configDir,
        }).Info("File watching started for hot reload")

        return nil</span>
}

// stopFileWatching stops the file watcher.
func (cm *ConfigManager) stopFileWatching() <span class="cov8" title="1">{
        // Mark watcher as inactive atomically
        atomic.StoreInt32(&amp;cm.watcherActive, 0)

        cm.watcherLock.Lock()
        defer cm.watcherLock.Unlock()

        if cm.watcher != nil </span><span class="cov8" title="1">{
                // Close watcher safely
                if err := cm.watcher.Close(); err != nil </span><span class="cov0" title="0">{
                        cm.logger.WithError(err).Warn("Error closing file watcher")
                }</span>
                <span class="cov8" title="1">cm.watcher = nil
                cm.logger.Debug("File watcher stopped and cleaned up")</span>
        }
}

// watchFileChanges watches for file changes and triggers configuration reload.
func (cm *ConfigManager) watchFileChanges() <span class="cov8" title="1">{
        defer cm.wg.Done()

        // Debounce timer to avoid multiple reloads
        var reloadTimer *time.Timer

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-cm.stopChan:<span class="cov0" title="0">
                        return</span>
                default:<span class="cov8" title="1">
                        // Check if watcher is still active atomically
                        if atomic.LoadInt32(&amp;cm.watcherActive) == 0 </span><span class="cov0" title="0">{
                                return
                        }</span>

                        // Check if watcher is still valid before accessing its channels
                        <span class="cov8" title="1">cm.watcherLock.RLock()
                        if cm.watcher == nil </span><span class="cov0" title="0">{
                                cm.watcherLock.RUnlock()
                                return
                        }</span>
                        <span class="cov8" title="1">events := cm.watcher.Events
                        errors := cm.watcher.Errors
                        cm.watcherLock.RUnlock()

                        // Use a select with timeout to avoid blocking indefinitely
                        select </span>{
                        case &lt;-cm.stopChan:<span class="cov8" title="1">
                                return</span>
                        case event, ok := &lt;-events:<span class="cov0" title="0">
                                if !ok </span><span class="cov0" title="0">{
                                        return
                                }</span>

                                // Check if the changed file is our config file
                                <span class="cov0" title="0">if event.Name == cm.configPath </span><span class="cov0" title="0">{
                                        cm.logger.WithFields(logging.Fields{
                                                "file":  event.Name,
                                                "event": event.Op.String(),
                                        }).Debug("Configuration file change detected")

                                        // Handle different event types
                                        switch event.Op </span>{
                                        case fsnotify.Write, fsnotify.Create:<span class="cov0" title="0">
                                                // Debounce reload to avoid multiple rapid reloads
                                                if reloadTimer != nil </span><span class="cov0" title="0">{
                                                        reloadTimer.Stop()
                                                }</span>
                                                <span class="cov0" title="0">reloadTimer = time.AfterFunc(100*time.Millisecond, func() </span><span class="cov0" title="0">{
                                                        cm.reloadConfiguration()
                                                }</span>)
                                        case fsnotify.Remove:<span class="cov0" title="0">
                                                cm.logger.Warn("Configuration file was removed, hot reload disabled")
                                                cm.stopFileWatching()
                                                return</span> // Exit the goroutine when file is removed
                                        }
                                }

                        case err, ok := &lt;-errors:<span class="cov0" title="0">
                                if !ok </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">cm.logger.WithError(err).Error("File watcher error")</span>
                        case &lt;-time.After(100 * time.Millisecond):<span class="cov0" title="0">
                                // Continue loop to check stopChan and watcher validity
                                continue</span>
                        }
                }
        }
}

// reloadConfiguration reloads the configuration file.
func (cm *ConfigManager) reloadConfiguration() <span class="cov8" title="1">{
        cm.logger.Info("Reloading configuration due to file change")

        // Check if file still exists
        if _, err := os.Stat(cm.configPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                cm.logger.Warn("Configuration file no longer exists, stopping hot reload")
                cm.stopFileWatching()
                return
        }</span>

        // Reload configuration
        <span class="cov8" title="1">if err := cm.LoadConfig(cm.configPath); err != nil </span><span class="cov0" title="0">{
                cm.logger.WithError(err).Error("Failed to reload configuration")
                return
        }</span>

        <span class="cov8" title="1">cm.logger.Info("Configuration reloaded successfully")</span>
}

// Stop stops the configuration manager and cleans up resources with context-aware cancellation.
func (cm *ConfigManager) Stop(ctx context.Context) error <span class="cov8" title="1">{
        cm.logger.Info("Stopping configuration manager")

        // Signal stop
        select </span>{
        case &lt;-cm.stopChan:<span class="cov8" title="1"></span>
                // Already closed
        default:<span class="cov8" title="1">
                close(cm.stopChan)</span>
        }

        // Stop file watching
        <span class="cov8" title="1">cm.stopFileWatching()

        // Wait for goroutines to finish with timeout
        done := make(chan struct{})
        go func() </span><span class="cov8" title="1">{
                cm.wg.Wait()
                close(done)
        }</span>()

        <span class="cov8" title="1">select </span>{
        case &lt;-done:<span class="cov8" title="1"></span>
                // Clean shutdown
        case &lt;-ctx.Done():<span class="cov8" title="1">
                cm.logger.Warn("Configuration manager shutdown timeout")
                return ctx.Err()</span>
        }

        <span class="cov8" title="1">cm.logger.Info("Configuration manager stopped")
        return nil</span>
}

// GetConfig returns the current configuration.
func (cm *ConfigManager) GetConfig() *Config <span class="cov8" title="1">{
        cm.lock.RLock()
        defer cm.lock.RUnlock()

        if cm.config == nil </span><span class="cov0" title="0">{
                return cm.defaultConfig
        }</span>
        <span class="cov8" title="1">return cm.config</span>
}

// GetLogger returns the config manager's logger for level configuration.
func (cm *ConfigManager) GetLogger() *logging.Logger <span class="cov0" title="0">{
        return cm.logger
}</span>

// SaveConfig saves the current configuration to the configuration file.
func (cm *ConfigManager) SaveConfig() error <span class="cov8" title="1">{
        cm.lock.Lock()
        defer cm.lock.Unlock()

        if cm.config == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no configuration to save")
        }</span>

        <span class="cov8" title="1">if cm.configPath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("no configuration file path set")
        }</span>

        <span class="cov8" title="1">cm.logger.WithFields(logging.Fields{
                "config_path": cm.configPath,
                "action":      "save_config",
        }).Info("Saving configuration to file")

        // Create a new Viper instance for saving
        v := viper.New()
        v.SetConfigFile(cm.configPath)
        v.SetConfigType("yaml")

        // Set all configuration values
        cm.setConfigValues(v, cm.config)

        // Ensure the directory exists
        configDir := filepath.Dir(cm.configPath)
        if err := os.MkdirAll(configDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create config directory: %w", err)
        }</span>

        // Write the configuration to file
        <span class="cov8" title="1">if err := v.WriteConfig(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>

        <span class="cov8" title="1">cm.logger.WithFields(logging.Fields{
                "config_path": cm.configPath,
                "action":      "save_config",
                "status":      "success",
        }).Info("Configuration saved successfully")

        return nil</span>
}

// setConfigValues recursively sets configuration values in Viper
func (cm *ConfigManager) setConfigValues(v *viper.Viper, config *Config) <span class="cov8" title="1">{
        // Server configuration
        v.Set("server.host", config.Server.Host)
        v.Set("server.port", config.Server.Port)
        v.Set("server.websocket_path", config.Server.WebSocketPath)
        v.Set("server.max_connections", config.Server.MaxConnections)
        v.Set("server.read_timeout", config.Server.ReadTimeout)
        v.Set("server.write_timeout", config.Server.WriteTimeout)
        v.Set("server.ping_interval", config.Server.PingInterval)
        v.Set("server.pong_wait", config.Server.PongWait)
        v.Set("server.max_message_size", config.Server.MaxMessageSize)

        // MediaMTX configuration
        v.Set("mediamtx.host", config.MediaMTX.Host)
        v.Set("mediamtx.api_port", config.MediaMTX.APIPort)
        v.Set("mediamtx.rtsp_port", config.MediaMTX.RTSPPort)
        v.Set("mediamtx.webrtc_port", config.MediaMTX.WebRTCPort)
        v.Set("mediamtx.hls_port", config.MediaMTX.HLSPort)
        v.Set("mediamtx.config_path", config.MediaMTX.ConfigPath)
        v.Set("mediamtx.recordings_path", config.MediaMTX.RecordingsPath)
        v.Set("mediamtx.snapshots_path", config.MediaMTX.SnapshotsPath)
        v.Set("mediamtx.health_check_interval", config.MediaMTX.HealthCheckInterval)
        v.Set("mediamtx.health_failure_threshold", config.MediaMTX.HealthFailureThreshold)
        v.Set("mediamtx.health_circuit_breaker_timeout", config.MediaMTX.HealthCircuitBreakerTimeout)
        v.Set("mediamtx.health_max_backoff_interval", config.MediaMTX.HealthMaxBackoffInterval)
        v.Set("mediamtx.health_recovery_confirmation_threshold", config.MediaMTX.HealthRecoveryConfirmationThreshold)
        v.Set("mediamtx.backoff_base_multiplier", config.MediaMTX.BackoffBaseMultiplier)
        v.Set("mediamtx.backoff_jitter_range", config.MediaMTX.BackoffJitterRange)
        v.Set("mediamtx.process_termination_timeout", config.MediaMTX.ProcessTerminationTimeout)
        v.Set("mediamtx.process_kill_timeout", config.MediaMTX.ProcessKillTimeout)
        v.Set("mediamtx.health_check_timeout", config.MediaMTX.HealthCheckTimeout)

        // Camera configuration
        v.Set("camera.poll_interval", config.Camera.PollInterval)
        v.Set("camera.detection_timeout", config.Camera.DetectionTimeout)
        v.Set("camera.device_range", config.Camera.DeviceRange)
        v.Set("camera.enable_capability_detection", config.Camera.EnableCapabilityDetection)
        v.Set("camera.auto_start_streams", config.Camera.AutoStartStreams)
        v.Set("camera.capability_timeout", config.Camera.CapabilityTimeout)
        v.Set("camera.capability_retry_interval", config.Camera.CapabilityRetryInterval)
        v.Set("camera.capability_max_retries", config.Camera.CapabilityMaxRetries)

        // Logging configuration
        v.Set("logging.level", config.Logging.Level)
        v.Set("logging.format", config.Logging.Format)
        v.Set("logging.file_enabled", config.Logging.FileEnabled)
        v.Set("logging.file_path", config.Logging.FilePath)
        v.Set("logging.max_file_size", config.Logging.MaxFileSize)
        v.Set("logging.backup_count", config.Logging.BackupCount)
        v.Set("logging.console_enabled", config.Logging.ConsoleEnabled)

        // Recording configuration
        v.Set("recording.enabled", config.Recording.Enabled)
        v.Set("recording.format", config.Recording.Format)
        v.Set("recording.quality", config.Recording.Quality)
        v.Set("recording.segment_duration", config.Recording.SegmentDuration)
        v.Set("recording.max_segment_size", config.Recording.MaxSegmentSize)
        v.Set("recording.auto_cleanup", config.Recording.AutoCleanup)
        v.Set("recording.cleanup_interval", config.Recording.CleanupInterval)
        v.Set("recording.max_age", config.Recording.MaxAge)
        v.Set("recording.max_size", config.Recording.MaxSize)

        // Snapshots configuration
        v.Set("snapshots.enabled", config.Snapshots.Enabled)
        v.Set("snapshots.format", config.Snapshots.Format)
        v.Set("snapshots.quality", config.Snapshots.Quality)
        v.Set("snapshots.max_width", config.Snapshots.MaxWidth)
        v.Set("snapshots.max_height", config.Snapshots.MaxHeight)
        v.Set("snapshots.auto_cleanup", config.Snapshots.AutoCleanup)
        v.Set("snapshots.cleanup_interval", config.Snapshots.CleanupInterval)
        v.Set("snapshots.max_age", config.Snapshots.MaxAge)
        v.Set("snapshots.max_count", config.Snapshots.MaxCount)

        // Retention policy configuration
        v.Set("retention_policy.enabled", config.RetentionPolicy.Enabled)
        v.Set("retention_policy.type", config.RetentionPolicy.Type)
        v.Set("retention_policy.max_age_days", config.RetentionPolicy.MaxAgeDays)
        v.Set("retention_policy.max_size_gb", config.RetentionPolicy.MaxSizeGB)
        v.Set("retention_policy.auto_cleanup", config.RetentionPolicy.AutoCleanup)
}</span>

// AddUpdateCallback adds a callback function to be called when configuration is updated.
func (cm *ConfigManager) AddUpdateCallback(callback func(*Config)) <span class="cov8" title="1">{
        cm.lock.Lock()
        defer cm.lock.Unlock()
        cm.updateCallbacks = append(cm.updateCallbacks, callback)
}</span>

// RegisterLoggingConfigurationUpdates registers automatic logging configuration updates.
// This method sets up a callback that automatically updates the global logging configuration
// whenever the main configuration is reloaded, ensuring all loggers use the latest settings.
//
// This solution:
// - ✅ No circular dependencies (config calls logging, never reverse)
// - ✅ Production ready (uses existing config reload infrastructure)
// - ✅ Power friendly (no polling, uses existing file watching)
// - ✅ Leverages factory pattern (updates all loggers via ConfigureGlobalLogging)
// - ✅ Integrates smoothly (uses your existing callback architecture)
func (cm *ConfigManager) RegisterLoggingConfigurationUpdates() <span class="cov8" title="1">{
        cm.AddUpdateCallback(func(newConfig *Config) </span><span class="cov8" title="1">{
                if newConfig == nil </span><span class="cov0" title="0">{
                        cm.logger.Warn("Skipping logging config update - invalid configuration")
                        return
                }</span>

                // Convert main config logging section to logging.LoggingConfig
                // Uses the same conversion pattern as main.go
                <span class="cov8" title="1">loggingConfig := &amp;logging.LoggingConfig{
                        Level:          newConfig.Logging.Level,
                        Format:         newConfig.Logging.Format,
                        FileEnabled:    newConfig.Logging.FileEnabled,
                        FilePath:       newConfig.Logging.FilePath,
                        MaxFileSize:    int(newConfig.Logging.MaxFileSize),
                        BackupCount:    newConfig.Logging.BackupCount,
                        ConsoleEnabled: newConfig.Logging.ConsoleEnabled,
                }

                // Update global logging configuration and all loggers via factory
                if err := logging.ConfigureGlobalLogging(loggingConfig); err != nil </span><span class="cov0" title="0">{
                        cm.logger.WithError(err).Error("Failed to update logging configuration")
                        return
                }</span>

                <span class="cov8" title="1">cm.logger.WithFields(logging.Fields{
                        "level":           loggingConfig.Level,
                        "format":          loggingConfig.Format,
                        "file_enabled":    loggingConfig.FileEnabled,
                        "console_enabled": loggingConfig.ConsoleEnabled,
                }).Info("Logging configuration updated successfully")</span>
        })
}

// setDefaults sets default configuration values in Viper.
func (cm *ConfigManager) setDefaults(v *viper.Viper) <span class="cov8" title="1">{
        // Server defaults
        v.SetDefault("server.host", "0.0.0.0")
        v.SetDefault("server.port", 8002)
        v.SetDefault("server.websocket_path", "/ws")
        v.SetDefault("server.max_connections", 100)
        v.SetDefault("server.read_timeout", "5s")
        v.SetDefault("server.write_timeout", "1s")
        v.SetDefault("server.ping_interval", "30s")
        v.SetDefault("server.pong_wait", "60s")
        v.SetDefault("server.max_message_size", 1048576) // 1MB
        v.SetDefault("server.read_buffer_size", 1024)
        v.SetDefault("server.write_buffer_size", 1024)
        v.SetDefault("server.shutdown_timeout", "30s")
        v.SetDefault("server.client_cleanup_timeout", "10s")

        // MediaMTX defaults
        v.SetDefault("mediamtx.host", "127.0.0.1")
        v.SetDefault("mediamtx.api_port", 9997)
        v.SetDefault("mediamtx.rtsp_port", 8554)
        v.SetDefault("mediamtx.webrtc_port", 8889)
        v.SetDefault("mediamtx.hls_port", 8888)
        v.SetDefault("mediamtx.timeout", "10s")
        v.SetDefault("mediamtx.config_path", "/opt/camera-service/config/mediamtx.yml")
        v.SetDefault("mediamtx.recordings_path", "/opt/camera-service/recordings")
        v.SetDefault("mediamtx.snapshots_path", "/opt/camera-service/snapshots")

        // MediaMTX codec defaults
        v.SetDefault("mediamtx.codec.video_profile", "baseline")
        v.SetDefault("mediamtx.codec.video_level", "3.0")
        v.SetDefault("mediamtx.codec.pixel_format", "yuv420p")
        v.SetDefault("mediamtx.codec.bitrate", "600k")
        v.SetDefault("mediamtx.codec.preset", "ultrafast")

        // MediaMTX health monitoring defaults
        v.SetDefault("mediamtx.health_check_interval", 30)
        v.SetDefault("mediamtx.health_failure_threshold", 10)
        v.SetDefault("mediamtx.health_circuit_breaker_timeout", 60)
        v.SetDefault("mediamtx.health_max_backoff_interval", 120)
        v.SetDefault("mediamtx.health_recovery_confirmation_threshold", 3)
        v.SetDefault("mediamtx.health_check_timeout", "5s")
        v.SetDefault("mediamtx.backoff_base_multiplier", 2.0)
        v.SetDefault("mediamtx.backoff_jitter_range", []float64{0.8, 1.2})
        v.SetDefault("mediamtx.process_termination_timeout", 3.0)
        v.SetDefault("mediamtx.process_kill_timeout", 2.0)

        // RTSP Connection Monitoring defaults
        v.SetDefault("mediamtx.rtsp_monitoring.enabled", true)
        v.SetDefault("mediamtx.rtsp_monitoring.check_interval", 30)
        v.SetDefault("mediamtx.rtsp_monitoring.connection_timeout", 10)
        v.SetDefault("mediamtx.rtsp_monitoring.max_connections", 50)
        v.SetDefault("mediamtx.rtsp_monitoring.session_timeout", 300)
        v.SetDefault("mediamtx.rtsp_monitoring.bandwidth_threshold", 1000000)
        v.SetDefault("mediamtx.rtsp_monitoring.packet_loss_threshold", 0.05)
        v.SetDefault("mediamtx.rtsp_monitoring.jitter_threshold", 50.0)

        // External Stream Discovery defaults
        v.SetDefault("mediamtx.external_discovery.enabled", true)
        v.SetDefault("mediamtx.external_discovery.scan_interval", 0)        // On-demand only
        v.SetDefault("mediamtx.external_discovery.scan_timeout", 30)        // 30 seconds max
        v.SetDefault("mediamtx.external_discovery.max_concurrent_scans", 5) // Limit concurrency
        v.SetDefault("mediamtx.external_discovery.enable_startup_scan", true)

        // Skydio-specific defaults (validated from official docs)
        v.SetDefault("mediamtx.external_discovery.skydio.enabled", true)
        v.SetDefault("mediamtx.external_discovery.skydio.network_ranges", []string{"192.168.42.0/24"})
        v.SetDefault("mediamtx.external_discovery.skydio.eo_port", 5554)
        v.SetDefault("mediamtx.external_discovery.skydio.ir_port", 6554)
        v.SetDefault("mediamtx.external_discovery.skydio.eo_stream_path", "/subject")
        v.SetDefault("mediamtx.external_discovery.skydio.ir_stream_path", "/infrared")
        v.SetDefault("mediamtx.external_discovery.skydio.enable_both_streams", true)
        v.SetDefault("mediamtx.external_discovery.skydio.known_ips", []string{"192.168.42.10"})

        // Generic UAV defaults (for other models)
        v.SetDefault("mediamtx.external_discovery.generic_uav.enabled", false)
        v.SetDefault("mediamtx.external_discovery.generic_uav.network_ranges", []string{})
        v.SetDefault("mediamtx.external_discovery.generic_uav.common_ports", []int{554, 8554})
        v.SetDefault("mediamtx.external_discovery.generic_uav.stream_paths", []string{"/stream", "/live", "/video"})
        v.SetDefault("mediamtx.external_discovery.generic_uav.known_ips", []string{})

        // MediaMTX stream readiness defaults
        v.SetDefault("mediamtx.stream_readiness.timeout", 15.0)
        v.SetDefault("mediamtx.stream_readiness.retry_attempts", 3)
        v.SetDefault("mediamtx.stream_readiness.retry_delay", 2.0)
        v.SetDefault("mediamtx.stream_readiness.check_interval", 0.5)
        v.SetDefault("mediamtx.stream_readiness.enable_progress_notifications", true)
        v.SetDefault("mediamtx.stream_readiness.graceful_fallback", true)

        // FFmpeg defaults
        v.SetDefault("ffmpeg.snapshot.process_creation_timeout", 5.0)
        v.SetDefault("ffmpeg.snapshot.execution_timeout", 8.0)
        v.SetDefault("ffmpeg.snapshot.internal_timeout", 5000000)
        v.SetDefault("ffmpeg.snapshot.retry_attempts", 2)
        v.SetDefault("ffmpeg.snapshot.retry_delay", 1.0)

        v.SetDefault("ffmpeg.recording.process_creation_timeout", 10.0)
        v.SetDefault("ffmpeg.recording.execution_timeout", 15.0)
        v.SetDefault("ffmpeg.recording.internal_timeout", 10000000)
        v.SetDefault("ffmpeg.recording.retry_attempts", 3)
        v.SetDefault("ffmpeg.recording.retry_delay", 2.0)

        // Notifications defaults
        v.SetDefault("notifications.websocket.delivery_timeout", 5.0)
        v.SetDefault("notifications.websocket.retry_attempts", 3)
        v.SetDefault("notifications.websocket.retry_delay", 1.0)
        v.SetDefault("notifications.websocket.max_queue_size", 1000)
        v.SetDefault("notifications.websocket.cleanup_interval", 30)

        v.SetDefault("notifications.real_time.camera_status_interval", 1.0)
        v.SetDefault("notifications.real_time.recording_progress_interval", 0.5)
        v.SetDefault("notifications.real_time.connection_health_check", 10.0)

        // Performance defaults
        v.SetDefault("performance.response_time_targets.snapshot_capture", 2.0)
        v.SetDefault("performance.response_time_targets.recording_start", 2.0)
        v.SetDefault("performance.response_time_targets.recording_stop", 2.0)
        v.SetDefault("performance.response_time_targets.file_listing", 1.0)

        v.SetDefault("performance.snapshot_tiers.tier1_usb_direct_timeout", 2.0)
        v.SetDefault("performance.snapshot_tiers.tier2_rtsp_ready_check_timeout", 1.0)
        v.SetDefault("performance.snapshot_tiers.tier3_activation_timeout", 3.0)
        v.SetDefault("performance.snapshot_tiers.tier3_activation_trigger_timeout", 1.0)
        v.SetDefault("performance.snapshot_tiers.total_operation_timeout", 10.0)
        v.SetDefault("performance.snapshot_tiers.immediate_response_threshold", 0.5)
        v.SetDefault("performance.snapshot_tiers.acceptable_response_threshold", 2.0)
        v.SetDefault("performance.snapshot_tiers.slow_response_threshold", 5.0)

        v.SetDefault("performance.optimization.enable_caching", true)
        v.SetDefault("performance.optimization.cache_ttl", 300)
        v.SetDefault("performance.optimization.max_concurrent_operations", 5)
        v.SetDefault("performance.optimization.connection_pool_size", 10)

        // Monitoring thresholds defaults
        v.SetDefault("performance.monitoring_thresholds.memory_usage_percent", 90.0)
        v.SetDefault("performance.monitoring_thresholds.error_rate_percent", 5.0)
        v.SetDefault("performance.monitoring_thresholds.average_response_time_ms", 1000.0)
        v.SetDefault("performance.monitoring_thresholds.active_connections_limit", 900)
        v.SetDefault("performance.monitoring_thresholds.goroutines_limit", 1000)

        // Debounce configuration defaults
        v.SetDefault("performance.debounce.health_monitor_seconds", 15)
        v.SetDefault("performance.debounce.storage_monitor_seconds", 30)
        v.SetDefault("performance.debounce.performance_monitor_seconds", 45)

        // Camera defaults
        v.SetDefault("camera.poll_interval", 0.1)
        v.SetDefault("camera.detection_timeout", 2.0)
        v.SetDefault("camera.device_range", []int{0, 9})
        v.SetDefault("camera.enable_capability_detection", true)
        v.SetDefault("camera.auto_start_streams", true)
        v.SetDefault("camera.capability_timeout", 5.0)
        v.SetDefault("camera.capability_retry_interval", 1.0)
        v.SetDefault("camera.capability_max_retries", 3)

        // Retention policy defaults
        v.SetDefault("retention_policy.enabled", true)
        v.SetDefault("retention_policy.type", "age")
        v.SetDefault("retention_policy.max_age_days", 7)
        v.SetDefault("retention_policy.max_size_gb", 1)
        v.SetDefault("retention_policy.auto_cleanup", true)

        // Logging defaults
        v.SetDefault("logging.level", "INFO")
        v.SetDefault("logging.format", "%(asctime)s - %(name)s - %(levelname)s - %(message)s")
        v.SetDefault("logging.file_enabled", true)
        v.SetDefault("logging.file_path", "/opt/camera-service/logs/camera-service.log")
        v.SetDefault("logging.max_file_size", 10485760)
        v.SetDefault("logging.backup_count", 5)
        v.SetDefault("logging.console_enabled", true)

        // Recording defaults
        v.SetDefault("recording.enabled", false)
        v.SetDefault("recording.format", "fmp4")
        v.SetDefault("recording.quality", "high")
        v.SetDefault("recording.segment_duration", 3600)
        v.SetDefault("recording.max_segment_size", 524288000)
        v.SetDefault("recording.auto_cleanup", true)
        v.SetDefault("recording.cleanup_interval", 86400)
        v.SetDefault("recording.max_age", 604800)
        v.SetDefault("recording.max_size", 10737418240)

        // Snapshots defaults
        v.SetDefault("snapshots.enabled", true)
        v.SetDefault("snapshots.format", "jpeg")
        v.SetDefault("snapshots.quality", 90)
        v.SetDefault("snapshots.max_width", 1920)
        v.SetDefault("snapshots.max_height", 1080)
        v.SetDefault("snapshots.auto_cleanup", true)
        v.SetDefault("snapshots.cleanup_interval", 3600)
        v.SetDefault("snapshots.max_age", 86400)
        v.SetDefault("snapshots.max_count", 1000)

        // Storage defaults
        v.SetDefault("storage.warn_percent", 80)
        v.SetDefault("storage.block_percent", 90)
        v.SetDefault("storage.default_path", "/opt/camera-service/recordings")
        v.SetDefault("storage.fallback_path", "/tmp/recordings")
}</span>

// notifyConfigUpdated notifies all registered callbacks of configuration updates.
func (cm *ConfigManager) notifyConfigUpdated(oldConfig, newConfig *Config) <span class="cov8" title="1">{
        // Create error channel for callback panics
        panicChan := make(chan error, len(cm.updateCallbacks))

        // Create WaitGroup to track callback goroutines
        var callbackWg sync.WaitGroup

        for _, callback := range cm.updateCallbacks </span><span class="cov8" title="1">{
                callbackWg.Add(1)
                go func(cb func(*Config), config *Config) </span><span class="cov8" title="1">{
                        defer callbackWg.Done()
                        defer func() </span><span class="cov8" title="1">{
                                // Recover from panics in goroutine and propagate as errors
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        panicErr := fmt.Errorf("panic in config callback: %v", r)
                                        cm.logger.WithError(panicErr).Error("Config callback panic")

                                        // Propagate panic as error instead of swallowing it
                                        select </span>{
                                        case panicChan &lt;- panicErr:<span class="cov0" title="0"></span>
                                        default:<span class="cov0" title="0">
                                                cm.logger.WithError(panicErr).Warn("Panic channel overflow, panic error dropped")</span>
                                        }
                                }
                        }()
                        <span class="cov8" title="1">cb(config)</span>
                }(callback, newConfig)
        }

        // Process any panics that occurred in config callbacks
        <span class="cov8" title="1">cm.wg.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer cm.wg.Done()
                // Wait for all callbacks to complete
                callbackWg.Wait()
                // Close the panic channel to signal the processing goroutine to exit
                close(panicChan)
        }</span>()

        // Process panic errors
        <span class="cov8" title="1">cm.wg.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer cm.wg.Done()
                for err := range panicChan </span><span class="cov0" title="0">{
                        cm.logger.WithError(err).Warn("Config callback panic occurred")
                        // Optionally increment error counters or trigger recovery mechanisms
                }</span>
        }()
}

// getDefaultConfig returns a default configuration instance.
func getDefaultConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                Server: ServerConfig{
                        Host:                 "0.0.0.0",
                        Port:                 8002,
                        WebSocketPath:        "/ws",
                        MaxConnections:       100,
                        ReadTimeout:          5 * time.Second,
                        WriteTimeout:         1 * time.Second,
                        PingInterval:         30 * time.Second,
                        PongWait:             60 * time.Second,
                        MaxMessageSize:       1024 * 1024, // 1MB
                        ReadBufferSize:       1024,
                        WriteBufferSize:      1024,
                        ShutdownTimeout:      30 * time.Second,
                        ClientCleanupTimeout: 10 * time.Second,
                },
                MediaMTX: MediaMTXConfig{
                        Host:                                "127.0.0.1",
                        APIPort:                             9997,
                        RTSPPort:                            8554,
                        WebRTCPort:                          8889,
                        HLSPort:                             8888,
                        ConfigPath:                          "/opt/camera-service/config/mediamtx.yml",
                        RecordingsPath:                      "/opt/camera-service/recordings",
                        SnapshotsPath:                       "/opt/camera-service/snapshots",
                        HealthCheckInterval:                 30,
                        HealthFailureThreshold:              10,
                        HealthCircuitBreakerTimeout:         60,
                        HealthMaxBackoffInterval:            120,
                        HealthRecoveryConfirmationThreshold: 3,
                        BackoffBaseMultiplier:               2.0,
                        BackoffJitterRange:                  []float64{0.8, 1.2},
                        ProcessTerminationTimeout:           3.0,
                        ProcessKillTimeout:                  2.0,
                },
                Camera: CameraConfig{
                        PollInterval:              0.1,
                        DetectionTimeout:          2.0,
                        DeviceRange:               []int{0, 9},
                        EnableCapabilityDetection: true,
                        AutoStartStreams:          true,
                        CapabilityTimeout:         5.0,
                        CapabilityRetryInterval:   1.0,
                        CapabilityMaxRetries:      3,
                },
                Logging: LoggingConfig{
                        Level:          "INFO",
                        Format:         "%(asctime)s - %(name)s - %(levelname)s - %(message)s",
                        FileEnabled:    true,
                        FilePath:       "/opt/camera-service/logs/camera-service.log",
                        MaxFileSize:    10485760,
                        BackupCount:    5,
                        ConsoleEnabled: true,
                },
                Recording: RecordingConfig{
                        Enabled:         false,
                        Format:          "fmp4",
                        Quality:         "high",
                        SegmentDuration: 3600,
                        MaxSegmentSize:  524288000,
                        AutoCleanup:     true,
                        CleanupInterval: 86400,
                        MaxAge:          604800,
                        MaxSize:         10737418240,
                },
                Snapshots: SnapshotConfig{
                        Enabled:         true,
                        Format:          "jpeg",
                        Quality:         90,
                        MaxWidth:        1920,
                        MaxHeight:       1080,
                        AutoCleanup:     true,
                        CleanupInterval: 3600,
                        MaxAge:          86400,
                        MaxCount:        1000,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strings"
        "syscall"

        "github.com/camerarecorder/mediamtx-camera-service-go/internal/logging"
)

// ValidationError represents a configuration validation error.
type ValidationError struct {
        Field   string
        Message string
}

func (e *ValidationError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("validation error for field '%s': %s", e.Field, e.Message)
}</span>

// ValidateConfig performs comprehensive validation of the configuration.
func ValidateConfig(config *Config) error <span class="cov8" title="1">{
        var errors []error

        // Validate each configuration section
        if err := validateServerConfig(&amp;config.Server); err != nil </span><span class="cov0" title="0">{
                errors = append(errors, err)
        }</span>

        <span class="cov8" title="1">if err := validateMediaMTXConfig(&amp;config.MediaMTX); err != nil </span><span class="cov8" title="1">{
                errors = append(errors, err)
        }</span>

        <span class="cov8" title="1">if err := validateCameraConfig(&amp;config.Camera); err != nil </span><span class="cov8" title="1">{
                errors = append(errors, err)
        }</span>

        <span class="cov8" title="1">if err := validateLoggingConfig(&amp;config.Logging); err != nil </span><span class="cov8" title="1">{
                errors = append(errors, err)
        }</span>

        <span class="cov8" title="1">if err := validateRecordingConfig(&amp;config.Recording); err != nil </span><span class="cov0" title="0">{
                errors = append(errors, err)
        }</span>

        <span class="cov8" title="1">if err := validateSnapshotConfig(&amp;config.Snapshots); err != nil </span><span class="cov0" title="0">{
                errors = append(errors, err)
        }</span>

        <span class="cov8" title="1">if err := validateFFmpegConfig(&amp;config.FFmpeg); err != nil </span><span class="cov0" title="0">{
                errors = append(errors, err)
        }</span>

        <span class="cov8" title="1">if err := validateNotificationsConfig(&amp;config.Notifications); err != nil </span><span class="cov0" title="0">{
                errors = append(errors, err)
        }</span>

        <span class="cov8" title="1">if err := validatePerformanceConfig(&amp;config.Performance); err != nil </span><span class="cov8" title="1">{
                errors = append(errors, err)
        }</span>

        <span class="cov8" title="1">if err := validateRetentionPolicyConfig(&amp;config.RetentionPolicy); err != nil </span><span class="cov8" title="1">{
                errors = append(errors, err)
        }</span>

        <span class="cov8" title="1">if err := validateSecurityConfig(&amp;config.Security); err != nil </span><span class="cov8" title="1">{
                errors = append(errors, err)
        }</span>

        <span class="cov8" title="1">if err := validateServerDefaults(&amp;config.ServerDefaults); err != nil </span><span class="cov0" title="0">{
                errors = append(errors, err)
        }</span>

        <span class="cov8" title="1">if err := validateStorageConfig(&amp;config.Storage); err != nil </span><span class="cov0" title="0">{
                errors = append(errors, err)
        }</span>

        // CRITICAL: Add comprehensive path validation
        <span class="cov8" title="1">if err := ValidatePathConfiguration(config); err != nil </span><span class="cov8" title="1">{
                errors = append(errors, err)
        }</span>

        // Return combined errors if any
        <span class="cov8" title="1">if len(errors) &gt; 0 </span><span class="cov8" title="1">{
                return &amp;ValidationError{
                        Field:   "config",
                        Message: fmt.Sprintf("configuration validation failed: %v", errors),
                }
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateServerConfig validates server configuration.
func validateServerConfig(config *ServerConfig) error <span class="cov8" title="1">{
        if config.Host == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "server.host", Message: "host cannot be empty"}
        }</span>

        <span class="cov8" title="1">if config.Port &lt;= 0 || config.Port &gt; 65535 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "server.port", Message: fmt.Sprintf("port must be between 1 and 65535, got %d", config.Port)}
        }</span>

        <span class="cov8" title="1">if config.WebSocketPath == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "server.websocket_path", Message: "websocket path cannot be empty"}
        }</span>

        <span class="cov8" title="1">if !strings.HasPrefix(config.WebSocketPath, "/") </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "server.websocket_path", Message: "websocket path must start with '/'"}
        }</span>

        <span class="cov8" title="1">if config.MaxConnections &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "server.max_connections", Message: fmt.Sprintf("max connections must be positive, got %d", config.MaxConnections)}
        }</span>

        <span class="cov8" title="1">if config.ReadTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "server.read_timeout", Message: fmt.Sprintf("read timeout must be positive, got %v", config.ReadTimeout)}
        }</span>

        <span class="cov8" title="1">if config.WriteTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "server.write_timeout", Message: fmt.Sprintf("write timeout must be positive, got %v", config.WriteTimeout)}
        }</span>

        <span class="cov8" title="1">if config.PingInterval &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "server.ping_interval", Message: fmt.Sprintf("ping interval must be positive, got %v", config.PingInterval)}
        }</span>

        <span class="cov8" title="1">if config.PongWait &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "server.pong_wait", Message: fmt.Sprintf("pong wait must be positive, got %v", config.PongWait)}
        }</span>

        <span class="cov8" title="1">if config.MaxMessageSize &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "server.max_message_size", Message: fmt.Sprintf("max message size must be positive, got %d", config.MaxMessageSize)}
        }</span>

        <span class="cov8" title="1">if config.ReadBufferSize &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "server.read_buffer_size", Message: fmt.Sprintf("read buffer size must be positive, got %d", config.ReadBufferSize)}
        }</span>

        <span class="cov8" title="1">if config.WriteBufferSize &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "server.write_buffer_size", Message: fmt.Sprintf("write buffer size must be positive, got %d", config.WriteBufferSize)}
        }</span>

        <span class="cov8" title="1">if config.ShutdownTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "server.shutdown_timeout", Message: fmt.Sprintf("shutdown timeout must be positive, got %v", config.ShutdownTimeout)}
        }</span>

        <span class="cov8" title="1">if config.ClientCleanupTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "server.client_cleanup_timeout", Message: fmt.Sprintf("client cleanup timeout must be positive, got %v", config.ClientCleanupTimeout)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateMediaMTXConfig validates MediaMTX configuration.
func validateMediaMTXConfig(config *MediaMTXConfig) error <span class="cov8" title="1">{
        if config.Host == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.host", Message: "host cannot be empty"}
        }</span>

        <span class="cov8" title="1">if config.APIPort &lt;= 0 || config.APIPort &gt; 65535 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.api_port", Message: fmt.Sprintf("API port must be between 1 and 65535, got %d", config.APIPort)}
        }</span>

        <span class="cov8" title="1">if config.RTSPPort &lt;= 0 || config.RTSPPort &gt; 65535 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.rtsp_port", Message: fmt.Sprintf("RTSP port must be between 1 and 65535, got %d", config.RTSPPort)}
        }</span>

        <span class="cov8" title="1">if config.WebRTCPort &lt;= 0 || config.WebRTCPort &gt; 65535 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.webrtc_port", Message: fmt.Sprintf("WebRTC port must be between 1 and 65535, got %d", config.WebRTCPort)}
        }</span>

        <span class="cov8" title="1">if config.HLSPort &lt;= 0 || config.HLSPort &gt; 65535 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.hls_port", Message: fmt.Sprintf("HLS port must be between 1 and 65535, got %d", config.HLSPort)}
        }</span>

        <span class="cov8" title="1">if config.ConfigPath == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.config_path", Message: "config path cannot be empty"}
        }</span>

        <span class="cov8" title="1">if config.RecordingsPath == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.recordings_path", Message: "recordings path cannot be empty"}
        }</span>

        <span class="cov8" title="1">if config.SnapshotsPath == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.snapshots_path", Message: "snapshots path cannot be empty"}
        }</span>

        // Validate file paths exist and are accessible
        <span class="cov8" title="1">if err := validateFilePath("mediamtx.config_path", config.ConfigPath); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := validateFilePath("mediamtx.recordings_path", config.RecordingsPath); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := validateFilePath("mediamtx.snapshots_path", config.SnapshotsPath); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate codec configuration
        <span class="cov8" title="1">if err := validateCodecConfig(&amp;config.Codec); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to validate codec configuration: %w", err)
        }</span>

        // Validate health monitoring configuration
        <span class="cov8" title="1">if config.HealthCheckInterval &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.health_check_interval", Message: fmt.Sprintf("health check interval must be positive, got %d", config.HealthCheckInterval)}
        }</span>

        <span class="cov8" title="1">if config.HealthFailureThreshold &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.health_failure_threshold", Message: fmt.Sprintf("health failure threshold must be positive, got %d", config.HealthFailureThreshold)}
        }</span>

        <span class="cov8" title="1">if config.HealthCircuitBreakerTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.health_circuit_breaker_timeout", Message: fmt.Sprintf("circuit breaker timeout must be positive, got %d", config.HealthCircuitBreakerTimeout)}
        }</span>

        <span class="cov8" title="1">if config.HealthMaxBackoffInterval &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.health_max_backoff_interval", Message: fmt.Sprintf("max backoff interval must be positive, got %d", config.HealthMaxBackoffInterval)}
        }</span>

        <span class="cov8" title="1">if config.HealthRecoveryConfirmationThreshold &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.health_recovery_confirmation_threshold", Message: fmt.Sprintf("recovery confirmation threshold must be positive, got %d", config.HealthRecoveryConfirmationThreshold)}
        }</span>

        <span class="cov8" title="1">if config.BackoffBaseMultiplier &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.backoff_base_multiplier", Message: fmt.Sprintf("backoff base multiplier must be positive, got %f", config.BackoffBaseMultiplier)}
        }</span>

        <span class="cov8" title="1">if len(config.BackoffJitterRange) != 2 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.backoff_jitter_range", Message: "backoff jitter range must have exactly 2 elements"}
        }</span>

        <span class="cov8" title="1">if config.BackoffJitterRange[0] &gt;= config.BackoffJitterRange[1] </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.backoff_jitter_range", Message: "backoff jitter range min must be less than max"}
        }</span>

        <span class="cov8" title="1">if config.ProcessTerminationTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.process_termination_timeout", Message: fmt.Sprintf("process termination timeout must be positive, got %f", config.ProcessTerminationTimeout)}
        }</span>

        <span class="cov8" title="1">if config.ProcessKillTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.process_kill_timeout", Message: fmt.Sprintf("process kill timeout must be positive, got %f", config.ProcessKillTimeout)}
        }</span>

        // Validate RTSP monitoring configuration
        <span class="cov8" title="1">if err := validateRTSPMonitoringConfig(&amp;config.RTSPMonitoring); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate stream readiness configuration
        <span class="cov8" title="1">if err := validateStreamReadinessConfig(&amp;config.StreamReadiness); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to validate stream readiness configuration: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateFilePath validates that a file path exists and is accessible
func validateFilePath(fieldName, path string) error <span class="cov8" title="1">{
        if path == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: fieldName, Message: "path cannot be empty"}
        }</span>

        // Clean the path to prevent path traversal attacks
        <span class="cov8" title="1">cleanPath := filepath.Clean(path)
        if cleanPath != path </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: fieldName, Message: fmt.Sprintf("path contains invalid characters or traversal attempts: %s", path)}
        }</span>

        // Check if path is absolute (recommended for security)
        <span class="cov8" title="1">if !filepath.IsAbs(cleanPath) </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: fieldName, Message: fmt.Sprintf("path should be absolute for security: %s", path)}
        }</span>

        // Check if path exists on filesystem
        <span class="cov8" title="1">if _, err := os.Stat(cleanPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return &amp;ValidationError{Field: fieldName, Message: fmt.Sprintf("path does not exist: %s", path)}
        }</span>

        // Check if path is accessible (readable)
        <span class="cov8" title="1">if _, err := os.Stat(cleanPath); err != nil </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: fieldName, Message: fmt.Sprintf("path is not accessible: %s - %v", path, err)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateLogFilePath validates that a log file path is valid and its directory is accessible
func validateLogFilePath(fieldName, path string) error <span class="cov8" title="1">{
        if path == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: fieldName, Message: "log file path cannot be empty"}
        }</span>

        // Clean the path to prevent path traversal attacks
        <span class="cov8" title="1">cleanPath := filepath.Clean(path)
        if cleanPath != path </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: fieldName, Message: fmt.Sprintf("log file path contains invalid characters or traversal attempts: %s", path)}
        }</span>

        // Check if path is absolute (recommended for security)
        <span class="cov8" title="1">if !filepath.IsAbs(cleanPath) </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: fieldName, Message: fmt.Sprintf("log file path should be absolute for security: %s", path)}
        }</span>

        // Get the directory path for the log file
        <span class="cov8" title="1">logDir := filepath.Dir(cleanPath)

        // Check if the directory exists and is accessible
        if _, err := os.Stat(logDir); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return &amp;ValidationError{Field: fieldName, Message: fmt.Sprintf("log directory does not exist: %s", logDir)}
        }</span>

        // Check if the directory is accessible (writable for log files)
        <span class="cov8" title="1">if _, err := os.Stat(logDir); err != nil </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: fieldName, Message: fmt.Sprintf("log directory is not accessible: %s - %v", logDir, err)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateCodecConfig validates codec configuration.
func validateCodecConfig(config *CodecConfig) error <span class="cov8" title="1">{
        validProfiles := []string{"baseline", "main", "high"}
        if !contains(validProfiles, config.VideoProfile) </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.codec.video_profile", Message: fmt.Sprintf("video profile must be one of %v, got %s", validProfiles, config.VideoProfile)}
        }</span>

        <span class="cov8" title="1">validLevels := []string{"1.0", "1.1", "1.2", "1.3", "2.0", "2.1", "2.2", "3.0", "3.1", "3.2", "4.0", "4.1", "4.2", "5.0", "5.1", "5.2"}
        if !contains(validLevels, config.VideoLevel) </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.codec.video_level", Message: fmt.Sprintf("video level must be one of %v, got %s", validLevels, config.VideoLevel)}
        }</span>

        <span class="cov8" title="1">validFormats := []string{"yuv420p", "yuv422p", "yuv444p"}
        if !contains(validFormats, config.PixelFormat) </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.codec.pixel_format", Message: fmt.Sprintf("pixel format must be one of %v, got %s", validFormats, config.PixelFormat)}
        }</span>

        <span class="cov8" title="1">if config.Bitrate == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.codec.bitrate", Message: "bitrate cannot be empty"}
        }</span>

        <span class="cov8" title="1">validPresets := []string{"ultrafast", "superfast", "veryfast", "faster", "fast", "medium", "slow", "slower", "veryslow"}
        if !contains(validPresets, config.Preset) </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.codec.preset", Message: fmt.Sprintf("preset must be one of %v, got %s", validPresets, config.Preset)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateStreamReadinessConfig validates stream readiness configuration.
func validateStreamReadinessConfig(config *StreamReadinessConfig) error <span class="cov8" title="1">{
        if config.Timeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.stream_readiness.timeout", Message: fmt.Sprintf("timeout must be positive, got %f", config.Timeout)}
        }</span>

        <span class="cov8" title="1">if config.RetryAttempts &lt; 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.stream_readiness.retry_attempts", Message: fmt.Sprintf("retry attempts must be non-negative, got %d", config.RetryAttempts)}
        }</span>

        <span class="cov8" title="1">if config.RetryDelay &lt; 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.stream_readiness.retry_delay", Message: fmt.Sprintf("retry delay must be non-negative, got %f", config.RetryDelay)}
        }</span>

        <span class="cov8" title="1">if config.CheckInterval &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.stream_readiness.check_interval", Message: fmt.Sprintf("check interval must be positive, got %f", config.CheckInterval)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateCameraConfig validates camera configuration.
func validateCameraConfig(config *CameraConfig) error <span class="cov8" title="1">{
        if config.PollInterval &lt; 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "camera.poll_interval", Message: fmt.Sprintf("poll interval must be non-negative, got %f", config.PollInterval)}
        }</span>

        <span class="cov8" title="1">if config.DetectionTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "camera.detection_timeout", Message: fmt.Sprintf("detection timeout must be positive, got %f", config.DetectionTimeout)}
        }</span>

        <span class="cov8" title="1">if len(config.DeviceRange) != 2 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "camera.device_range", Message: "device range must have exactly 2 elements"}
        }</span>

        <span class="cov8" title="1">if config.DeviceRange[0] &lt; 0 || config.DeviceRange[1] &lt; 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "camera.device_range", Message: "device range values must be non-negative"}
        }</span>

        <span class="cov8" title="1">if config.DeviceRange[0] &gt; config.DeviceRange[1] </span><span class="cov8" title="1">{
                return &amp;ValidationError{Field: "camera.device_range", Message: "device range min must be less than or equal to max"}
        }</span>

        <span class="cov8" title="1">if config.CapabilityTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "camera.capability_timeout", Message: fmt.Sprintf("capability timeout must be positive, got %f", config.CapabilityTimeout)}
        }</span>

        <span class="cov8" title="1">if config.CapabilityRetryInterval &lt; 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "camera.capability_retry_interval", Message: fmt.Sprintf("capability retry interval must be non-negative, got %f", config.CapabilityRetryInterval)}
        }</span>

        <span class="cov8" title="1">if config.CapabilityMaxRetries &lt; 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "camera.capability_max_retries", Message: fmt.Sprintf("capability max retries must be non-negative, got %d", config.CapabilityMaxRetries)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateLoggingConfig validates logging configuration.
func validateLoggingConfig(config *LoggingConfig) error <span class="cov8" title="1">{
        validLevels := []string{"DEBUG", "INFO", "WARN", "WARNING", "ERROR", "FATAL"}
        if !contains(validLevels, strings.ToUpper(config.Level)) </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "logging.level", Message: fmt.Sprintf("log level must be one of %v, got %s", validLevels, config.Level)}
        }</span>

        <span class="cov8" title="1">if config.Format == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "logging.format", Message: "log format cannot be empty"}
        }</span>

        <span class="cov8" title="1">if config.FileEnabled &amp;&amp; config.FilePath == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "logging.file_path", Message: "file path cannot be empty when file logging is enabled"}
        }</span>

        // Validate log file path when file logging is enabled
        <span class="cov8" title="1">if config.FileEnabled &amp;&amp; config.FilePath != "" </span><span class="cov8" title="1">{
                if err := validateLogFilePath("logging.file_path", config.FilePath); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if config.MaxFileSize &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "logging.max_file_size", Message: fmt.Sprintf("max file size must be positive, got %d", config.MaxFileSize)}
        }</span>

        <span class="cov8" title="1">if config.BackupCount &lt; 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "logging.backup_count", Message: fmt.Sprintf("backup count must be non-negative, got %d", config.BackupCount)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateRecordingConfig validates recording configuration.
func validateRecordingConfig(config *RecordingConfig) error <span class="cov8" title="1">{
        validFormats := []string{"fmp4", "mp4", "mkv", "avi"}
        if !contains(validFormats, config.Format) </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "recording.format", Message: fmt.Sprintf("recording format must be one of %v, got %s", validFormats, config.Format)}
        }</span>

        <span class="cov8" title="1">validQualities := []string{"low", "medium", "high"}
        if !contains(validQualities, config.Quality) </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "recording.quality", Message: fmt.Sprintf("recording quality must be one of %v, got %s", validQualities, config.Quality)}
        }</span>

        <span class="cov8" title="1">if config.SegmentDuration &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "recording.segment_duration", Message: fmt.Sprintf("segment duration must be positive, got %d", config.SegmentDuration)}
        }</span>

        <span class="cov8" title="1">if config.MaxSegmentSize &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "recording.max_segment_size", Message: fmt.Sprintf("max segment size must be positive, got %d", config.MaxSegmentSize)}
        }</span>

        <span class="cov8" title="1">if config.CleanupInterval &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "recording.cleanup_interval", Message: fmt.Sprintf("cleanup interval must be positive, got %d", config.CleanupInterval)}
        }</span>

        <span class="cov8" title="1">if config.MaxAge &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "recording.max_age", Message: fmt.Sprintf("max age must be positive, got %d", config.MaxAge)}
        }</span>

        <span class="cov8" title="1">if config.MaxSize &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "recording.max_size", Message: fmt.Sprintf("max size must be positive, got %d", config.MaxSize)}
        }</span>

        <span class="cov8" title="1">if config.DefaultRotationSize &lt; 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "recording.default_rotation_size", Message: fmt.Sprintf("recording default rotation size cannot be negative, got %d", config.DefaultRotationSize)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateSnapshotConfig validates snapshot configuration.
func validateSnapshotConfig(config *SnapshotConfig) error <span class="cov8" title="1">{
        validFormats := []string{"jpeg", "png", "bmp"}
        if !contains(validFormats, config.Format) </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "snapshots.format", Message: fmt.Sprintf("snapshot format must be one of %v, got %s", validFormats, config.Format)}
        }</span>

        <span class="cov8" title="1">if config.Quality &lt; 1 || config.Quality &gt; 100 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "snapshots.quality", Message: fmt.Sprintf("quality must be between 1 and 100, got %d", config.Quality)}
        }</span>

        <span class="cov8" title="1">if config.MaxWidth &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "snapshots.max_width", Message: fmt.Sprintf("max width must be positive, got %d", config.MaxWidth)}
        }</span>

        <span class="cov8" title="1">if config.MaxHeight &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "snapshots.max_height", Message: fmt.Sprintf("max height must be positive, got %d", config.MaxHeight)}
        }</span>

        <span class="cov8" title="1">if config.CleanupInterval &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "snapshots.cleanup_interval", Message: fmt.Sprintf("cleanup interval must be positive, got %d", config.CleanupInterval)}
        }</span>

        <span class="cov8" title="1">if config.MaxAge &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "snapshots.max_age", Message: fmt.Sprintf("max age must be positive, got %d", config.MaxAge)}
        }</span>

        <span class="cov8" title="1">if config.MaxCount &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "snapshots.max_count", Message: fmt.Sprintf("max count must be positive, got %d", config.MaxCount)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateFFmpegConfig validates FFmpeg configuration.
func validateFFmpegConfig(config *FFmpegConfig) error <span class="cov8" title="1">{
        if err := validateFFmpegSnapshotConfig(&amp;config.Snapshot); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to validate FFmpeg snapshot config: %w", err)
        }</span>

        <span class="cov8" title="1">if err := validateFFmpegRecordingConfig(&amp;config.Recording); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to validate FFmpeg recording config: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateFFmpegSnapshotConfig validates FFmpeg snapshot configuration.
func validateFFmpegSnapshotConfig(config *FFmpegSnapshotConfig) error <span class="cov8" title="1">{
        if config.ProcessCreationTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "ffmpeg.snapshot.process_creation_timeout", Message: fmt.Sprintf("process creation timeout must be positive, got %f", config.ProcessCreationTimeout)}
        }</span>

        <span class="cov8" title="1">if config.ExecutionTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "ffmpeg.snapshot.execution_timeout", Message: fmt.Sprintf("execution timeout must be positive, got %f", config.ExecutionTimeout)}
        }</span>

        <span class="cov8" title="1">if config.InternalTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "ffmpeg.snapshot.internal_timeout", Message: fmt.Sprintf("internal timeout must be positive, got %d", config.InternalTimeout)}
        }</span>

        <span class="cov8" title="1">if config.RetryAttempts &lt; 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "ffmpeg.snapshot.retry_attempts", Message: fmt.Sprintf("retry attempts must be non-negative, got %d", config.RetryAttempts)}
        }</span>

        <span class="cov8" title="1">if config.RetryDelay &lt; 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "ffmpeg.snapshot.retry_delay", Message: fmt.Sprintf("retry delay must be non-negative, got %f", config.RetryDelay)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateFFmpegRecordingConfig validates FFmpeg recording configuration.
func validateFFmpegRecordingConfig(config *FFmpegRecordingConfig) error <span class="cov8" title="1">{
        if config.ProcessCreationTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "ffmpeg.recording.process_creation_timeout", Message: fmt.Sprintf("process creation timeout must be positive, got %f", config.ProcessCreationTimeout)}
        }</span>

        <span class="cov8" title="1">if config.ExecutionTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "ffmpeg.recording.execution_timeout", Message: fmt.Sprintf("execution timeout must be positive, got %f", config.ExecutionTimeout)}
        }</span>

        <span class="cov8" title="1">if config.InternalTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "ffmpeg.recording.internal_timeout", Message: fmt.Sprintf("internal timeout must be positive, got %d", config.InternalTimeout)}
        }</span>

        <span class="cov8" title="1">if config.RetryAttempts &lt; 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "ffmpeg.recording.retry_attempts", Message: fmt.Sprintf("retry attempts must be non-negative, got %d", config.RetryAttempts)}
        }</span>

        <span class="cov8" title="1">if config.RetryDelay &lt; 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "ffmpeg.recording.retry_delay", Message: fmt.Sprintf("retry delay must be non-negative, got %f", config.RetryDelay)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateNotificationsConfig validates notifications configuration.
func validateNotificationsConfig(config *NotificationsConfig) error <span class="cov8" title="1">{
        if err := validateWebSocketNotificationConfig(&amp;config.WebSocket); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to validate WebSocket notification config: %w", err)
        }</span>

        <span class="cov8" title="1">if err := validateRealTimeNotificationConfig(&amp;config.RealTime); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to validate real-time notification config: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateWebSocketNotificationConfig validates WebSocket notification configuration.
func validateWebSocketNotificationConfig(config *WebSocketNotificationConfig) error <span class="cov8" title="1">{
        if config.DeliveryTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "notifications.websocket.delivery_timeout", Message: fmt.Sprintf("delivery timeout must be positive, got %f", config.DeliveryTimeout)}
        }</span>

        <span class="cov8" title="1">if config.RetryAttempts &lt; 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "notifications.websocket.retry_attempts", Message: fmt.Sprintf("retry attempts must be non-negative, got %d", config.RetryAttempts)}
        }</span>

        <span class="cov8" title="1">if config.RetryDelay &lt; 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "notifications.websocket.retry_delay", Message: fmt.Sprintf("retry delay must be non-negative, got %f", config.RetryDelay)}
        }</span>

        <span class="cov8" title="1">if config.MaxQueueSize &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "notifications.websocket.max_queue_size", Message: fmt.Sprintf("max queue size must be positive, got %d", config.MaxQueueSize)}
        }</span>

        <span class="cov8" title="1">if config.CleanupInterval &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "notifications.websocket.cleanup_interval", Message: fmt.Sprintf("cleanup interval must be positive, got %d", config.CleanupInterval)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateRealTimeNotificationConfig validates real-time notification configuration.
func validateRealTimeNotificationConfig(config *RealTimeNotificationConfig) error <span class="cov8" title="1">{
        if config.CameraStatusInterval &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "notifications.real_time.camera_status_interval", Message: fmt.Sprintf("camera status interval must be positive, got %f", config.CameraStatusInterval)}
        }</span>

        <span class="cov8" title="1">if config.RecordingProgressInterval &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "notifications.real_time.recording_progress_interval", Message: fmt.Sprintf("recording progress interval must be positive, got %f", config.RecordingProgressInterval)}
        }</span>

        <span class="cov8" title="1">if config.ConnectionHealthCheck &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "notifications.real_time.connection_health_check", Message: fmt.Sprintf("connection health check must be positive, got %f", config.ConnectionHealthCheck)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validatePerformanceConfig validates performance configuration.
func validatePerformanceConfig(config *PerformanceConfig) error <span class="cov8" title="1">{
        if err := validateResponseTimeTargetsConfig(&amp;config.ResponseTimeTargets); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to validate response time targets config: %w", err)
        }</span>

        <span class="cov8" title="1">if err := validateSnapshotTiersConfig(&amp;config.SnapshotTiers); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to validate snapshot tiers config: %w", err)
        }</span>

        <span class="cov8" title="1">if err := validateOptimizationConfig(&amp;config.Optimization); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to validate optimization config: %w", err)
        }</span>

        <span class="cov8" title="1">if err := validateMonitoringThresholdsConfig(&amp;config.MonitoringThresholds); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to validate monitoring thresholds config: %w", err)
        }</span>

        <span class="cov8" title="1">if err := validateDebounceConfig(&amp;config.Debounce); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to validate debounce config: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateResponseTimeTargetsConfig validates response time targets configuration.
func validateResponseTimeTargetsConfig(config *ResponseTimeTargetsConfig) error <span class="cov8" title="1">{
        if config.SnapshotCapture &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.response_time_targets.snapshot_capture", Message: fmt.Sprintf("snapshot capture target must be positive, got %f", config.SnapshotCapture)}
        }</span>

        <span class="cov8" title="1">if config.RecordingStart &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.response_time_targets.recording_start", Message: fmt.Sprintf("recording start target must be positive, got %f", config.RecordingStart)}
        }</span>

        <span class="cov8" title="1">if config.RecordingStop &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.response_time_targets.recording_stop", Message: fmt.Sprintf("recording stop target must be positive, got %f", config.RecordingStop)}
        }</span>

        <span class="cov8" title="1">if config.FileListing &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.response_time_targets.file_listing", Message: fmt.Sprintf("file listing target must be positive, got %f", config.FileListing)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateSnapshotTiersConfig validates snapshot tiers configuration.
func validateSnapshotTiersConfig(config *SnapshotTiersConfig) error <span class="cov8" title="1">{
        if config.Tier1USBDirectTimeout &lt;= 0 </span><span class="cov8" title="1">{
                return &amp;ValidationError{Field: "performance.snapshot_tiers.tier1_usb_direct_timeout", Message: fmt.Sprintf("tier1 USB direct timeout must be positive, got %f", config.Tier1USBDirectTimeout)}
        }</span>

        <span class="cov8" title="1">if config.Tier2RTSPReadyCheckTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.snapshot_tiers.tier2_rtsp_ready_check_timeout", Message: fmt.Sprintf("tier2 RTSP ready check timeout must be positive, got %f", config.Tier2RTSPReadyCheckTimeout)}
        }</span>

        <span class="cov8" title="1">if config.Tier3ActivationTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.snapshot_tiers.tier3_activation_timeout", Message: fmt.Sprintf("tier3 activation timeout must be positive, got %f", config.Tier3ActivationTimeout)}
        }</span>

        <span class="cov8" title="1">if config.Tier3ActivationTriggerTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.snapshot_tiers.tier3_activation_trigger_timeout", Message: fmt.Sprintf("tier3 activation trigger timeout must be positive, got %f", config.Tier3ActivationTriggerTimeout)}
        }</span>

        <span class="cov8" title="1">if config.TotalOperationTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.snapshot_tiers.total_operation_timeout", Message: fmt.Sprintf("total operation timeout must be positive, got %f", config.TotalOperationTimeout)}
        }</span>

        <span class="cov8" title="1">if config.ImmediateResponseThreshold &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.snapshot_tiers.immediate_response_threshold", Message: fmt.Sprintf("immediate response threshold must be positive, got %f", config.ImmediateResponseThreshold)}
        }</span>

        <span class="cov8" title="1">if config.AcceptableResponseThreshold &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.snapshot_tiers.acceptable_response_threshold", Message: fmt.Sprintf("acceptable response threshold must be positive, got %f", config.AcceptableResponseThreshold)}
        }</span>

        <span class="cov8" title="1">if config.SlowResponseThreshold &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.snapshot_tiers.slow_response_threshold", Message: fmt.Sprintf("slow response threshold must be positive, got %f", config.SlowResponseThreshold)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateOptimizationConfig validates optimization configuration.
func validateOptimizationConfig(config *OptimizationConfig) error <span class="cov8" title="1">{
        if config.CacheTTL &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.optimization.cache_ttl", Message: fmt.Sprintf("cache TTL must be positive, got %d", config.CacheTTL)}
        }</span>

        <span class="cov8" title="1">if config.MaxConcurrentOperations &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.optimization.max_concurrent_operations", Message: fmt.Sprintf("max concurrent operations must be positive, got %d", config.MaxConcurrentOperations)}
        }</span>

        <span class="cov8" title="1">if config.ConnectionPoolSize &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.optimization.connection_pool_size", Message: fmt.Sprintf("connection pool size must be positive, got %d", config.ConnectionPoolSize)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateMonitoringThresholdsConfig validates monitoring thresholds configuration.
func validateMonitoringThresholdsConfig(config *MonitoringThresholdsConfig) error <span class="cov8" title="1">{
        if config.MemoryUsagePercent &lt;= 0 || config.MemoryUsagePercent &gt; 100 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.monitoring_thresholds.memory_usage_percent", Message: fmt.Sprintf("memory usage percent must be between 0 and 100, got %f", config.MemoryUsagePercent)}
        }</span>

        <span class="cov8" title="1">if config.ErrorRatePercent &lt; 0 || config.ErrorRatePercent &gt; 100 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.monitoring_thresholds.error_rate_percent", Message: fmt.Sprintf("error rate percent must be between 0 and 100, got %f", config.ErrorRatePercent)}
        }</span>

        <span class="cov8" title="1">if config.AverageResponseTimeMs &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.monitoring_thresholds.average_response_time_ms", Message: fmt.Sprintf("average response time must be positive, got %f", config.AverageResponseTimeMs)}
        }</span>

        <span class="cov8" title="1">if config.ActiveConnectionsLimit &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.monitoring_thresholds.active_connections_limit", Message: fmt.Sprintf("active connections limit must be positive, got %d", config.ActiveConnectionsLimit)}
        }</span>

        <span class="cov8" title="1">if config.GoroutinesLimit &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.monitoring_thresholds.goroutines_limit", Message: fmt.Sprintf("goroutines limit must be positive, got %d", config.GoroutinesLimit)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateDebounceConfig validates debounce configuration.
func validateDebounceConfig(config *DebounceConfig) error <span class="cov8" title="1">{
        if config.HealthMonitorSeconds &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.debounce.health_monitor_seconds", Message: fmt.Sprintf("health monitor debounce seconds must be positive, got %d", config.HealthMonitorSeconds)}
        }</span>

        <span class="cov8" title="1">if config.StorageMonitorSeconds &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.debounce.storage_monitor_seconds", Message: fmt.Sprintf("storage monitor debounce seconds must be positive, got %d", config.StorageMonitorSeconds)}
        }</span>

        <span class="cov8" title="1">if config.PerformanceMonitorSeconds &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "performance.debounce.performance_monitor_seconds", Message: fmt.Sprintf("performance monitor debounce seconds must be positive, got %d", config.PerformanceMonitorSeconds)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateRetentionPolicyConfig validates retention policy configuration.
func validateRetentionPolicyConfig(config *RetentionPolicyConfig) error <span class="cov8" title="1">{
        // Validate policy type
        validTypes := []string{"age", "size", "manual"}
        if !contains(validTypes, config.Type) </span><span class="cov8" title="1">{
                return &amp;ValidationError{Field: "retention_policy.type", Message: fmt.Sprintf("policy type must be one of %v, got %s", validTypes, config.Type)}
        }</span>

        // Validate age-based policy parameters
        <span class="cov8" title="1">if config.Type == "age" </span><span class="cov8" title="1">{
                if config.MaxAgeDays &lt; 0 </span><span class="cov8" title="1">{
                        return &amp;ValidationError{Field: "retention_policy.max_age_days", Message: fmt.Sprintf("max age days cannot be negative for age-based policy, got %d", config.MaxAgeDays)}
                }</span>
                <span class="cov8" title="1">if config.MaxAgeDays &gt; 0 &amp;&amp; config.MaxAgeDays &gt; 365 </span><span class="cov8" title="1">{
                        return &amp;ValidationError{Field: "retention_policy.max_age_days", Message: fmt.Sprintf("max age days cannot exceed 365 days, got %d", config.MaxAgeDays)}
                }</span>
        }

        // Validate size-based policy parameters
        <span class="cov8" title="1">if config.Type == "size" </span><span class="cov0" title="0">{
                if config.MaxSizeGB &lt;= 0 </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Field: "retention_policy.max_size_gb", Message: fmt.Sprintf("max size GB must be positive for size-based policy, got %d", config.MaxSizeGB)}
                }</span>
                <span class="cov0" title="0">if config.MaxSizeGB &gt; 1000 </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Field: "retention_policy.max_size_gb", Message: fmt.Sprintf("max size GB cannot exceed 1000 GB, got %d", config.MaxSizeGB)}
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateSecurityConfig validates security configuration.
func validateSecurityConfig(config *SecurityConfig) error <span class="cov8" title="1">{
        // Validate JWT secret key
        if strings.TrimSpace(config.JWTSecretKey) == "" </span><span class="cov8" title="1">{
                return &amp;ValidationError{Field: "security.jwt_secret_key", Message: "JWT secret key cannot be empty"}
        }</span>

        // Validate JWT expiry hours
        <span class="cov8" title="1">if config.JWTExpiryHours &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "security.jwt_expiry_hours", Message: fmt.Sprintf("JWT expiry hours must be positive, got %d", config.JWTExpiryHours)}
        }</span>

        // Validate rate limit requests
        <span class="cov8" title="1">if config.RateLimitRequests &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "security.rate_limit_requests", Message: fmt.Sprintf("rate limit requests must be positive, got %d", config.RateLimitRequests)}
        }</span>

        // Validate rate limit window
        <span class="cov8" title="1">if config.RateLimitWindow &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "security.rate_limit_window", Message: fmt.Sprintf("rate limit window must be positive, got %v", config.RateLimitWindow)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateServerDefaults validates server defaults configuration.
func validateServerDefaults(config *ServerDefaults) error <span class="cov8" title="1">{
        // Validate shutdown timeout
        if config.ShutdownTimeout &lt; 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "server_defaults.shutdown_timeout", Message: fmt.Sprintf("shutdown timeout cannot be negative, got %f", config.ShutdownTimeout)}
        }</span>

        // Validate camera monitor ticker
        <span class="cov8" title="1">if config.CameraMonitorTicker &lt; 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "server_defaults.camera_monitor_ticker", Message: fmt.Sprintf("camera monitor ticker cannot be negative, got %f", config.CameraMonitorTicker)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateStorageConfig validates storage configuration.
func validateStorageConfig(config *StorageConfig) error <span class="cov8" title="1">{
        // Validate warn and block percentages
        if config.WarnPercent &lt; 0 || config.WarnPercent &gt; 100 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "storage.warn_percent", Message: fmt.Sprintf("warn percent must be between 0 and 100, got %d", config.WarnPercent)}
        }</span>

        <span class="cov8" title="1">if config.BlockPercent &lt; 0 || config.BlockPercent &gt; 100 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "storage.block_percent", Message: fmt.Sprintf("block percent must be between 0 and 100, got %d", config.BlockPercent)}
        }</span>

        // Ensure warn percent is less than block percent
        <span class="cov8" title="1">if config.WarnPercent &gt;= config.BlockPercent </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "storage.warn_percent", Message: fmt.Sprintf("warn percent (%d) must be less than block percent (%d)", config.WarnPercent, config.BlockPercent)}
        }</span>

        // Validate storage paths
        <span class="cov8" title="1">if config.DefaultPath != "" </span><span class="cov8" title="1">{
                if err := validateStoragePath("storage.default_path", config.DefaultPath); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if config.FallbackPath != "" </span><span class="cov8" title="1">{
                if err := validateStoragePath("storage.fallback_path", config.FallbackPath); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateStoragePath validates that a storage path is valid, secure, and accessible
func validateStoragePath(fieldName, path string) error <span class="cov8" title="1">{
        if strings.TrimSpace(path) == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: fieldName, Message: "storage path cannot be empty"}
        }</span>

        // Clean the path to prevent path traversal attacks
        <span class="cov8" title="1">cleanPath := filepath.Clean(path)
        if cleanPath != path </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: fieldName, Message: fmt.Sprintf("storage path contains invalid characters or traversal attempts: %s", path)}
        }</span>

        // Check if path is absolute (recommended for security)
        <span class="cov8" title="1">if !filepath.IsAbs(cleanPath) </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: fieldName, Message: fmt.Sprintf("storage path should be absolute for security: %s", path)}
        }</span>

        // Check if path exists on filesystem
        <span class="cov8" title="1">if _, err := os.Stat(cleanPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: fieldName, Message: fmt.Sprintf("storage path does not exist: %s", path)}
        }</span>

        // Check if path is accessible (readable and writable for storage)
        <span class="cov8" title="1">if _, err := os.Stat(cleanPath); err != nil </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: fieldName, Message: fmt.Sprintf("storage path is not accessible: %s - %v", path, err)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateRTSPMonitoringConfig validates RTSP monitoring configuration
func validateRTSPMonitoringConfig(config *RTSPMonitoringConfig) error <span class="cov8" title="1">{
        if config.CheckInterval &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.rtsp_monitoring.check_interval", Message: fmt.Sprintf("check interval must be positive, got %d", config.CheckInterval)}
        }</span>

        <span class="cov8" title="1">if config.ConnectionTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.rtsp_monitoring.connection_timeout", Message: fmt.Sprintf("connection timeout must be positive, got %d", config.ConnectionTimeout)}
        }</span>

        <span class="cov8" title="1">if config.MaxConnections &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.rtsp_monitoring.max_connections", Message: fmt.Sprintf("max connections must be positive, got %d", config.MaxConnections)}
        }</span>

        <span class="cov8" title="1">if config.SessionTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.rtsp_monitoring.session_timeout", Message: fmt.Sprintf("session timeout must be positive, got %d", config.SessionTimeout)}
        }</span>

        <span class="cov8" title="1">if config.BandwidthThreshold &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.rtsp_monitoring.bandwidth_threshold", Message: fmt.Sprintf("bandwidth threshold must be positive, got %d", config.BandwidthThreshold)}
        }</span>

        <span class="cov8" title="1">if config.PacketLossThreshold &lt; 0 || config.PacketLossThreshold &gt; 1 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.rtsp_monitoring.packet_loss_threshold", Message: fmt.Sprintf("packet loss threshold must be between 0 and 1, got %f", config.PacketLossThreshold)}
        }</span>

        <span class="cov8" title="1">if config.JitterThreshold &lt; 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "mediamtx.rtsp_monitoring.jitter_threshold", Message: fmt.Sprintf("jitter threshold must be non-negative, got %f", config.JitterThreshold)}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidatePathConfiguration validates all path-related configuration
func ValidatePathConfiguration(config *Config) error <span class="cov8" title="1">{
        // Validate MediaMTX paths
        if err := validatePath("recordings_path", config.MediaMTX.RecordingsPath, true); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid recordings path: %w", err)
        }</span>

        <span class="cov8" title="1">if err := validatePath("snapshots_path", config.MediaMTX.SnapshotsPath, true); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid snapshots path: %w", err)
        }</span>

        // Validate storage paths
        <span class="cov8" title="1">if err := validatePath("storage.default_path", config.Storage.DefaultPath, false); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid storage default path: %w", err)
        }</span>

        <span class="cov8" title="1">if err := validatePath("storage.fallback_path", config.Storage.FallbackPath, false); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid storage fallback path: %w", err)
        }</span>

        // Validate recording configuration
        <span class="cov8" title="1">if err := validatePathPattern(config.Recording.FileNamePattern); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid recording file pattern: %w", err)
        }</span>

        <span class="cov8" title="1">if err := validateRecordFormat(config.Recording.RecordFormat); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid recording format: %w", err)
        }</span>

        // Validate snapshots configuration
        <span class="cov8" title="1">if err := validatePathPattern(config.Snapshots.FileNamePattern); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid snapshot file pattern: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validatePath validates a single path configuration
func validatePath(name string, path string, createIfMissing bool) error <span class="cov8" title="1">{
        // 1. Check if path is absolute
        if !filepath.IsAbs(path) </span><span class="cov8" title="1">{
                return fmt.Errorf("%s must be an absolute path, got: %s", name, path)
        }</span>

        // 2. Check for path traversal attempts
        <span class="cov8" title="1">cleanPath := filepath.Clean(path)
        if strings.Contains(cleanPath, "..") </span><span class="cov0" title="0">{
                return fmt.Errorf("%s contains path traversal: %s", name, path)
        }</span>

        // 3. Check if path exists
        <span class="cov8" title="1">info, err := os.Stat(path)
        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                if createIfMissing </span><span class="cov0" title="0">{
                        // Try to create the directory
                        if err := os.MkdirAll(path, 0755); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("%s does not exist and cannot be created: %w", name, err)
                        }</span>
                        <span class="cov0" title="0">info, _ = os.Stat(path)</span> // Re-stat after creation
                } else<span class="cov8" title="1"> {
                        return fmt.Errorf("%s does not exist: %s", name, path)
                }</span>
        } else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot access %s: %w", name, err)
        }</span>

        // 4. Check if it's a directory
        <span class="cov8" title="1">if info != nil &amp;&amp; !info.IsDir() </span><span class="cov0" title="0">{
                return fmt.Errorf("%s is not a directory: %s", name, path)
        }</span>

        // 5. Check write permissions
        <span class="cov8" title="1">if err := checkWritePermission(path); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%s is not writable: %w", name, err)
        }</span>

        // 6. Check available space (warning only)
        <span class="cov8" title="1">if err := checkDiskSpace(path); err != nil </span><span class="cov0" title="0">{
                // Log warning but don't fail
                logging.GetLogger("config").WithError(err).Warn("Low disk space warning")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// checkWritePermission tests if we can write to the directory
func checkWritePermission(path string) error <span class="cov8" title="1">{
        // Create a temporary test file
        testFile := filepath.Join(path, fmt.Sprintf(".write_test_%d", os.Getpid()))

        // Try to create and immediately delete the test file
        file, err := os.Create(testFile)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot write to directory: %w", err)
        }</span>
        <span class="cov8" title="1">file.Close()

        // Clean up test file
        if err := os.Remove(testFile); err != nil </span><span class="cov0" title="0">{
                // Log but don't fail - file was created successfully
                logging.GetLogger("config").WithError(err).Debug("Could not remove test file")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// checkDiskSpace checks available disk space
func checkDiskSpace(path string) error <span class="cov8" title="1">{
        // Get disk usage statistics
        var stat syscall.Statfs_t
        if err := syscall.Statfs(path, &amp;stat); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot check disk space: %w", err)
        }</span>

        // Calculate available space in bytes
        <span class="cov8" title="1">available := stat.Bavail * uint64(stat.Bsize)

        // Warn if less than 1GB available
        const minSpace = 1 &lt;&lt; 30 // 1GB
        if available &lt; minSpace </span><span class="cov0" title="0">{
                availableMB := available / (1 &lt;&lt; 20)
                return fmt.Errorf("low disk space: only %d MB available", availableMB)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validatePathPattern validates file naming patterns for security
func validatePathPattern(pattern string) error <span class="cov8" title="1">{
        // Allow empty patterns - they will use defaults
        if pattern == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Check for dangerous characters that could lead to path traversal
        <span class="cov8" title="1">dangerous := []string{"..", "/", "\\", "\n", "\r", "\x00"}
        for _, char := range dangerous </span><span class="cov8" title="1">{
                if strings.Contains(pattern, char) </span><span class="cov8" title="1">{
                        return fmt.Errorf("pattern contains dangerous character: %q", char)
                }</span>
        }

        // Check pattern length
        <span class="cov8" title="1">if len(pattern) &gt; 255 </span><span class="cov0" title="0">{
                return fmt.Errorf("pattern too long: %d characters (max 255)", len(pattern))
        }</span>

        // Check for any % variables that aren't in our valid list
        // Match only the exact valid variables to avoid false positives like %d_
        <span class="cov8" title="1">validVarsPattern := `%(?:path|device|Y|m|d|H|M|S|timestamp)`
        validVarsRe := regexp.MustCompile(validVarsPattern)
        
        // Find all % variables in the pattern
        allVarsRe := regexp.MustCompile(`%[a-zA-Z_]+`)
        allMatches := allVarsRe.FindAllString(pattern, -1)
        
        for _, match := range allMatches </span><span class="cov8" title="1">{
                if !validVarsRe.MatchString(match) </span><span class="cov0" title="0">{
                        return fmt.Errorf("pattern contains invalid variable: %s", match)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateRecordFormat validates recording format
func validateRecordFormat(format string) error <span class="cov8" title="1">{
        validFormats := []string{"fmp4", "mp4", "mpegts", "ts"}

        for _, validFormat := range validFormats </span><span class="cov8" title="1">{
                if format == validFormat </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }

        <span class="cov8" title="1">return fmt.Errorf("invalid record format: %s, must be one of: %s", format, strings.Join(validFormats, ", "))</span>
}

// contains checks if a slice contains a specific value.
func contains(slice []string, value string) bool <span class="cov8" title="1">{
        for _, item := range slice </span><span class="cov8" title="1">{
                if item == value </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "os"
        "path/filepath"
        "strings"
        "testing"

        "github.com/stretchr/testify/require"
)

// TestConfigHelper provides utilities for testing configuration management
type TestConfigHelper struct {
        t            *testing.T
        fixturesPath string
        tempDir      string
}

// NewTestConfigHelper creates a new test configuration helper
func NewTestConfigHelper(t *testing.T) *TestConfigHelper <span class="cov8" title="1">{
        // Get the fixtures path relative to the project root
        projectRoot := getProjectRoot()
        fixturesPath := filepath.Join(projectRoot, "tests", "fixtures")

        // Create temporary directory for test files
        tempDir := t.TempDir()

        return &amp;TestConfigHelper{
                t:            t,
                fixturesPath: fixturesPath,
                tempDir:      tempDir,
        }
}</span>

// LoadFixtureConfig loads a configuration file from the fixtures directory
func (h *TestConfigHelper) LoadFixtureConfig(fixtureName string) string <span class="cov8" title="1">{
        fixturePath := filepath.Join(h.fixturesPath, fixtureName)
        content, err := os.ReadFile(fixturePath)
        require.NoError(h.t, err, "Failed to read fixture: %s", fixtureName)
        return string(content)
}</span>

// CreateTempConfigFile creates a temporary configuration file with the given content
func (h *TestConfigHelper) CreateTempConfigFile(content string) string <span class="cov8" title="1">{
        tempFile := filepath.Join(h.tempDir, "test_config.yaml")
        err := os.WriteFile(tempFile, []byte(content), 0644)
        require.NoError(h.t, err, "Failed to create temporary config file")
        return tempFile
}</span>

// CreateTestDirectories creates the directories needed for test configuration validation
func (h *TestConfigHelper) CreateTestDirectories() <span class="cov8" title="1">{
        // Create directories that the config validation expects to exist
        dirs := []string{
                "/tmp/mediamtx.yml",
                "/tmp/recordings",
                "/tmp/snapshots",
                "/tmp/camera-service.log",
        }

        for _, dir := range dirs </span><span class="cov8" title="1">{
                // For files, create the parent directory
                if strings.HasSuffix(dir, ".yml") || strings.HasSuffix(dir, ".log") </span><span class="cov8" title="1">{
                        parentDir := filepath.Dir(dir)
                        err := os.MkdirAll(parentDir, 0755)
                        require.NoError(h.t, err, "Failed to create directory: %s", parentDir)

                        // Create empty file
                        _, err = os.Create(dir)
                        require.NoError(h.t, err, "Failed to create file: %s", dir)
                }</span> else<span class="cov8" title="1"> {
                        // For directories, create them
                        err := os.MkdirAll(dir, 0755)
                        require.NoError(h.t, err, "Failed to create directory: %s", dir)
                }</span>
        }
}

// CreateTempConfigFromFixture creates a temporary config file from a fixture
func (h *TestConfigHelper) CreateTempConfigFromFixture(fixtureName string) string <span class="cov8" title="1">{
        content := h.LoadFixtureConfig(fixtureName)
        return h.CreateTempConfigFile(content)
}</span>

// CleanupEnvironment cleans up environment variables that might interfere with tests
func (h *TestConfigHelper) CleanupEnvironment() <span class="cov8" title="1">{
        envVars := []string{
                "CAMERA_SERVICE_SERVER_HOST",
                "CAMERA_SERVICE_SERVER_PORT",
                "CAMERA_SERVICE_SERVER_WEBSOCKET_PATH",
                "CAMERA_SERVICE_SERVER_MAX_CONNECTIONS",
                "CAMERA_SERVICE_MEDIAMTX_HOST",
                "CAMERA_SERVICE_MEDIAMTX_API_PORT",
                "CAMERA_SERVICE_MEDIAMTX_RTSP_PORT",
                "CAMERA_SERVICE_MEDIAMTX_WEBRTC_PORT",
                "CAMERA_SERVICE_MEDIAMTX_HLS_PORT",
                "CAMERA_SERVICE_MEDIAMTX_CONFIG_PATH",
                "CAMERA_SERVICE_MEDIAMTX_RECORDINGS_PATH",
                "CAMERA_SERVICE_MEDIAMTX_SNAPSHOTS_PATH",
                "CAMERA_SERVICE_MEDIAMTX_HEALTH_CHECK_INTERVAL",
                "CAMERA_SERVICE_MEDIAMTX_HEALTH_FAILURE_THRESHOLD",
                "CAMERA_SERVICE_MEDIAMTX_HEALTH_CIRCUIT_BREAKER_TIMEOUT",
                "CAMERA_SERVICE_MEDIAMTX_HEALTH_MAX_BACKOFF_INTERVAL",
                "CAMERA_SERVICE_MEDIAMTX_HEALTH_RECOVERY_CONFIRMATION_THRESHOLD",
                "CAMERA_SERVICE_MEDIAMTX_BACKOFF_BASE_MULTIPLIER",
                "CAMERA_SERVICE_MEDIAMTX_PROCESS_TERMINATION_TIMEOUT",
                "CAMERA_SERVICE_MEDIAMTX_PROCESS_KILL_TIMEOUT",
                "CAMERA_SERVICE_CAMERA_POLL_INTERVAL",
                "CAMERA_SERVICE_CAMERA_DETECTION_TIMEOUT",
                "CAMERA_SERVICE_CAMERA_ENABLE_CAPABILITY_DETECTION",
                "CAMERA_SERVICE_CAMERA_AUTO_START_STREAMS",
                "CAMERA_SERVICE_CAMERA_CAPABILITY_TIMEOUT",
                "CAMERA_SERVICE_CAMERA_CAPABILITY_RETRY_INTERVAL",
                "CAMERA_SERVICE_CAMERA_CAPABILITY_MAX_RETRIES",
                "CAMERA_SERVICE_LOGGING_LEVEL",
                "CAMERA_SERVICE_LOGGING_FORMAT",
                "CAMERA_SERVICE_LOGGING_FILE_ENABLED",
                "CAMERA_SERVICE_LOGGING_FILE_PATH",
                "CAMERA_SERVICE_LOGGING_CONSOLE_ENABLED",
                "CAMERA_SERVICE_RECORDING_ENABLED",
                "CAMERA_SERVICE_RECORDING_FORMAT",
                "CAMERA_SERVICE_RECORDING_QUALITY",
                "CAMERA_SERVICE_SNAPSHOTS_ENABLED",
                "CAMERA_SERVICE_SNAPSHOTS_FORMAT",
                "CAMERA_SERVICE_SNAPSHOTS_QUALITY",
                "CAMERA_SERVICE_ENABLE_HOT_RELOAD",
                "CAMERA_SERVICE_ENV",
        }

        for _, envVar := range envVars </span><span class="cov8" title="1">{
                os.Unsetenv(envVar)
        }</span>
}

// SetEnvironmentVariable sets a specific environment variable for testing
func (h *TestConfigHelper) SetEnvironmentVariable(key, value string) <span class="cov8" title="1">{
        os.Setenv(key, value)
}</span>

// getProjectRoot finds the project root directory by looking for go.mod
func getProjectRoot() string <span class="cov8" title="1">{
        dir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                panic("Failed to get current working directory")</span>
        }

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil </span><span class="cov8" title="1">{
                        return dir
                }</span>

                <span class="cov8" title="1">parent := filepath.Dir(dir)
                if parent == dir </span><span class="cov0" title="0">{
                        panic("Could not find go.mod file")</span>
                }
                <span class="cov8" title="1">dir = parent</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
