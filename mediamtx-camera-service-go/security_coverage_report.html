
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>security: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/camerarecorder/mediamtx-camera-service-go/internal/security/jwt_handler.go (90.6%)</option>
				
				<option value="file1">github.com/camerarecorder/mediamtx-camera-service-go/internal/security/role_manager.go (93.3%)</option>
				
				<option value="file2">github.com/camerarecorder/mediamtx-camera-service-go/internal/security/session_manager.go (93.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package security

import (
        "fmt"
        "strings"
        "sync"
        "time"

        "github.com/golang-jwt/jwt/v4"
        "github.com/sirupsen/logrus"
)

// JWTClaims represents the claims structure for JWT tokens.
// Mirrors the Python JWTClaims dataclass structure for compatibility.
type JWTClaims struct {
        UserID string `json:"user_id"`
        Role   string `json:"role"`
        IAT    int64  `json:"iat"`
        EXP    int64  `json:"exp"`
}

// ValidRoles defines the valid user roles in the system.
// Follows the Python VALID_ROLES set for compatibility.
var ValidRoles = map[string]bool{
        "viewer":   true,
        "operator": true,
        "admin":    true,
}

// ClientRateInfo represents rate limiting information for a client
type ClientRateInfo struct {
        ClientID     string
        RequestCount int64
        LastRequest  time.Time
        WindowStart  time.Time
}

// JWTHandler manages JWT token generation and validation.
// Implements JWT authentication with HS256 algorithm, configurable expiry,
// role-based access control, and rate limiting as specified in Architecture Decision AD-7.
type JWTHandler struct {
        secretKey string
        algorithm string
        logger    *logrus.Logger

        // Rate limiting extensions (Phase 1 enhancement)
        clientRates map[string]*ClientRateInfo
        rateMutex   sync.RWMutex
        rateLimit   int64         // Requests per window
        rateWindow  time.Duration // Time window for rate limiting
}

// NewJWTHandler creates a new JWT handler instance.
// Returns an error if the secret key is empty or invalid.
func NewJWTHandler(secretKey string) (*JWTHandler, error) <span class="cov8" title="1">{
        if strings.TrimSpace(secretKey) == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("secret key must be provided")
        }</span>

        <span class="cov8" title="1">handler := &amp;JWTHandler{
                secretKey: secretKey,
                algorithm: "HS256",
                logger:    logrus.New(),

                // Rate limiting initialization (Phase 1 enhancement)
                clientRates: make(map[string]*ClientRateInfo),
                rateLimit:   100,         // Default: 100 requests per window
                rateWindow:  time.Minute, // Default: 1 minute window
        }

        handler.logger.WithFields(logrus.Fields{
                "algorithm":   handler.algorithm,
                "rate_limit":  handler.rateLimit,
                "rate_window": handler.rateWindow,
        }).Info("JWT handler initialized with rate limiting")
        return handler, nil</span>
}

// GenerateToken creates a new JWT token with the specified claims.
// Returns the token string and any error encountered during generation.
func (h *JWTHandler) GenerateToken(userID, role string, expiryHours int) (string, error) <span class="cov8" title="1">{
        // Validate input parameters
        if strings.TrimSpace(userID) == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("user ID cannot be empty")
        }</span>

        <span class="cov8" title="1">if !ValidRoles[role] </span><span class="cov8" title="1">{
                return "", fmt.Errorf("invalid role: %s", role)
        }</span>

        <span class="cov8" title="1">if expiryHours &lt;= 0 </span><span class="cov8" title="1">{
                expiryHours = 24 // Default to 24 hours
        }</span>

        // Create claims with current timestamp
        <span class="cov8" title="1">now := time.Now().Unix()
        claims := JWTClaims{
                UserID: userID,
                Role:   role,
                IAT:    now,
                EXP:    now + int64(expiryHours*3600),
        }

        // Create JWT token
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
                "user_id": claims.UserID,
                "role":    claims.Role,
                "iat":     claims.IAT,
                "exp":     claims.EXP,
        })

        // Sign the token
        tokenString, err := token.SignedString([]byte(h.secretKey))
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("Failed to sign JWT token: %v", err)
                return "", fmt.Errorf("failed to generate token: %w", err)
        }</span>

        <span class="cov8" title="1">h.logger.WithFields(logrus.Fields{
                "user_id": userID,
                "role":    role,
                "expires": time.Unix(claims.EXP, 0).Format(time.RFC3339),
        }).Debug("JWT token generated successfully")

        return tokenString, nil</span>
}

// Rate limiting methods (Phase 1 enhancement)

// CheckRateLimit checks if a client has exceeded the rate limit
func (h *JWTHandler) CheckRateLimit(clientID string) bool <span class="cov8" title="1">{
        h.rateMutex.Lock()
        defer h.rateMutex.Unlock()

        now := time.Now()
        clientRate, exists := h.clientRates[clientID]

        if !exists </span><span class="cov8" title="1">{
                // First request for this client
                h.clientRates[clientID] = &amp;ClientRateInfo{
                        ClientID:     clientID,
                        RequestCount: 1,
                        LastRequest:  now,
                        WindowStart:  now,
                }
                return true
        }</span>

        // Check if we're in a new time window
        <span class="cov8" title="1">if now.Sub(clientRate.WindowStart) &gt;= h.rateWindow </span><span class="cov8" title="1">{
                // Reset for new window
                clientRate.RequestCount = 1
                clientRate.WindowStart = now
                clientRate.LastRequest = now
                return true
        }</span>

        // Check if within rate limit
        <span class="cov8" title="1">if clientRate.RequestCount &gt;= h.rateLimit </span><span class="cov8" title="1">{
                h.logger.WithFields(logrus.Fields{
                        "client_id":     clientID,
                        "request_count": clientRate.RequestCount,
                        "rate_limit":    h.rateLimit,
                        "window_start":  clientRate.WindowStart,
                }).Warn("Rate limit exceeded for client")
                return false
        }</span>

        // Increment request count
        <span class="cov8" title="1">clientRate.RequestCount++
        clientRate.LastRequest = now

        return true</span>
}

// RecordRequest records a request for rate limiting (alternative to CheckRateLimit)
func (h *JWTHandler) RecordRequest(clientID string) <span class="cov8" title="1">{
        h.rateMutex.Lock()
        defer h.rateMutex.Unlock()

        now := time.Now()
        clientRate, exists := h.clientRates[clientID]

        if !exists </span><span class="cov8" title="1">{
                h.clientRates[clientID] = &amp;ClientRateInfo{
                        ClientID:     clientID,
                        RequestCount: 1,
                        LastRequest:  now,
                        WindowStart:  now,
                }
                return
        }</span>

        // Check if we're in a new time window
        <span class="cov8" title="1">if now.Sub(clientRate.WindowStart) &gt;= h.rateWindow </span><span class="cov8" title="1">{
                clientRate.RequestCount = 1
                clientRate.WindowStart = now
                clientRate.LastRequest = now
                return
        }</span>

        <span class="cov8" title="1">clientRate.RequestCount++
        clientRate.LastRequest = now</span>
}

// GetClientRateInfo returns rate limiting information for a client
func (h *JWTHandler) GetClientRateInfo(clientID string) *ClientRateInfo <span class="cov8" title="1">{
        h.rateMutex.RLock()
        defer h.rateMutex.RUnlock()

        if clientRate, exists := h.clientRates[clientID]; exists </span><span class="cov8" title="1">{
                // Return a copy to avoid race conditions
                return &amp;ClientRateInfo{
                        ClientID:     clientRate.ClientID,
                        RequestCount: clientRate.RequestCount,
                        LastRequest:  clientRate.LastRequest,
                        WindowStart:  clientRate.WindowStart,
                }
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SetRateLimit configures the rate limiting parameters
func (h *JWTHandler) SetRateLimit(limit int64, window time.Duration) <span class="cov8" title="1">{
        h.rateMutex.Lock()
        defer h.rateMutex.Unlock()

        h.rateLimit = limit
        h.rateWindow = window

        h.logger.WithFields(logrus.Fields{
                "rate_limit":  limit,
                "rate_window": window,
        }).Info("Rate limiting configuration updated")
}</span>

// CleanupExpiredClients removes rate limiting data for inactive clients
func (h *JWTHandler) CleanupExpiredClients(maxInactive time.Duration) <span class="cov8" title="1">{
        h.rateMutex.Lock()
        defer h.rateMutex.Unlock()

        now := time.Now()
        expiredClients := []string{}

        for clientID, clientRate := range h.clientRates </span><span class="cov8" title="1">{
                if now.Sub(clientRate.LastRequest) &gt; maxInactive </span><span class="cov8" title="1">{
                        expiredClients = append(expiredClients, clientID)
                }</span>
        }

        <span class="cov8" title="1">for _, clientID := range expiredClients </span><span class="cov8" title="1">{
                delete(h.clientRates, clientID)
        }</span>

        <span class="cov8" title="1">if len(expiredClients) &gt; 0 </span><span class="cov8" title="1">{
                h.logger.WithField("expired_clients", len(expiredClients)).Debug("Cleaned up expired client rate limiting data")
        }</span>
}

// ValidateToken validates a JWT token and extracts claims.
// Returns the claims if valid, nil if invalid or expired.
// Matches Python implementation security model: uses JWT library validation with explicit algorithm restriction.
func (h *JWTHandler) ValidateToken(tokenString string) (*JWTClaims, error) <span class="cov8" title="1">{
        if strings.TrimSpace(tokenString) == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("token cannot be empty")
        }</span>

        // Use JWT library validation with explicit algorithm restriction (like Python)
        // This prevents algorithm confusion attacks and follows security best practices
        <span class="cov8" title="1">token, err := jwt.ParseWithClaims(tokenString, jwt.MapClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                // Validate algorithm explicitly (like Python's algorithms=[self.algorithm])
                if token.Method.Alg() != "HS256" </span><span class="cov8" title="1">{
                        h.logger.WithField("algorithm", token.Method.Alg()).Warn("Unsupported signing method detected")
                        return nil, fmt.Errorf("unsupported signing method: %v", token.Method.Alg())
                }</span>

                <span class="cov8" title="1">h.logger.WithField("signing_method", token.Method.Alg()).Debug("JWT signing method validated")
                return []byte(h.secretKey), nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                // Log the specific error for security auditing (like Python)
                h.logger.WithError(err).Warn("JWT token validation failed")

                // Return the original error for proper error handling (like Python)
                // Don't mask specific error types that could indicate security issues
                return nil, err
        }</span>

        // Extract claims
        <span class="cov8" title="1">claims, ok := token.Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Warn("JWT token claims are not MapClaims")
                return nil, fmt.Errorf("invalid token claims")
        }</span>

        <span class="cov8" title="1">if !token.Valid </span><span class="cov0" title="0">{
                h.logger.Warn("JWT token is not valid")
                return nil, fmt.Errorf("invalid token claims")
        }</span>

        // Validate required fields
        <span class="cov8" title="1">requiredFields := []string{"user_id", "role", "iat", "exp"}
        for _, field := range requiredFields </span><span class="cov8" title="1">{
                if _, exists := claims[field]; !exists </span><span class="cov8" title="1">{
                        h.logger.Warnf("JWT token missing required field: %s", field)
                        return nil, fmt.Errorf("missing required field: %s", field)
                }</span>
        }

        // Validate role
        <span class="cov8" title="1">role, ok := claims["role"].(string)
        if !ok || !ValidRoles[role] </span><span class="cov8" title="1">{
                h.logger.Warnf("JWT token has invalid role: %v", claims["role"])
                return nil, fmt.Errorf("invalid role: %v", claims["role"])
        }</span>

        // Extract and validate timestamps
        <span class="cov8" title="1">iat, ok := claims["iat"].(float64)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid issued at timestamp")
        }</span>

        <span class="cov8" title="1">exp, ok := claims["exp"].(float64)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid expiration timestamp")
        }</span>

        // Check if token is expired
        <span class="cov8" title="1">if time.Now().Unix() &gt; int64(exp) </span><span class="cov0" title="0">{
                h.logger.Warn("JWT token has expired")
                return nil, fmt.Errorf("token has expired")
        }</span>

        // Create JWTClaims structure
        <span class="cov8" title="1">jwtClaims := &amp;JWTClaims{
                UserID: claims["user_id"].(string),
                Role:   role,
                IAT:    int64(iat),
                EXP:    int64(exp),
        }

        h.logger.WithFields(logrus.Fields{
                "user_id": jwtClaims.UserID,
                "role":    jwtClaims.Role,
                "expires": time.Unix(jwtClaims.EXP, 0).Format(time.RFC3339),
        }).Debug("JWT token validated successfully")

        return jwtClaims, nil</span>
}

// IsTokenExpired checks if a JWT token is expired without full validation.
// Returns true if the token is expired, false otherwise.
func (h *JWTHandler) IsTokenExpired(tokenString string) bool <span class="cov8" title="1">{
        if strings.TrimSpace(tokenString) == "" </span><span class="cov8" title="1">{
                return true
        }</span>

        // Parse token without validation to extract claims
        <span class="cov8" title="1">token, _, err := new(jwt.Parser).ParseUnverified(tokenString, jwt.MapClaims{})
        if err != nil </span><span class="cov8" title="1">{
                h.logger.WithError(err).Debug("Failed to parse token for expiry check")
                return true
        }</span>

        <span class="cov8" title="1">claims, ok := token.Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">exp, ok := claims["exp"].(float64)
        if !ok </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return time.Now().Unix() &gt; int64(exp)</span>
}

// GetSecretKey returns the secret key used for JWT signing.
// This method is primarily used for testing purposes.
func (h *JWTHandler) GetSecretKey() string <span class="cov8" title="1">{
        return h.secretKey
}</span>

// GetAlgorithm returns the algorithm used for JWT signing.
func (h *JWTHandler) GetAlgorithm() string <span class="cov8" title="1">{
        return h.algorithm
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package security

import (
        "fmt"
        "strings"

        "github.com/sirupsen/logrus"
)

// Role represents the user role hierarchy in the system.
// Higher values indicate higher permissions.
type Role int

const (
        // RoleViewer represents read-only access to camera status and basic information.
        RoleViewer Role = iota + 1
        // RoleOperator represents viewer permissions plus camera control operations.
        RoleOperator
        // RoleAdmin represents full access to all features including system management.
        RoleAdmin
)

// RoleNames maps role constants to their string representations.
var RoleNames = map[Role]string{
        RoleViewer:   "viewer",
        RoleOperator: "operator",
        RoleAdmin:    "admin",
}

// StringRoleNames maps string role names to their Role constants.
var StringRoleNames = map[string]Role{
        "viewer":   RoleViewer,
        "operator": RoleOperator,
        "admin":    RoleAdmin,
}

// String returns the string representation of the role.
func (r Role) String() string <span class="cov8" title="1">{
        if name, exists := RoleNames[r]; exists </span><span class="cov8" title="1">{
                return name
        }</span>
        <span class="cov0" title="0">return "unknown"</span>
}

// PermissionChecker manages role-based access control for API methods.
// Implements method-level permission checking with role hierarchy enforcement.
type PermissionChecker struct {
        methodPermissions map[string]Role
        logger            *logrus.Logger
}

// NewPermissionChecker creates a new permission checker with default method permissions.
// Initializes the permission matrix based on the Python system's method permissions.
func NewPermissionChecker() *PermissionChecker <span class="cov8" title="1">{
        checker := &amp;PermissionChecker{
                methodPermissions: make(map[string]Role),
                logger:            logrus.New(),
        }

        // Initialize method permissions based on Python system
        // Viewer permissions (read-only operations)
        viewerMethods := []string{
                "ping",
                "get_camera_list",
                "get_camera_status",
                "list_recordings",
                "list_snapshots",
                "get_streams",
        }

        // Operator permissions (camera control operations)
        operatorMethods := []string{
                "take_snapshot",
                "start_recording",
                "stop_recording",
        }

        // Admin permissions (system management operations)
        adminMethods := []string{
                "get_metrics",
                "get_status",
                "get_server_info",
                "cleanup_old_files",
        }

        // Set permissions for each method
        for _, method := range viewerMethods </span><span class="cov8" title="1">{
                checker.methodPermissions[method] = RoleViewer
        }</span>

        <span class="cov8" title="1">for _, method := range operatorMethods </span><span class="cov8" title="1">{
                checker.methodPermissions[method] = RoleOperator
        }</span>

        <span class="cov8" title="1">for _, method := range adminMethods </span><span class="cov8" title="1">{
                checker.methodPermissions[method] = RoleAdmin
        }</span>

        <span class="cov8" title="1">checker.logger.WithField("method_count", len(checker.methodPermissions)).Info("Permission checker initialized")
        return checker</span>
}

// HasPermission checks if a user with the given role has permission to access the specified method.
// Returns true if the user has sufficient permissions, false otherwise.
func (p *PermissionChecker) HasPermission(userRole Role, method string) bool <span class="cov8" title="1">{
        if strings.TrimSpace(method) == "" </span><span class="cov0" title="0">{
                p.logger.Warn("Method name cannot be empty")
                return false
        }</span>

        <span class="cov8" title="1">requiredRole, exists := p.methodPermissions[method]
        if !exists </span><span class="cov8" title="1">{
                p.logger.Warnf("Method '%s' not found in permission matrix", method)
                return false
        }</span>

        <span class="cov8" title="1">hasPermission := userRole &gt;= requiredRole

        p.logger.WithFields(logrus.Fields{
                "method":         method,
                "user_role":      userRole.String(),
                "required_role":  requiredRole.String(),
                "has_permission": hasPermission,
        }).Debug("Permission check performed")

        return hasPermission</span>
}

// GetRequiredRole returns the minimum role required to access the specified method.
// Returns RoleAdmin if the method is not found in the permission matrix.
func (p *PermissionChecker) GetRequiredRole(method string) Role <span class="cov8" title="1">{
        if strings.TrimSpace(method) == "" </span><span class="cov8" title="1">{
                return RoleAdmin
        }</span>

        <span class="cov8" title="1">requiredRole, exists := p.methodPermissions[method]
        if !exists </span><span class="cov8" title="1">{
                p.logger.Warnf("Method '%s' not found in permission matrix", method)
                return RoleAdmin
        }</span>

        <span class="cov8" title="1">return requiredRole</span>
}

// ValidateRole validates a string role and converts it to a Role constant.
// Returns an error if the role string is invalid.
func (p *PermissionChecker) ValidateRole(roleString string) (Role, error) <span class="cov8" title="1">{
        if strings.TrimSpace(roleString) == "" </span><span class="cov8" title="1">{
                return RoleViewer, fmt.Errorf("role cannot be empty")
        }</span>

        <span class="cov8" title="1">role, exists := StringRoleNames[strings.ToLower(roleString)]
        if !exists </span><span class="cov8" title="1">{
                return RoleViewer, fmt.Errorf("invalid role: %s", roleString)
        }</span>

        <span class="cov8" title="1">return role, nil</span>
}

// GetRoleHierarchy returns the role hierarchy information.
// Useful for debugging and validation purposes.
func (p *PermissionChecker) GetRoleHierarchy() map[string]int <span class="cov8" title="1">{
        hierarchy := make(map[string]int)
        for role, name := range RoleNames </span><span class="cov8" title="1">{
                hierarchy[name] = int(role)
        }</span>
        <span class="cov8" title="1">return hierarchy</span>
}

// GetMethodPermissions returns a copy of the method permissions map.
// Useful for debugging and validation purposes.
func (p *PermissionChecker) GetMethodPermissions() map[string]string <span class="cov8" title="1">{
        permissions := make(map[string]string)
        for method, role := range p.methodPermissions </span><span class="cov8" title="1">{
                permissions[method] = role.String()
        }</span>
        <span class="cov8" title="1">return permissions</span>
}

// AddMethodPermission adds a new method permission to the checker.
// This method allows dynamic permission configuration.
func (p *PermissionChecker) AddMethodPermission(method string, requiredRole Role) error <span class="cov8" title="1">{
        if strings.TrimSpace(method) == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("method name cannot be empty")
        }</span>

        <span class="cov8" title="1">if requiredRole &lt; RoleViewer || requiredRole &gt; RoleAdmin </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid role: %d", requiredRole)
        }</span>

        <span class="cov8" title="1">p.methodPermissions[method] = requiredRole

        p.logger.WithFields(logrus.Fields{
                "method":        method,
                "required_role": requiredRole.String(),
        }).Info("Method permission added")

        return nil</span>
}

// RemoveMethodPermission removes a method permission from the checker.
// Returns an error if the method doesn't exist.
func (p *PermissionChecker) RemoveMethodPermission(method string) error <span class="cov8" title="1">{
        if strings.TrimSpace(method) == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("method name cannot be empty")
        }</span>

        <span class="cov8" title="1">if _, exists := p.methodPermissions[method]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("method '%s' not found in permission matrix", method)
        }</span>

        <span class="cov8" title="1">delete(p.methodPermissions, method)

        p.logger.WithField("method", method).Info("Method permission removed")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package security

import (
        "fmt"
        "sync"
        "time"

        "github.com/google/uuid"
        "github.com/sirupsen/logrus"
)

// Session represents a user session with authentication and activity tracking.
// Mirrors the Python session structure for compatibility.
type Session struct {
        SessionID    string    `json:"session_id"`
        UserID       string    `json:"user_id"`
        Role         Role      `json:"role"`
        CreatedAt    time.Time `json:"created_at"`
        ExpiresAt    time.Time `json:"expires_at"`
        LastActivity time.Time `json:"last_activity"`
}

// SessionManager manages user sessions with thread-safe operations.
// Implements session creation, validation, cleanup, and activity tracking.
type SessionManager struct {
        sessions map[string]*Session
        mu       sync.RWMutex
        logger   *logrus.Logger
        // Configuration
        defaultSessionTimeout time.Duration
        cleanupInterval       time.Duration
        // Cleanup control
        cleanupTicker *time.Ticker
        stopChan      chan struct{}
        wg            sync.WaitGroup
}

// NewSessionManager creates a new session manager with default configuration.
// Starts automatic cleanup of expired sessions.
func NewSessionManager() *SessionManager <span class="cov0" title="0">{
        manager := &amp;SessionManager{
                sessions:              make(map[string]*Session),
                logger:                logrus.New(),
                defaultSessionTimeout: 24 * time.Hour,  // Default 24 hours
                cleanupInterval:       5 * time.Minute, // Cleanup every 5 minutes
                stopChan:              make(chan struct{}),
        }

        // Start automatic cleanup
        manager.startCleanup()

        manager.logger.WithField("timeout", manager.defaultSessionTimeout).Info("Session manager initialized")
        return manager
}</span>

// NewSessionManagerWithConfig creates a new session manager with custom configuration.
func NewSessionManagerWithConfig(sessionTimeout, cleanupInterval time.Duration) *SessionManager <span class="cov8" title="1">{
        manager := &amp;SessionManager{
                sessions:              make(map[string]*Session),
                logger:                logrus.New(),
                defaultSessionTimeout: sessionTimeout,
                cleanupInterval:       cleanupInterval,
                stopChan:              make(chan struct{}),
        }

        // Start automatic cleanup
        manager.startCleanup()

        manager.logger.WithFields(logrus.Fields{
                "session_timeout":  sessionTimeout,
                "cleanup_interval": cleanupInterval,
        }).Info("Session manager initialized with custom configuration")

        return manager
}</span>

// CreateSession creates a new session for the specified user.
// Returns the session and any error encountered during creation.
func (sm *SessionManager) CreateSession(userID string, role Role) (*Session, error) <span class="cov8" title="1">{
        if userID == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("user ID cannot be empty")
        }</span>

        <span class="cov8" title="1">if role &lt; RoleViewer || role &gt; RoleAdmin </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid role: %d", role)
        }</span>

        <span class="cov8" title="1">now := time.Now()
        sessionID := uuid.New().String()

        session := &amp;Session{
                SessionID:    sessionID,
                UserID:       userID,
                Role:         role,
                CreatedAt:    now,
                ExpiresAt:    now.Add(sm.defaultSessionTimeout),
                LastActivity: now,
        }

        sm.mu.Lock()
        sm.sessions[sessionID] = session
        sm.mu.Unlock()

        sm.logger.WithFields(logrus.Fields{
                "session_id": sessionID,
                "user_id":    userID,
                "role":       role.String(),
                "expires_at": session.ExpiresAt.Format(time.RFC3339),
        }).Info("Session created successfully")

        return session, nil</span>
}

// ValidateSession validates a session and returns the session if valid.
// Returns nil if the session is invalid, expired, or not found.
func (sm *SessionManager) ValidateSession(sessionID string) (*Session, error) <span class="cov8" title="1">{
        if sessionID == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("session ID cannot be empty")
        }</span>

        <span class="cov8" title="1">sm.mu.RLock()
        session, exists := sm.sessions[sessionID]
        sm.mu.RUnlock()

        if !exists </span><span class="cov8" title="1">{
                sm.logger.WithField("session_id", sessionID).Debug("Session not found")
                return nil, fmt.Errorf("session not found")
        }</span>

        // Check if session is expired
        <span class="cov8" title="1">if time.Now().After(session.ExpiresAt) </span><span class="cov0" title="0">{
                sm.logger.WithField("session_id", sessionID).Debug("Session has expired")
                // Remove expired session
                sm.removeSession(sessionID)
                return nil, fmt.Errorf("session has expired")
        }</span>

        // Update last activity
        <span class="cov8" title="1">sm.UpdateActivity(sessionID)

        sm.logger.WithFields(logrus.Fields{
                "session_id": sessionID,
                "user_id":    session.UserID,
                "role":       session.Role.String(),
        }).Debug("Session validated successfully")

        return session, nil</span>
}

// UpdateActivity updates the last activity timestamp for a session.
// This method is thread-safe and can be called frequently.
func (sm *SessionManager) UpdateActivity(sessionID string) <span class="cov8" title="1">{
        if sessionID == "" </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">sm.mu.Lock()
        defer sm.mu.Unlock()

        if session, exists := sm.sessions[sessionID]; exists </span><span class="cov8" title="1">{
                session.LastActivity = time.Now()
        }</span>
}

// RemoveSession removes a session from the manager.
// This method is thread-safe and can be called from cleanup routines.
func (sm *SessionManager) removeSession(sessionID string) <span class="cov8" title="1">{
        sm.mu.Lock()
        defer sm.mu.Unlock()

        if _, exists := sm.sessions[sessionID]; exists </span><span class="cov8" title="1">{
                delete(sm.sessions, sessionID)
                sm.logger.WithField("session_id", sessionID).Debug("Session removed")
        }</span>
}

// CleanupExpiredSessions removes all expired sessions from the manager.
// This method is called automatically by the cleanup routine.
func (sm *SessionManager) CleanupExpiredSessions() <span class="cov8" title="1">{
        now := time.Now()
        expiredSessions := make([]string, 0)

        sm.mu.RLock()
        for sessionID, session := range sm.sessions </span><span class="cov8" title="1">{
                if now.After(session.ExpiresAt) </span><span class="cov8" title="1">{
                        expiredSessions = append(expiredSessions, sessionID)
                }</span>
        }
        <span class="cov8" title="1">sm.mu.RUnlock()

        // Remove expired sessions
        for _, sessionID := range expiredSessions </span><span class="cov8" title="1">{
                sm.removeSession(sessionID)
        }</span>

        <span class="cov8" title="1">if len(expiredSessions) &gt; 0 </span><span class="cov8" title="1">{
                sm.logger.WithField("expired_count", len(expiredSessions)).Info("Cleaned up expired sessions")
        }</span>
}

// startCleanup starts the automatic cleanup routine.
func (sm *SessionManager) startCleanup() <span class="cov8" title="1">{
        sm.cleanupTicker = time.NewTicker(sm.cleanupInterval)
        sm.wg.Add(1)

        go func() </span><span class="cov8" title="1">{
                defer sm.wg.Done()
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-sm.cleanupTicker.C:<span class="cov8" title="1">
                                sm.CleanupExpiredSessions()</span>
                        case &lt;-sm.stopChan:<span class="cov8" title="1">
                                return</span>
                        }
                }
        }()
}

// Stop stops the session manager and cleanup routine.
// This method should be called when shutting down the application.
func (sm *SessionManager) Stop() <span class="cov8" title="1">{
        if sm.cleanupTicker != nil </span><span class="cov8" title="1">{
                sm.cleanupTicker.Stop()
        }</span>
        <span class="cov8" title="1">close(sm.stopChan)
        sm.wg.Wait()

        sm.logger.Info("Session manager stopped")</span>
}

// GetSessionCount returns the current number of active sessions.
func (sm *SessionManager) GetSessionCount() int <span class="cov8" title="1">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()
        return len(sm.sessions)
}</span>

// GetSessionStats returns statistics about the current sessions.
func (sm *SessionManager) GetSessionStats() map[string]interface{} <span class="cov8" title="1">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()

        stats := map[string]interface{}{
                "total_sessions": len(sm.sessions),
                "role_counts":    make(map[string]int),
        }

        // Count sessions by role
        for _, session := range sm.sessions </span><span class="cov8" title="1">{
                roleName := session.Role.String()
                stats["role_counts"].(map[string]int)[roleName]++
        }</span>

        <span class="cov8" title="1">return stats</span>
}

// GetSessionByUserID returns all sessions for a specific user.
// Useful for debugging and session management.
func (sm *SessionManager) GetSessionByUserID(userID string) []*Session <span class="cov8" title="1">{
        if userID == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">sm.mu.RLock()
        defer sm.mu.RUnlock()

        var userSessions []*Session
        for _, session := range sm.sessions </span><span class="cov8" title="1">{
                if session.UserID == userID </span><span class="cov8" title="1">{
                        userSessions = append(userSessions, session)
                }</span>
        }

        <span class="cov8" title="1">return userSessions</span>
}

// InvalidateUserSessions invalidates all sessions for a specific user.
// Useful when a user's permissions change or for security purposes.
func (sm *SessionManager) InvalidateUserSessions(userID string) error <span class="cov8" title="1">{
        if userID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("user ID cannot be empty")
        }</span>

        <span class="cov8" title="1">sm.mu.Lock()
        defer sm.mu.Unlock()

        sessionsToRemove := make([]string, 0)
        for sessionID, session := range sm.sessions </span><span class="cov8" title="1">{
                if session.UserID == userID </span><span class="cov8" title="1">{
                        sessionsToRemove = append(sessionsToRemove, sessionID)
                }</span>
        }

        <span class="cov8" title="1">for _, sessionID := range sessionsToRemove </span><span class="cov8" title="1">{
                delete(sm.sessions, sessionID)
        }</span>

        <span class="cov8" title="1">sm.logger.WithFields(logrus.Fields{
                "user_id":              userID,
                "sessions_invalidated": len(sessionsToRemove),
        }).Info("User sessions invalidated")

        return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
